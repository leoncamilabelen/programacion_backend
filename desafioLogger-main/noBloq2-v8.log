v8-version,9,2,230,21,-node.19,0
shared-library,/usr/local/bin/node,0x106c39000,0x107ff05c3,113471488
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7ff8089a5080,0x7ff808b65bd8,140775424
shared-library,/usr/lib/libobjc.A.dylib,0x7ff8087ebb80,0x7ff808811fc3,140775424
shared-library,/usr/lib/liboah.dylib,0x7ff8136a5390,0x7ff8136aaeaa,140775424
shared-library,/usr/lib/libfakelink.dylib,0x7ff8136d8e30,0x7ff8136dbbc5,140775424
shared-library,/usr/lib/libicucore.A.dylib,0x7ff80ad04280,0x7ff80af1e63a,140775424
shared-library,/usr/lib/libSystem.B.dylib,0x7ff8136d773b,0x7ff8136d7cf0,140775424
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7ff8136dcc46,0x7ff8136dcebe,140775424
shared-library,/usr/lib/libc++abi.dylib,0x7ff80890a060,0x7ff80891be20,140775424
shared-library,/usr/lib/libc++.1.dylib,0x7ff8088b4e60,0x7ff8088ff170,140775424
shared-library,/usr/lib/system/libcache.dylib,0x7ff8136d1aa8,0x7ff8136d449e,140775424
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7ff81368e090,0x7ff813697eec,140775424
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7ff8136b6ff0,0x7ff8136bbadd,140775424
shared-library,/usr/lib/system/libcopyfile.dylib,0x7ff8136aca10,0x7ff8136b4440,140775424
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7ff8086e5840,0x7ff808754258,140775424
shared-library,/usr/lib/system/libdispatch.dylib,0x7ff8087a4310,0x7ff8087d97cd,140775424
shared-library,/usr/lib/system/libdyld.dylib,0x7ff808962d70,0x7ff80896cfc0,140775424
shared-library,/usr/lib/system/libkeymgr.dylib,0x7ff8136c8ae9,0x7ff8136c8f18,140775424
shared-library,/usr/lib/system/libmacho.dylib,0x7ff81366c4a0,0x7ff813670959,140775424
shared-library,/usr/lib/system/libquarantine.dylib,0x7ff812cf80f4,0x7ff812cf9cf8,140775424
shared-library,/usr/lib/system/libremovefile.dylib,0x7ff8136c6920,0x7ff8136c7d9b,140775424
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7ff80d8ca418,0x7ff80d8de715,140775424
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7ff8086932c6,0x7ff808693834,140775424
shared-library,/usr/lib/system/libsystem_c.dylib,0x7ff808827fb0,0x7ff8088a9456,140775424
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7ff8136befee,0x7ff8136c29dc,140775424
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7ff811fa0060,0x7ff811fa28c8,140775424
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7ff81125d2a4,0x7ff8112732bd,140775424
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7ff8133a8e10,0x7ff8133ac420,140775424
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7ff80af8d1b0,0x7ff80af93433,140775424
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7ff8136c9f78,0x7ff8136cf1be,140775424
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7ff808824fb3,0x7ff808826c7c,140775424
shared-library,/usr/lib/system/libsystem_info.dylib,0x7ff808979100,0x7ff80899e9d8,140775424
shared-library,/usr/lib/system/libsystem_m.dylib,0x7ff81360a280,0x7ff81363f03c,140775424
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7ff8087784d0,0x7ff80879a950,140775424
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7ff80d866c87,0x7ff80d877c08,140775424
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7ff80b3b4d54,0x7ff80b3c1ed6,140775424
shared-library,/usr/lib/system/libsystem_product_info_filter.dylib,0x7ff819847000,0x7ff819847000,140775424
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7ff811fa3820,0x7ff811fa7422,140775424
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7ff8136c3f8c,0x7ff8136c5520,140775424
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7ff80891f7c0,0x7ff80894507b,140775424
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7ff80896f040,0x7ff80897607f,140775424
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7ff8089570e0,0x7ff80895f7f7,140775424
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7ff80f121d74,0x7ff80f1274ce,140775424
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7ff8086cc7a0,0x7ff8086e1323,140775424
shared-library,/usr/lib/system/libunwind.dylib,0x7ff81369e5c0,0x7ff8136a348a,140775424
shared-library,/usr/lib/system/libxpc.dylib,0x7ff808695ce0,0x7ff8086bd061,140775424
profiler,begin,1000
tick,0x7ff80891faf6,1205,0,0x0,6
tick,0x1078fad83,2473,0,0x0,6
new,CodeRange,0x10ceee000,0
new,MemoryChunk,0x216c1fdc0000,262144
new,MemoryChunk,0x216c28400000,262144
new,MemoryChunk,0x216c85fc0000,262144
new,MemoryChunk,0x216cb6bc0000,262144
new,MemoryChunk,0x216c3c140000,262144
heap-capacity,1031072
heap-available,2198652736
new,MemoryChunk,0x216c014c0000,262144
new,MemoryChunk,0x216cd6d40000,262144
new,MemoryChunk,0x216cb0d00000,262144
new,MemoryChunk,0x216c14540000,262144
new,MemoryChunk,0x216c18bc0000,262144
new,MemoryChunk,0x216c4df80000,262144
new,MemoryChunk,0x216c9d840000,262144
new,MemoryChunk,0x10cf00000,262144
new,MemoryChunk,0x216c76000000,262144
code-creation,Builtin,2,10562,0x1076b56a0,1596,RecordWrite
code-creation,Builtin,2,10603,0x1076b5ce0,416,EphemeronKeyBarrier
code-creation,Builtin,2,10614,0x1076b5ea0,60,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,10625,0x1076b5ee0,364,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,10636,0x1076b6060,416,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,10647,0x1076b6220,444,CallFunction_ReceiverIsAny
code-creation,Builtin,2,10658,0x1076b63e0,104,CallBoundFunction
code-creation,Builtin,2,10667,0x1076b6460,120,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,10678,0x1076b64e0,120,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,10688,0x1076b6560,120,Call_ReceiverIsAny
code-creation,Builtin,2,10697,0x1076b65e0,1036,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,10708,0x1076b6a00,1032,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,10719,0x1076b6e20,1124,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,10731,0x1076b72a0,1120,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,10742,0x1076b7720,1124,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,10753,0x1076b7ba0,1120,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,10762,0x1076b8020,992,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,10774,0x1076b8420,992,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,10787,0x1076b8820,992,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,10798,0x1076b8c20,736,CallProxy
code-creation,Builtin,2,10806,0x1076b8f20,152,CallVarargs
code-creation,Builtin,2,10815,0x1076b8fc0,956,CallWithSpread
code-creation,Builtin,2,10823,0x1076b9380,2012,CallWithSpread_Baseline
code-creation,Builtin,2,10833,0x1076b9b60,1992,CallWithSpread_WithFeedback
code-creation,Builtin,2,10843,0x1076ba340,876,CallWithArrayLike
code-creation,Builtin,2,10852,0x1076ba6c0,1872,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,10862,0x1076bae20,160,CallForwardVarargs
code-creation,Builtin,2,10871,0x1076baee0,160,CallFunctionForwardVarargs
code-creation,Builtin,2,10881,0x1076bafa0,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,10891,0x1076bb040,228,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,10902,0x1076bb140,316,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,10914,0x1076bb280,28,ConstructFunction
code-creation,Builtin,2,10930,0x1076bb2a0,104,ConstructBoundFunction
code-creation,Builtin,2,10998,0x1076bb320,28,ConstructedNonConstructable
code-creation,Builtin,2,11011,0x1076bb340,100,Construct
code-creation,Builtin,2,11019,0x1076bb3c0,152,ConstructVarargs
code-creation,Builtin,2,11029,0x1076bb460,984,ConstructWithSpread
code-creation,Builtin,2,11217,0x1076bb840,1804,ConstructWithSpread_Baseline
code-creation,Builtin,2,11242,0x1076bbf60,1820,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,11254,0x1076bc680,936,ConstructWithArrayLike
code-creation,Builtin,2,12454,0x1076bca40,1716,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,12466,0x1076bd100,196,ConstructForwardVarargs
code-creation,Builtin,2,12477,0x1076bd1e0,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,12504,0x1076bd2c0,848,Construct_Baseline
code-creation,Builtin,2,12514,0x1076bd620,860,Construct_WithFeedback
code-creation,Builtin,2,12523,0x1076bd980,480,JSConstructStubGeneric
code-creation,Builtin,2,12533,0x1076bdb80,380,JSBuiltinsConstructStub
code-creation,Builtin,2,12543,0x1076bdd00,676,FastNewObject
code-creation,Builtin,2,12552,0x1076bdfc0,292,FastNewClosure
code-creation,Builtin,2,12560,0x1076be100,720,ConstructProxy
code-creation,Builtin,2,12570,0x1076be3e0,192,JSEntry
code-creation,Builtin,2,12578,0x1076be4c0,192,JSConstructEntry
code-creation,Builtin,2,12587,0x1076be5a0,192,JSRunMicrotasksEntry
code-creation,Builtin,2,12596,0x1076be680,96,JSEntryTrampoline
code-creation,Builtin,2,12605,0x1076be700,96,JSConstructEntryTrampoline
code-creation,Builtin,2,12615,0x1076be780,304,ResumeGeneratorTrampoline
code-creation,Builtin,2,12625,0x1076be8c0,1112,StringCodePointAt
code-creation,Builtin,2,12634,0x1076bed20,1560,StringFromCodePointAt
code-creation,Builtin,2,12643,0x1076bf340,544,StringEqual
code-creation,Builtin,2,12652,0x1076bf580,276,StringGreaterThan
code-creation,Builtin,2,12661,0x1076bf6a0,276,StringGreaterThanOrEqual
code-creation,Builtin,2,12670,0x1076bf7c0,276,StringLessThan
code-creation,Builtin,2,12679,0x1076bf8e0,276,StringLessThanOrEqual
code-creation,Builtin,2,12688,0x1076bfa00,2504,StringSubstring
code-creation,Builtin,2,12697,0x1076c03e0,84,OrderedHashTableHealIndex
code-creation,Builtin,2,12707,0x1076c0440,1200,InterpreterEntryTrampoline
code-creation,Builtin,2,12716,0x1076c0900,80,InterpreterPushArgsThenCall
code-creation,Builtin,2,12726,0x1076c0960,88,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,12737,0x1076c09c0,88,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,12748,0x1076c0a20,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,12758,0x1076c0a80,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,12769,0x1076c0ae0,88,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,12780,0x1076c0b40,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,12790,0x1076c0ba0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,12800,0x1076c0c80,52,InterpreterOnStackReplacement
code-creation,Builtin,2,12809,0x1076c0cc0,596,BaselineOutOfLinePrologue
code-creation,Builtin,2,12819,0x1076c0f20,56,BaselineOnStackReplacement
code-creation,Builtin,2,12828,0x1076c0f60,80,BaselineLeaveFrame
code-creation,Builtin,2,12838,0x1076c0fc0,192,BaselineEnterAtBytecode
code-creation,Builtin,2,12847,0x1076c10a0,200,BaselineEnterAtNextBytecode
code-creation,Builtin,2,12857,0x1076c1180,184,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,12867,0x1076c1240,1060,CompileLazy
code-creation,Builtin,2,12876,0x1076c1680,92,CompileLazyDeoptimizedCode
code-creation,Builtin,2,12885,0x1076c16e0,252,InstantiateAsmJs
code-creation,Builtin,2,12894,0x1076c17e0,32,NotifyDeoptimized
code-creation,Builtin,2,12903,0x1076c1820,788,DeoptimizationEntry_Eager
code-creation,Builtin,2,12913,0x1076c1b40,792,DeoptimizationEntry_Soft
code-creation,Builtin,2,13731,0x1076c1e60,792,DeoptimizationEntry_Bailout
code-creation,Builtin,2,13757,0x1076c2180,792,DeoptimizationEntry_Lazy
code-creation,Builtin,2,13768,0x1076c24a0,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,13778,0x1076c24e0,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,13789,0x1076c2520,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,13799,0x1076c2560,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,13809,0x1076c25c0,288,CallApiCallback
code-creation,Builtin,2,13818,0x1076c2700,272,CallApiGetter
code-creation,Builtin,2,13827,0x1076c2820,12,HandleApiCall
code-creation,Builtin,2,13836,0x1076c2840,12,HandleApiCallAsFunction
code-creation,Builtin,2,13872,0x1076c2860,12,HandleApiCallAsConstructor
code-creation,Builtin,2,13888,0x1076c2880,64,AllocateInYoungGeneration
code-creation,Builtin,2,13898,0x1076c28e0,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,13908,0x1076c2920,64,AllocateInOldGeneration
code-creation,Builtin,2,13935,0x1076c2980,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,13956,0x1076c29c0,444,CopyFastSmiOrObjectElements
code-creation,Builtin,2,13970,0x1076c2b80,512,GrowFastDoubleElements
code-creation,Builtin,2,13980,0x1076c2da0,416,GrowFastSmiOrObjectElements
code-creation,Builtin,2,13990,0x1076c2f60,412,DebugBreakTrampoline
code-creation,Builtin,2,13999,0x1076c3100,180,ToNumber
code-creation,Builtin,2,14008,0x1076c31c0,292,ToNumber_Baseline
code-creation,Builtin,2,14017,0x1076c3300,360,ToNumeric_Baseline
code-creation,Builtin,2,14026,0x1076c3480,104,PlainPrimitiveToNumber
code-creation,Builtin,2,14036,0x1076c3500,212,ToNumberConvertBigInt
code-creation,Builtin,2,14045,0x1076c35e0,132,Typeof
code-creation,Builtin,2,14054,0x1076c3680,104,BigIntToI64
code-creation,Builtin,2,14062,0x1076c3700,4,BigIntToI32Pair
code-creation,Builtin,2,14071,0x1076c3720,232,I64ToBigInt
code-creation,Builtin,2,14080,0x1076c3820,4,I32PairToBigInt
code-creation,Builtin,2,14089,0x1076c3840,100,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,14099,0x1076c38c0,208,TailCallOptimizedCodeSlot
code-creation,Builtin,2,14109,0x1076c39a0,3500,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,14119,0x1076c4760,16388,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,14128,0x1076c8780,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,14138,0x1076c88a0,60,LoadIC_FunctionPrototype
code-creation,Builtin,2,14147,0x1076c88e0,12,LoadIC_StringLength
code-creation,Builtin,2,14156,0x1076c8900,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,14166,0x1076c8920,3056,LoadIC_NoFeedback
code-creation,Builtin,2,14175,0x1076c9520,32,StoreGlobalIC_Slow
code-creation,Builtin,2,14184,0x1076c9560,7488,StoreIC_NoFeedback
code-creation,Builtin,2,14193,0x1076cb2c0,180,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,14203,0x1076cb380,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,14213,0x1076cb3e0,260,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,14224,0x1076cb500,260,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,14236,0x1076cb620,260,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,14247,0x1076cb740,260,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,14259,0x1076cb860,6716,StoreFastElementIC_Standard
code-creation,Builtin,2,14268,0x1076cd2a0,9984,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,14280,0x1076cf9c0,6712,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,14291,0x1076d1400,6532,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,14301,0x1076d2da0,8960,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,14312,0x1076d50c0,20096,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,14324,0x1076d9f60,8960,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,14335,0x1076dc280,11668,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,14346,0x1076df020,792,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,14356,0x1076df340,164,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,14366,0x1076df400,72,HasIndexedInterceptorIC
code-creation,Builtin,2,14375,0x1076df460,88,DynamicCheckMapsTrampoline
code-creation,Builtin,2,14385,0x1076df4c0,260,DynamicCheckMaps
code-creation,Builtin,2,14394,0x1076df5e0,148,EnqueueMicrotask
code-creation,Builtin,2,14403,0x1076df680,8,RunMicrotasksTrampoline
code-creation,Builtin,2,14412,0x1076df6a0,3536,RunMicrotasks
code-creation,Builtin,2,14421,0x1076e0480,2140,HasProperty
code-creation,Builtin,2,14429,0x1076e0ce0,1160,DeleteProperty
code-creation,Builtin,2,14438,0x1076e1180,1976,CopyDataProperties
code-creation,Builtin,2,14447,0x1076e1940,9364,SetDataProperties
code-creation,Builtin,2,14456,0x1076e3de0,28,Abort
code-creation,Builtin,2,14465,0x1076e3e00,28,AbortCSAAssert
code-creation,Builtin,2,14473,0x1076e3e20,12,EmptyFunction
code-creation,Builtin,2,14482,0x1076e3e40,12,Illegal
code-creation,Builtin,2,14490,0x1076e3e60,12,StrictPoisonPillThrower
code-creation,Builtin,2,22998,0x1076e3e80,12,UnsupportedThrower
code-creation,Builtin,2,23028,0x1076e3ea0,64,ReturnReceiver
code-creation,Builtin,2,23038,0x1076e3f00,28,ArrayConstructor
code-creation,Builtin,2,23048,0x1076e3f20,404,ArrayConstructorImpl
code-creation,Builtin,2,23057,0x1076e40c0,212,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,23069,0x1076e41a0,212,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,23081,0x1076e4280,176,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,23093,0x1076e4340,176,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,23105,0x1076e4400,176,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,23118,0x1076e44c0,176,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,23130,0x1076e4580,188,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,23142,0x1076e4640,188,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,23154,0x1076e4700,512,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,23172,0x1076e4920,476,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,23184,0x1076e4b00,436,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,23196,0x1076e4cc0,396,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,23209,0x1076e4e60,436,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,23221,0x1076e5020,396,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,23234,0x1076e51c0,448,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,23247,0x1076e53a0,412,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,23259,0x1076e5540,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,23269,0x1076e55a0,12,ArrayConcat
code-creation,Builtin,2,23278,0x1076e55c0,12,ArrayPrototypeFill
code-creation,Builtin,2,23287,0x1076e55e0,932,ArrayIncludesSmiOrObject
code-creation,Builtin,2,23296,0x1076e59a0,140,ArrayIncludesPackedDoubles
code-creation,Builtin,2,23306,0x1076e5a40,208,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,23316,0x1076e5b20,548,ArrayIncludes
code-creation,Builtin,2,23324,0x1076e5d60,856,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,23334,0x1076e60c0,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,23343,0x1076e6140,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,23353,0x1076e61c0,552,ArrayIndexOf
code-creation,Builtin,2,23361,0x1076e6400,12,ArrayPop
code-creation,Builtin,2,23370,0x1076e6420,612,ArrayPrototypePop
code-creation,Builtin,2,23379,0x1076e66a0,12,ArrayPush
code-creation,Builtin,2,23387,0x1076e66c0,2496,ArrayPrototypePush
code-creation,Builtin,2,23396,0x1076e70a0,12,ArrayShift
code-creation,Builtin,2,23405,0x1076e70c0,12,ArrayUnshift
code-creation,Builtin,2,23413,0x1076e70e0,968,CloneFastJSArray
code-creation,Builtin,2,23422,0x1076e74c0,2252,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,23432,0x1076e7da0,984,ExtractFastJSArray
code-creation,Builtin,2,23441,0x1076e8180,256,ArrayPrototypeEntries
code-creation,Builtin,2,23451,0x1076e82a0,248,ArrayPrototypeKeys
code-creation,Builtin,2,23460,0x1076e83a0,256,ArrayPrototypeValues
code-creation,Builtin,2,23469,0x1076e84c0,4008,ArrayIteratorPrototypeNext
code-creation,Builtin,2,23479,0x1076e9480,3632,FlattenIntoArray
code-creation,Builtin,2,23488,0x1076ea2c0,3636,FlatMapIntoArray
code-creation,Builtin,2,23497,0x1076eb100,372,ArrayPrototypeFlat
code-creation,Builtin,2,23506,0x1076eb280,428,ArrayPrototypeFlatMap
code-creation,Builtin,2,23515,0x1076eb440,12,ArrayBufferConstructor
code-creation,Builtin,2,23524,0x1076eb460,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,23535,0x1076eb480,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,23544,0x1076eb4a0,700,AsyncFunctionEnter
code-creation,Builtin,2,23554,0x1076eb760,132,AsyncFunctionReject
code-creation,Builtin,2,23563,0x1076eb800,128,AsyncFunctionResolve
code-creation,Builtin,2,23583,0x1076eb8a0,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,23593,0x1076eb8c0,2276,AsyncFunctionAwaitCaught
code-creation,Builtin,2,23603,0x1076ec1c0,2276,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,23613,0x1076ecac0,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,23623,0x1076ecb80,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,23633,0x1076ecc40,12,BigIntConstructor
code-creation,Builtin,2,23642,0x1076ecc60,12,BigIntAsUintN
code-creation,Builtin,2,23651,0x1076ecc80,12,BigIntAsIntN
code-creation,Builtin,2,23660,0x1076ecca0,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,23669,0x1076eccc0,12,BigIntPrototypeToString
code-creation,Builtin,2,23679,0x1076ecce0,12,BigIntPrototypeValueOf
code-creation,Builtin,2,23688,0x1076ecd00,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,23699,0x1076ecd20,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,23709,0x1076ecd40,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,23720,0x1076ecd60,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,23730,0x1076ecd80,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,23740,0x1076ecda0,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,23750,0x1076ecdc0,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,23760,0x1076ecde0,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,23770,0x1076ece00,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,23780,0x1076ece20,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,23790,0x1076ece40,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,23800,0x1076ece60,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,23811,0x1076ece80,12,CallSitePrototypeGetThis
code-creation,Builtin,2,23821,0x1076ecea0,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,23830,0x1076ecec0,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,23840,0x1076ecee0,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,23851,0x1076ecf00,12,CallSitePrototypeIsEval
code-creation,Builtin,2,23860,0x1076ecf20,12,CallSitePrototypeIsNative
code-creation,Builtin,2,23869,0x1076ecf40,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,23879,0x1076ecf60,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,23889,0x1076ecf80,12,CallSitePrototypeToString
code-creation,Builtin,2,23898,0x1076ecfa0,12,ConsoleDebug
code-creation,Builtin,2,23907,0x1076ecfc0,12,ConsoleError
code-creation,Builtin,2,23916,0x1076ecfe0,12,ConsoleInfo
code-creation,Builtin,2,23924,0x1076ed000,12,ConsoleLog
code-creation,Builtin,2,23933,0x1076ed020,12,ConsoleWarn
code-creation,Builtin,2,23941,0x1076ed040,12,ConsoleDir
code-creation,Builtin,2,23950,0x1076ed060,12,ConsoleDirXml
code-creation,Builtin,2,23958,0x1076ed080,12,ConsoleTable
code-creation,Builtin,2,23967,0x1076ed0a0,12,ConsoleTrace
code-creation,Builtin,2,23975,0x1076ed0c0,12,ConsoleGroup
code-creation,Builtin,2,23984,0x1076ed0e0,12,ConsoleGroupCollapsed
code-creation,Builtin,2,23994,0x1076ed100,12,ConsoleGroupEnd
code-creation,Builtin,2,24002,0x1076ed120,12,ConsoleClear
code-creation,Builtin,2,24011,0x1076ed140,12,ConsoleCount
code-creation,Builtin,2,24020,0x1076ed160,12,ConsoleCountReset
code-creation,Builtin,2,24029,0x1076ed180,12,ConsoleAssert
code-creation,Builtin,2,24037,0x1076ed1a0,12,ConsoleProfile
code-creation,Builtin,2,24046,0x1076ed1c0,12,ConsoleProfileEnd
code-creation,Builtin,2,24055,0x1076ed1e0,12,ConsoleTime
code-creation,Builtin,2,24064,0x1076ed200,12,ConsoleTimeLog
code-creation,Builtin,2,24073,0x1076ed220,12,ConsoleTimeEnd
code-creation,Builtin,2,24081,0x1076ed240,12,ConsoleTimeStamp
code-creation,Builtin,2,24090,0x1076ed260,12,ConsoleContext
code-creation,Builtin,2,24099,0x1076ed280,12,DataViewConstructor
code-creation,Builtin,2,24108,0x1076ed2a0,12,DateConstructor
code-creation,Builtin,2,24117,0x1076ed2c0,220,DatePrototypeGetDate
code-creation,Builtin,2,24126,0x1076ed3a0,220,DatePrototypeGetDay
code-creation,Builtin,2,24136,0x1076ed480,220,DatePrototypeGetFullYear
code-creation,Builtin,2,24155,0x1076ed560,220,DatePrototypeGetHours
code-creation,Builtin,2,24165,0x1076ed640,196,DatePrototypeGetMilliseconds
code-creation,Builtin,2,24175,0x1076ed720,220,DatePrototypeGetMinutes
code-creation,Builtin,2,24185,0x1076ed800,220,DatePrototypeGetMonth
code-creation,Builtin,2,24194,0x1076ed8e0,220,DatePrototypeGetSeconds
code-creation,Builtin,2,24204,0x1076ed9c0,124,DatePrototypeGetTime
code-creation,Builtin,2,24213,0x1076eda40,196,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,24223,0x1076edb20,196,DatePrototypeGetUTCDate
code-creation,Builtin,2,24233,0x1076edc00,196,DatePrototypeGetUTCDay
code-creation,Builtin,2,24242,0x1076edce0,196,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,24252,0x1076eddc0,196,DatePrototypeGetUTCHours
code-creation,Builtin,2,24261,0x1076edea0,196,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,24271,0x1076edf80,196,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,24281,0x1076ee060,196,DatePrototypeGetUTCMonth
code-creation,Builtin,2,24291,0x1076ee140,196,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,24300,0x1076ee220,124,DatePrototypeValueOf
code-creation,Builtin,2,24310,0x1076ee2a0,352,DatePrototypeToPrimitive
code-creation,Builtin,2,24319,0x1076ee420,12,DatePrototypeGetYear
code-creation,Builtin,2,24329,0x1076ee440,12,DatePrototypeSetYear
code-creation,Builtin,2,24338,0x1076ee460,12,DateNow
code-creation,Builtin,2,24346,0x1076ee480,12,DateParse
code-creation,Builtin,2,24354,0x1076ee4a0,12,DatePrototypeSetDate
code-creation,Builtin,2,24364,0x1076ee4c0,12,DatePrototypeSetFullYear
code-creation,Builtin,2,24373,0x1076ee4e0,12,DatePrototypeSetHours
code-creation,Builtin,2,24383,0x1076ee500,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,24393,0x1076ee520,12,DatePrototypeSetMinutes
code-creation,Builtin,2,24402,0x1076ee540,12,DatePrototypeSetMonth
code-creation,Builtin,2,24411,0x1076ee560,12,DatePrototypeSetSeconds
code-creation,Builtin,2,24421,0x1076ee580,12,DatePrototypeSetTime
code-creation,Builtin,2,24430,0x1076ee5a0,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,24439,0x1076ee5c0,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,24449,0x1076ee5e0,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,24459,0x1076ee600,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,24469,0x1076ee620,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,24478,0x1076ee640,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,24488,0x1076ee660,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,24498,0x1076ee680,12,DatePrototypeToDateString
code-creation,Builtin,2,24507,0x1076ee6a0,12,DatePrototypeToISOString
code-creation,Builtin,2,24517,0x1076ee6c0,12,DatePrototypeToUTCString
code-creation,Builtin,2,24527,0x1076ee6e0,12,DatePrototypeToString
code-creation,Builtin,2,24536,0x1076ee700,12,DatePrototypeToTimeString
code-creation,Builtin,2,24546,0x1076ee720,12,DatePrototypeToJson
code-creation,Builtin,2,24555,0x1076ee740,12,DateUTC
code-creation,Builtin,2,24563,0x1076ee760,12,ErrorConstructor
code-creation,Builtin,2,24572,0x1076ee780,12,ErrorCaptureStackTrace
code-creation,Builtin,2,24581,0x1076ee7a0,12,ErrorPrototypeToString
code-creation,Builtin,2,24590,0x1076ee7c0,12,FunctionConstructor
code-creation,Builtin,2,24599,0x1076ee7e0,68,FunctionPrototypeApply
code-creation,Builtin,2,24609,0x1076ee840,12,FunctionPrototypeBind
code-creation,Builtin,2,24618,0x1076ee860,32,FunctionPrototypeCall
code-creation,Builtin,2,24628,0x1076ee8a0,12,FunctionPrototypeToString
code-creation,Builtin,2,24637,0x1076ee8c0,192,CreateIterResultObject
code-creation,Builtin,2,24647,0x1076ee9a0,788,CreateGeneratorObject
code-creation,Builtin,2,24656,0x1076eecc0,12,GeneratorFunctionConstructor
code-creation,Builtin,2,24666,0x1076eece0,412,GeneratorPrototypeNext
code-creation,Builtin,2,24675,0x1076eee80,420,GeneratorPrototypeReturn
code-creation,Builtin,2,24685,0x1076ef040,424,GeneratorPrototypeThrow
code-creation,Builtin,2,24694,0x1076ef200,12,AsyncFunctionConstructor
code-creation,Builtin,2,24704,0x1076ef220,416,SuspendGeneratorBaseline
code-creation,Builtin,2,24724,0x1076ef3e0,88,ResumeGeneratorBaseline
code-creation,Builtin,2,24733,0x1076ef440,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,24745,0x1076ef480,12,GlobalDecodeURI
code-creation,Builtin,2,24754,0x1076ef4a0,12,GlobalDecodeURIComponent
code-creation,Builtin,2,24763,0x1076ef4c0,12,GlobalEncodeURI
code-creation,Builtin,2,24772,0x1076ef4e0,12,GlobalEncodeURIComponent
code-creation,Builtin,2,24781,0x1076ef500,12,GlobalEscape
code-creation,Builtin,2,24790,0x1076ef520,12,GlobalUnescape
code-creation,Builtin,2,24799,0x1076ef540,12,GlobalEval
code-creation,Builtin,2,24808,0x1076ef560,132,GlobalIsFinite
code-creation,Builtin,2,24819,0x1076ef600,124,GlobalIsNaN
code-creation,Builtin,2,24827,0x1076ef680,12,JsonParse
code-creation,Builtin,2,24836,0x1076ef6a0,12,JsonStringify
code-creation,Builtin,2,24845,0x1076ef6c0,3868,LoadIC
code-creation,Builtin,2,24853,0x1076f05e0,3552,LoadIC_Megamorphic
code-creation,Builtin,2,24862,0x1076f13e0,3776,LoadIC_Noninlined
code-creation,Builtin,2,24871,0x1076f22c0,44,LoadICTrampoline
code-creation,Builtin,2,24880,0x1076f2300,24,LoadICBaseline
code-creation,Builtin,2,24889,0x1076f2320,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,24899,0x1076f2360,6636,LoadSuperIC
code-creation,Builtin,2,24907,0x1076f3d60,24,LoadSuperICBaseline
code-creation,Builtin,2,24916,0x1076f3d80,7424,KeyedLoadIC
code-creation,Builtin,2,24925,0x1076f5aa0,12320,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,24934,0x1076f8ae0,44,KeyedLoadICTrampoline
code-creation,Builtin,2,24944,0x1076f8b20,24,KeyedLoadICBaseline
code-creation,Builtin,2,24953,0x1076f8b40,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,24963,0x1076f8b80,5320,StoreGlobalIC
code-creation,Builtin,2,24972,0x1076fa060,44,StoreGlobalICTrampoline
code-creation,Builtin,2,24981,0x1076fa0a0,24,StoreGlobalICBaseline
code-creation,Builtin,2,24991,0x1076fa0c0,5552,StoreIC
code-creation,Builtin,2,24999,0x1076fb680,44,StoreICTrampoline
code-creation,Builtin,2,25008,0x1076fb6c0,24,StoreICBaseline
code-creation,Builtin,2,25016,0x1076fb6e0,5984,KeyedStoreIC
code-creation,Builtin,2,25025,0x1076fce60,44,KeyedStoreICTrampoline
code-creation,Builtin,2,25034,0x1076fcea0,24,KeyedStoreICBaseline
code-creation,Builtin,2,25044,0x1076fcec0,408,StoreInArrayLiteralIC
code-creation,Builtin,2,25053,0x1076fd060,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,25063,0x1076fd080,140,LookupContextBaseline
code-creation,Builtin,2,25072,0x1076fd120,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,25082,0x1076fd1c0,2580,LoadGlobalIC
code-creation,Builtin,2,25091,0x1076fdbe0,2556,LoadGlobalICInsideTypeof
code-creation,Builtin,2,25101,0x1076fe5e0,44,LoadGlobalICTrampoline
code-creation,Builtin,2,25110,0x1076fe620,24,LoadGlobalICBaseline
code-creation,Builtin,2,25120,0x1076fe640,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,25130,0x1076fe680,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,25140,0x1076fe6a0,140,LookupGlobalICBaseline
code-creation,Builtin,2,25150,0x1076fe740,140,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,25160,0x1076fe7e0,2104,CloneObjectIC
code-creation,Builtin,2,25169,0x1076ff020,24,CloneObjectICBaseline
code-creation,Builtin,2,25178,0x1076ff040,1984,CloneObjectIC_Slow
code-creation,Builtin,2,25187,0x1076ff820,2752,KeyedHasIC
code-creation,Builtin,2,25195,0x107700300,24,KeyedHasICBaseline
code-creation,Builtin,2,25205,0x107700320,2128,KeyedHasIC_Megamorphic
code-creation,Builtin,2,25214,0x107700b80,1440,IterableToList
code-creation,Builtin,2,25223,0x107701140,1240,IterableToFixedArray
code-creation,Builtin,2,25232,0x107701620,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,25242,0x107701920,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,25253,0x107701960,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,25263,0x1077019e0,992,IterableToFixedArrayForWasm
code-creation,Builtin,2,25273,0x107701de0,1628,StringListFromIterable
code-creation,Builtin,2,25282,0x107702440,1220,FindOrderedHashMapEntry
code-creation,Builtin,2,25292,0x107702920,4164,MapConstructor
code-creation,Builtin,2,25311,0x107703980,2012,MapPrototypeSet
code-creation,Builtin,2,25320,0x107704160,1524,MapPrototypeDelete
code-creation,Builtin,2,25329,0x107704760,204,MapPrototypeGet
code-creation,Builtin,2,25338,0x107704840,164,MapPrototypeHas
code-creation,Builtin,2,25347,0x107704900,12,MapPrototypeClear
code-creation,Builtin,2,25356,0x107704920,280,MapPrototypeEntries
code-creation,Builtin,2,25366,0x107704a40,140,MapPrototypeGetSize
code-creation,Builtin,2,25375,0x107704ae0,492,MapPrototypeForEach
code-creation,Builtin,2,25384,0x107704ce0,280,MapPrototypeKeys
code-creation,Builtin,2,25393,0x107704e00,280,MapPrototypeValues
code-creation,Builtin,2,25402,0x107704f20,908,MapIteratorPrototypeNext
code-creation,Builtin,2,25411,0x1077052c0,1224,MapIteratorToList
code-creation,Builtin,2,25421,0x1077057a0,12,NumberPrototypeToExponential
code-creation,Builtin,2,25430,0x1077057c0,12,NumberPrototypeToFixed
code-creation,Builtin,2,25440,0x1077057e0,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,25450,0x107705800,12,NumberPrototypeToPrecision
code-creation,Builtin,2,25460,0x107705820,328,SameValue
code-creation,Builtin,2,25468,0x107705980,204,SameValueNumbersOnly
code-creation,Builtin,2,25477,0x107705a60,792,Add_Baseline
code-creation,Builtin,2,25486,0x107705d80,828,Subtract_Baseline
code-creation,Builtin,2,25495,0x1077060c0,808,Multiply_Baseline
code-creation,Builtin,2,25504,0x107706400,828,Divide_Baseline
code-creation,Builtin,2,25513,0x107706740,764,Modulus_Baseline
code-creation,Builtin,2,25522,0x107706a40,76,Exponentiate_Baseline
code-creation,Builtin,2,25531,0x107706aa0,708,BitwiseAnd_Baseline
code-creation,Builtin,2,25540,0x107706d80,700,BitwiseOr_Baseline
code-creation,Builtin,2,25549,0x107707040,708,BitwiseXor_Baseline
code-creation,Builtin,2,25559,0x107707320,720,ShiftLeft_Baseline
code-creation,Builtin,2,25568,0x107707600,720,ShiftRight_Baseline
code-creation,Builtin,2,25577,0x1077078e0,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,25586,0x107707c40,720,Add_WithFeedback
code-creation,Builtin,2,25596,0x107707f20,780,Subtract_WithFeedback
code-creation,Builtin,2,25605,0x107708240,772,Multiply_WithFeedback
code-creation,Builtin,2,25614,0x107708560,804,Divide_WithFeedback
code-creation,Builtin,2,25624,0x1077088a0,724,Modulus_WithFeedback
code-creation,Builtin,2,25633,0x107708b80,52,Exponentiate_WithFeedback
code-creation,Builtin,2,25642,0x107708bc0,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,25652,0x107708e80,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,25661,0x107709140,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,25671,0x107709400,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,25680,0x1077096c0,692,ShiftRight_WithFeedback
code-creation,Builtin,2,25689,0x107709980,804,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,25700,0x107709cc0,1696,Equal_Baseline
code-creation,Builtin,2,25709,0x10770a380,908,StrictEqual_Baseline
code-creation,Builtin,2,25718,0x10770a720,1264,LessThan_Baseline
code-creation,Builtin,2,25727,0x10770ac20,1264,GreaterThan_Baseline
code-creation,Builtin,2,25736,0x10770b120,1264,LessThanOrEqual_Baseline
code-creation,Builtin,2,25746,0x10770b620,1264,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,25756,0x10770bb20,1624,Equal_WithFeedback
code-creation,Builtin,2,25765,0x10770c180,940,StrictEqual_WithFeedback
code-creation,Builtin,2,25775,0x10770c540,1240,LessThan_WithFeedback
code-creation,Builtin,2,25784,0x10770ca20,1240,GreaterThan_WithFeedback
code-creation,Builtin,2,25793,0x10770cf00,1240,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,25803,0x10770d3e0,1240,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,25813,0x10770d8c0,332,BitwiseNot_Baseline
code-creation,Builtin,2,25822,0x10770da20,460,Decrement_Baseline
code-creation,Builtin,2,25832,0x10770dc00,464,Increment_Baseline
code-creation,Builtin,2,25841,0x10770dde0,488,Negate_Baseline
code-creation,Builtin,2,25849,0x10770dfe0,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,25859,0x10770e120,440,Decrement_WithFeedback
code-creation,Builtin,2,25868,0x10770e2e0,444,Increment_WithFeedback
code-creation,Builtin,2,25887,0x10770e4a0,472,Negate_WithFeedback
code-creation,Builtin,2,25897,0x10770e680,252,ObjectAssign
code-creation,Builtin,2,25906,0x10770e780,860,ObjectCreate
code-creation,Builtin,2,25914,0x10770eae0,12,ObjectDefineGetter
code-creation,Builtin,2,25923,0x10770eb00,12,ObjectDefineProperties
code-creation,Builtin,2,25933,0x10770eb20,12,ObjectDefineProperty
code-creation,Builtin,2,25942,0x10770eb40,12,ObjectDefineSetter
code-creation,Builtin,2,25951,0x10770eb60,1528,ObjectEntries
code-creation,Builtin,2,25960,0x10770f160,12,ObjectFreeze
code-creation,Builtin,2,25969,0x10770f180,5680,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,25979,0x1077107c0,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,25989,0x1077107e0,596,ObjectGetOwnPropertyNames
code-creation,Builtin,2,25999,0x107710a40,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,26009,0x107710a60,388,ObjectIs
code-creation,Builtin,2,26017,0x107710c00,12,ObjectIsFrozen
code-creation,Builtin,2,26026,0x107710c20,12,ObjectIsSealed
code-creation,Builtin,2,26035,0x107710c40,532,ObjectKeys
code-creation,Builtin,2,26043,0x107710e60,12,ObjectLookupGetter
code-creation,Builtin,2,26053,0x107710e80,12,ObjectLookupSetter
code-creation,Builtin,2,26062,0x107710ea0,1792,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,26072,0x1077115c0,216,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,26082,0x1077116a0,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,26092,0x1077116c0,12,ObjectPrototypeGetProto
code-creation,Builtin,2,26102,0x1077116e0,12,ObjectPrototypeSetProto
code-creation,Builtin,2,26111,0x107711700,12,ObjectSeal
code-creation,Builtin,2,26120,0x107711720,1104,ObjectToString
code-creation,Builtin,2,26128,0x107711b80,1292,ObjectValues
code-creation,Builtin,2,26137,0x1077120a0,280,OrdinaryHasInstance
code-creation,Builtin,2,26146,0x1077121c0,344,InstanceOf
code-creation,Builtin,2,26155,0x107712320,644,InstanceOf_WithFeedback
code-creation,Builtin,2,26165,0x1077125c0,664,InstanceOf_Baseline
code-creation,Builtin,2,26174,0x107712860,260,ForInEnumerate
code-creation,Builtin,2,26183,0x107712980,148,ForInPrepare
code-creation,Builtin,2,26191,0x107712a20,2084,ForInFilter
code-creation,Builtin,2,26200,0x107713260,52,ReflectApply
code-creation,Builtin,2,26208,0x1077132a0,60,ReflectConstruct
code-creation,Builtin,2,26217,0x1077132e0,12,ReflectDefineProperty
code-creation,Builtin,2,26227,0x107713300,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,26237,0x107713320,12,ReflectOwnKeys
code-creation,Builtin,2,26246,0x107713340,12,ReflectSet
code-creation,Builtin,2,26254,0x107713360,12,RegExpCapture1Getter
code-creation,Builtin,2,26263,0x107713380,12,RegExpCapture2Getter
code-creation,Builtin,2,26272,0x1077133a0,12,RegExpCapture3Getter
code-creation,Builtin,2,26282,0x1077133c0,12,RegExpCapture4Getter
code-creation,Builtin,2,26291,0x1077133e0,12,RegExpCapture5Getter
code-creation,Builtin,2,26301,0x107713400,12,RegExpCapture6Getter
code-creation,Builtin,2,26310,0x107713420,12,RegExpCapture7Getter
code-creation,Builtin,2,26319,0x107713440,12,RegExpCapture8Getter
code-creation,Builtin,2,26329,0x107713460,12,RegExpCapture9Getter
code-creation,Builtin,2,26338,0x107713480,2208,RegExpConstructor
code-creation,Builtin,2,26347,0x107713d40,12,RegExpInputGetter
code-creation,Builtin,2,26356,0x107713d60,12,RegExpInputSetter
code-creation,Builtin,2,26365,0x107713d80,12,RegExpLastMatchGetter
code-creation,Builtin,2,26375,0x107713da0,12,RegExpLastParenGetter
code-creation,Builtin,2,26384,0x107713dc0,12,RegExpLeftContextGetter
code-creation,Builtin,2,26393,0x107713de0,908,RegExpPrototypeCompile
code-creation,Builtin,2,26403,0x107714180,12,RegExpPrototypeToString
code-creation,Builtin,2,26412,0x1077141a0,12,RegExpRightContextGetter
code-creation,Builtin,2,26422,0x1077141c0,288,RegExpExecAtom
code-creation,Builtin,2,26431,0x107714300,1056,RegExpExecInternal
code-creation,Builtin,2,26440,0x107714740,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,26450,0x107714760,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,26470,0x107714780,12,ResizableArrayBufferPrototypeResize
code-creation,Builtin,2,26481,0x1077147a0,12,GrowableSharedArrayBufferPrototypeGrow
code-creation,Builtin,2,26491,0x1077147c0,12,GrowableSharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,26503,0x1077147e0,2696,SetConstructor
code-creation,Builtin,2,26512,0x107715280,1276,SetPrototypeHas
code-creation,Builtin,2,26521,0x107715780,1728,SetPrototypeAdd
code-creation,Builtin,2,26530,0x107715e60,1476,SetPrototypeDelete
code-creation,Builtin,2,26539,0x107716440,12,SetPrototypeClear
code-creation,Builtin,2,26548,0x107716460,284,SetPrototypeEntries
code-creation,Builtin,2,26557,0x107716580,144,SetPrototypeGetSize
code-creation,Builtin,2,26567,0x107716620,444,SetPrototypeForEach
code-creation,Builtin,2,26576,0x1077167e0,284,SetPrototypeValues
code-creation,Builtin,2,26585,0x107716900,844,SetIteratorPrototypeNext
code-creation,Builtin,2,26595,0x107716c60,1144,SetOrSetIteratorToList
code-creation,Builtin,2,26604,0x1077170e0,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,26614,0x107717100,1272,AtomicsLoad
code-creation,Builtin,2,26623,0x107717600,1008,AtomicsStore
code-creation,Builtin,2,26632,0x107717a00,1696,AtomicsExchange
code-creation,Builtin,2,26641,0x1077180c0,2088,AtomicsCompareExchange
code-creation,Builtin,2,26650,0x107718900,1800,AtomicsAdd
code-creation,Builtin,2,26658,0x107719020,1800,AtomicsSub
code-creation,Builtin,2,26667,0x107719740,1800,AtomicsAnd
code-creation,Builtin,2,26678,0x107719e60,1800,AtomicsOr
code-creation,Builtin,2,26686,0x10771a580,1800,AtomicsXor
code-creation,Builtin,2,26695,0x10771aca0,12,AtomicsNotify
code-creation,Builtin,2,26704,0x10771acc0,12,AtomicsIsLockFree
code-creation,Builtin,2,26713,0x10771ace0,12,AtomicsWait
code-creation,Builtin,2,26722,0x10771ad00,12,AtomicsWaitAsync
code-creation,Builtin,2,26731,0x10771ad20,12,StringFromCodePoint
code-creation,Builtin,2,26740,0x10771ad40,1444,StringFromCharCode
code-creation,Builtin,2,26749,0x10771b300,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,26759,0x10771b320,4360,StringPrototypeMatchAll
code-creation,Builtin,2,26768,0x10771c440,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,26778,0x10771c460,1228,StringPrototypeReplace
code-creation,Builtin,2,26788,0x10771c940,2912,StringPrototypeSplit
code-creation,Builtin,2,26797,0x10771d4c0,12,StringRaw
code-creation,Builtin,2,26805,0x10771d4e0,12,SymbolConstructor
code-creation,Builtin,2,26814,0x10771d500,12,SymbolFor
code-creation,Builtin,2,26823,0x10771d520,12,SymbolKeyFor
code-creation,Builtin,2,26831,0x10771d540,88,TypedArrayBaseConstructor
code-creation,Builtin,2,26841,0x10771d5a0,256,TypedArrayConstructor
code-creation,Builtin,2,26850,0x10771d6c0,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,26860,0x10771d6e0,876,TypedArrayPrototypeByteLength
code-creation,Builtin,2,26870,0x10771da60,292,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,26880,0x10771dba0,724,TypedArrayPrototypeLength
code-creation,Builtin,2,26890,0x10771de80,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,26901,0x10771dea0,12,TypedArrayPrototypeFill
code-creation,Builtin,2,26911,0x10771dec0,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,26921,0x10771dee0,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,26931,0x10771df00,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,26941,0x10771df20,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,26951,0x10771df40,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,26961,0x10771e080,10640,TypedArrayPrototypeMap
code-creation,Builtin,2,26970,0x107720a20,796,GenericJSToWasmWrapper
code-creation,Builtin,2,26980,0x107720d40,148,WasmCompileLazy
code-creation,Builtin,2,26989,0x107720de0,168,WasmDebugBreak
code-creation,Builtin,2,26998,0x107720ea0,16,WasmOnStackReplace
code-creation,Builtin,2,27007,0x107720ec0,136,WasmFloat32ToNumber
code-creation,Builtin,2,27017,0x107720f60,148,WasmFloat64ToNumber
code-creation,Builtin,2,27026,0x107721000,4,WasmI32AtomicWait32
code-creation,Builtin,2,27035,0x107721020,4,WasmI64AtomicWait32
code-creation,Builtin,2,27055,0x107721040,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,27066,0x107721060,4328,WeakMapConstructor
code-creation,Builtin,2,27075,0x107722160,196,WeakMapLookupHashIndex
code-creation,Builtin,2,27085,0x107722240,220,WeakMapGet
code-creation,Builtin,2,27094,0x107722320,176,WeakMapPrototypeHas
code-creation,Builtin,2,27104,0x1077223e0,204,WeakMapPrototypeSet
code-creation,Builtin,2,27113,0x1077224c0,144,WeakMapPrototypeDelete
code-creation,Builtin,2,27123,0x107722560,2888,WeakSetConstructor
code-creation,Builtin,2,27133,0x1077230c0,176,WeakSetPrototypeHas
code-creation,Builtin,2,27143,0x107723180,204,WeakSetPrototypeAdd
code-creation,Builtin,2,27152,0x107723260,144,WeakSetPrototypeDelete
code-creation,Builtin,2,27162,0x107723300,372,WeakCollectionDelete
code-creation,Builtin,2,27172,0x107723480,816,WeakCollectionSet
code-creation,Builtin,2,27182,0x1077237c0,312,AsyncGeneratorResolve
code-creation,Builtin,2,27191,0x107723900,120,AsyncGeneratorReject
code-creation,Builtin,2,27200,0x107723980,2232,AsyncGeneratorYield
code-creation,Builtin,2,27209,0x107724240,2304,AsyncGeneratorReturn
code-creation,Builtin,2,27219,0x107724b60,292,AsyncGeneratorResumeNext
code-creation,Builtin,2,27228,0x107724ca0,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,27239,0x107724cc0,1052,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,27249,0x1077250e0,1056,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,27260,0x107725520,1056,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,27270,0x107725960,2252,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,27279,0x107726240,2252,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,27289,0x107726b20,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,27300,0x107726ba0,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,27310,0x107726c40,116,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,27320,0x107726cc0,116,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,27331,0x107726d40,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,27342,0x107726dc0,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,27352,0x107726e60,1612,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,27363,0x1077274c0,1720,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,27373,0x107727b80,1736,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,27384,0x107728260,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,27394,0x1077282e0,228,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,27406,0x1077283e0,228,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,27418,0x1077284e0,212,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,27431,0x1077285c0,408,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,27442,0x107728760,408,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,27454,0x107728900,228,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,27466,0x107728a00,228,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,27478,0x107728b00,212,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,27490,0x107728be0,408,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,27502,0x107728d80,408,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,27513,0x107728f20,4,DirectCEntry
code-creation,Builtin,2,27522,0x107728f40,1096,StringAdd_CheckNone
code-creation,Builtin,2,27531,0x1077293a0,2496,SubString
code-creation,Builtin,2,27539,0x107729d80,16,StackCheck
code-creation,Builtin,2,27548,0x107729da0,84,DoubleToI
code-creation,Builtin,2,27556,0x107729e00,2224,GetProperty
code-creation,Builtin,2,27565,0x10772a6c0,2296,GetPropertyWithReceiver
code-creation,Builtin,2,27575,0x10772afc0,16528,SetProperty
code-creation,Builtin,2,27584,0x10772f060,14092,SetPropertyInLiteral
code-creation,Builtin,2,27593,0x107732780,8,MemCopyUint8Uint8
tick,0x106fe515f,44181,0,0x0,1
tick,0x7ff808922ae6,44217,0,0x0,6
code-creation,Builtin,2,44422,0x1077327a0,8,MemMove
tick,0x7ff808922ae6,46689,0,0x0,6
code-creation,Builtin,2,46769,0x1077327c0,12,IsTraceCategoryEnabled
code-creation,Builtin,2,46799,0x1077327e0,12,Trace
code-creation,Builtin,2,46810,0x107732800,12,FinalizationRegistryUnregister
tick,0x7ff808922ae6,48580,0,0x0,6
tick,0x7ff808921e26,48616,0,0x0,6
code-creation,Builtin,2,48632,0x107732820,416,AsyncModuleEvaluate
code-creation,Builtin,2,48647,0x1077329e0,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,48658,0x107732a00,12,CallAsyncModuleRejected
code-creation,Builtin,2,48670,0x107732a20,260,AggregateErrorConstructor
code-creation,Builtin,2,48681,0x107732b40,856,ArrayPrototypeAt
code-creation,Builtin,2,48692,0x107732ea0,5808,ArrayPrototypeCopyWithin
code-creation,Builtin,2,48703,0x107734560,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,48715,0x107734640,612,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,48727,0x1077348c0,2736,ArrayEveryLoopContinuation
code-creation,Builtin,2,48738,0x107735380,1464,ArrayEvery
code-creation,Builtin,2,48748,0x107735940,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,48761,0x107735a60,984,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,48773,0x107735e40,3012,ArrayFilterLoopContinuation
code-creation,Builtin,2,48784,0x107736a20,4324,ArrayFilter
code-creation,Builtin,2,48850,0x107737b20,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,48933,0x107737c00,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,48955,0x107737c40,312,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,48968,0x107737d80,524,ArrayFindLoopContinuation
code-creation,Builtin,2,48980,0x107737fa0,1456,ArrayPrototypeFind
code-creation,Builtin,2,48991,0x107738560,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,49003,0x107738640,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,49016,0x107738680,312,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,49029,0x1077387c0,524,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,49041,0x1077389e0,1460,ArrayPrototypeFindIndex
code-creation,Builtin,2,49052,0x107738fa0,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,49065,0x107739080,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,49078,0x107739160,2628,ArrayForEachLoopContinuation
code-creation,Builtin,2,49089,0x107739bc0,1328,ArrayForEach
code-creation,Builtin,2,49099,0x10773a100,3560,ArrayFrom
code-creation,Builtin,2,49109,0x10773af00,148,ArrayIsArray
code-creation,Builtin,2,49119,0x10773afa0,408,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,49131,0x10773b140,36,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,49143,0x10773b180,140,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,49155,0x10773b220,312,ConvertToLocaleString
code-creation,Builtin,2,49166,0x10773b360,792,JoinStackPush
code-creation,Builtin,2,49176,0x10773b680,284,JoinStackPop
code-creation,Builtin,2,49186,0x10773b7a0,6700,ArrayPrototypeJoin
code-creation,Builtin,2,49196,0x10773d1e0,5412,ArrayPrototypeToLocaleString
code-creation,Builtin,2,49208,0x10773e720,236,ArrayPrototypeToString
code-creation,Builtin,2,49218,0x10773e820,6008,TypedArrayPrototypeJoin
code-creation,Builtin,2,49229,0x10773ffa0,4692,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,49241,0x107741200,3820,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,49252,0x107742100,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,49264,0x107742220,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,49276,0x107742320,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,49288,0x107742540,2640,ArrayMapLoopContinuation
code-creation,Builtin,2,49299,0x107742fa0,3944,ArrayMap
code-creation,Builtin,2,49308,0x107743f20,996,ArrayOf
code-creation,Builtin,2,49317,0x107744320,440,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,49330,0x1077444e0,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,49360,0x1077445c0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,49374,0x1077446a0,2676,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,49386,0x107745120,1996,ArrayReduceRight
code-creation,Builtin,2,49396,0x107745900,176,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,49408,0x1077459c0,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,49420,0x107745aa0,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,49440,0x107745b80,2704,ArrayReduceLoopContinuation
code-creation,Builtin,2,49458,0x107746620,1604,ArrayReduce
code-creation,Builtin,2,49482,0x107746c80,3264,ArrayPrototypeReverse
code-creation,Builtin,2,49492,0x107747960,3640,ArrayPrototypeShift
code-creation,Builtin,2,49502,0x1077487a0,5192,ArrayPrototypeSlice
code-creation,Builtin,2,49513,0x107749c00,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,49524,0x107749ce0,576,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,49535,0x107749f40,2720,ArraySomeLoopContinuation
code-creation,Builtin,2,49551,0x10774aa00,1444,ArraySome
code-creation,Builtin,2,49561,0x10774afc0,14320,ArrayPrototypeSplice
code-creation,Builtin,2,49572,0x10774e7c0,3284,ArrayPrototypeUnshift
code-creation,Builtin,2,49582,0x10774f4a0,388,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,49594,0x10774f640,388,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,49605,0x10774f7e0,388,ResizableArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,49617,0x10774f980,388,ResizableArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,49630,0x10774fb20,388,GrowableSharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,49643,0x10774fcc0,96,ArrayBufferIsView
code-creation,Builtin,2,49653,0x10774fd40,396,ToInteger
code-creation,Builtin,2,49662,0x10774fee0,3192,FastCreateDataProperty
code-creation,Builtin,2,49673,0x107750b60,676,CheckNumberInRange
code-creation,Builtin,2,49683,0x107750e20,584,CheckSameObject
code-creation,Builtin,2,49693,0x107751080,904,BooleanConstructor
code-creation,Builtin,2,49703,0x107751420,164,BooleanPrototypeToString
code-creation,Builtin,2,49714,0x1077514e0,156,BooleanPrototypeValueOf
code-creation,Builtin,2,49725,0x107751580,1180,BigIntAddNoThrow
code-creation,Builtin,2,49735,0x107751a20,1276,BigIntAdd
code-creation,Builtin,2,49744,0x107751f20,1180,BigIntSubtractNoThrow
code-creation,Builtin,2,49754,0x1077523c0,1276,BigIntSubtract
code-creation,Builtin,2,49764,0x1077528c0,284,BigIntUnaryMinus
code-creation,Builtin,2,49774,0x1077529e0,1388,ToString
code-creation,Builtin,2,49783,0x107752f60,156,StringPrototypeToString
code-creation,Builtin,2,49793,0x107753000,156,StringPrototypeValueOf
code-creation,Builtin,2,49804,0x1077530a0,2496,StringToList
code-creation,Builtin,2,49813,0x107753a80,1028,StringPrototypeCharAt
code-creation,Builtin,2,49824,0x107753ea0,700,StringPrototypeCharCodeAt
code-creation,Builtin,2,49835,0x107754160,1284,StringPrototypeCodePointAt
tick,0x7ff808922ae6,49879,0,0x0,6
code-creation,Builtin,2,49892,0x107754680,404,StringPrototypeConcat
code-creation,Builtin,2,49907,0x107754820,992,StringConstructor
code-creation,Builtin,2,49917,0x107754c20,1464,StringAddConvertLeft
code-creation,Builtin,2,49927,0x1077551e0,1492,StringAddConvertRight
code-creation,Builtin,2,49938,0x1077557c0,828,StringCharAt
code-creation,Builtin,2,49947,0x107755b00,16,FastNewClosureBaseline
code-creation,Builtin,2,49957,0x107755b20,196,FastNewFunctionContextEval
code-creation,Builtin,2,49969,0x107755c00,196,FastNewFunctionContextFunction
code-creation,Builtin,2,49980,0x107755ce0,244,CreateRegExpLiteral
code-creation,Builtin,2,49990,0x107755de0,1096,CreateShallowArrayLiteral
code-creation,Builtin,2,50001,0x107756240,532,CreateEmptyArrayLiteral
code-creation,Builtin,2,50011,0x107756460,1752,CreateShallowObjectLiteral
code-creation,Builtin,2,50022,0x107756b40,380,ObjectConstructor
code-creation,Builtin,2,50032,0x107756cc0,172,CreateEmptyLiteralObject
code-creation,Builtin,2,50042,0x107756d80,552,NumberConstructor
code-creation,Builtin,2,50069,0x107756fc0,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,50081,0x107757020,64,StringToNumber
code-creation,Builtin,2,50090,0x107757080,184,NonNumberToNumber
code-creation,Builtin,2,50100,0x107757140,240,NonNumberToNumeric
code-creation,Builtin,2,50110,0x107757240,36,ToNumeric
code-creation,Builtin,2,50120,0x107757280,1212,NumberToString
code-creation,Builtin,2,50131,0x107757740,92,ToBoolean
code-creation,Builtin,2,50140,0x1077577a0,96,ToBooleanForBaselineJump
code-creation,Builtin,2,50150,0x107757820,724,ToLength
code-creation,Builtin,2,50160,0x107757b00,1340,ToName
code-creation,Builtin,2,50169,0x107758040,756,ToObject
code-creation,Builtin,2,50192,0x107758340,208,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,50205,0x107758420,208,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,50216,0x107758500,208,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,50227,0x1077585e0,288,OrdinaryToPrimitive_Number
code-creation,Builtin,2,50238,0x107758720,288,OrdinaryToPrimitive_String
code-creation,Builtin,2,50250,0x107758860,216,FastConsoleAssert
code-creation,Builtin,2,50260,0x107758940,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,50271,0x107758a00,336,DataViewPrototypeGetByteLength
code-creation,Builtin,2,50282,0x107758b60,336,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,50294,0x107758cc0,572,DataViewPrototypeGetUint8
code-creation,Builtin,2,50304,0x107758f00,572,DataViewPrototypeGetInt8
code-creation,Builtin,2,50315,0x107759140,644,DataViewPrototypeGetUint16
code-creation,Builtin,2,50326,0x1077593e0,644,DataViewPrototypeGetInt16
code-creation,Builtin,2,50337,0x107759680,808,DataViewPrototypeGetUint32
code-creation,Builtin,2,50348,0x1077599c0,684,DataViewPrototypeGetInt32
code-creation,Builtin,2,50359,0x107759c80,844,DataViewPrototypeGetFloat32
code-creation,Builtin,2,50369,0x107759fe0,908,DataViewPrototypeGetFloat64
code-creation,Builtin,2,50381,0x10775a380,980,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,50392,0x10775a760,1000,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,50403,0x10775ab60,928,DataViewPrototypeSetUint8
code-creation,Builtin,2,50413,0x10775af20,928,DataViewPrototypeSetInt8
code-creation,Builtin,2,50424,0x10775b2e0,1028,DataViewPrototypeSetUint16
code-creation,Builtin,2,50435,0x10775b700,1028,DataViewPrototypeSetInt16
code-creation,Builtin,2,50446,0x10775bb20,1064,DataViewPrototypeSetUint32
code-creation,Builtin,2,50456,0x10775bf60,1064,DataViewPrototypeSetInt32
code-creation,Builtin,2,50467,0x10775c3a0,1032,DataViewPrototypeSetFloat32
code-creation,Builtin,2,50478,0x10775c7c0,1096,DataViewPrototypeSetFloat64
code-creation,Builtin,2,50488,0x10775cc20,944,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,50499,0x10775cfe0,944,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,50510,0x10775d3a0,828,FinalizationRegistryConstructor
code-creation,Builtin,2,50521,0x10775d6e0,1244,FinalizationRegistryRegister
code-creation,Builtin,2,50532,0x10775dbc0,660,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,50544,0x10775de60,328,FunctionPrototypeHasInstance
code-creation,Builtin,2,50555,0x10775dfc0,920,FastFunctionPrototypeBind
code-creation,Builtin,2,50566,0x10775e360,88,IncBlockCounter
code-creation,Builtin,2,50576,0x10775e3c0,252,GetTemplateObject
code-creation,Builtin,2,50586,0x10775e4c0,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,50597,0x10775e4e0,92,ForInNext
code-creation,Builtin,2,50606,0x10775e540,128,GetImportMetaObjectBaseline
code-creation,Builtin,2,50617,0x10775e5e0,116,GetIteratorWithFeedback
code-creation,Builtin,2,50628,0x10775e660,100,GetIteratorBaseline
code-creation,Builtin,2,50638,0x10775e6e0,268,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,50650,0x10775e800,1128,CallIteratorWithFeedback
code-creation,Builtin,2,50660,0x10775ec80,288,MathAbs
code-creation,Builtin,2,50669,0x10775edc0,424,MathCeil
code-creation,Builtin,2,50679,0x10775ef80,432,MathFloor
code-creation,Builtin,2,50688,0x10775f140,488,MathRound
code-creation,Builtin,2,50697,0x10775f340,428,MathTrunc
code-creation,Builtin,2,50718,0x10775f500,364,MathPow
code-creation,Builtin,2,50728,0x10775f680,396,MathMax
code-creation,Builtin,2,50738,0x10775f820,400,MathMin
code-creation,Builtin,2,50748,0x10775f9c0,316,MathAcos
code-creation,Builtin,2,50758,0x10775fb00,316,MathAcosh
code-creation,Builtin,2,50767,0x10775fc40,316,MathAsin
code-creation,Builtin,2,50777,0x10775fd80,316,MathAsinh
code-creation,Builtin,2,50787,0x10775fec0,316,MathAtan
code-creation,Builtin,2,50797,0x107760000,412,MathAtan2
code-creation,Builtin,2,50806,0x1077601a0,316,MathAtanh
code-creation,Builtin,2,50816,0x1077602e0,316,MathCbrt
code-creation,Builtin,2,50825,0x107760420,168,MathClz32
code-creation,Builtin,2,50835,0x1077604e0,316,MathCos
code-creation,Builtin,2,50845,0x107760620,316,MathCosh
code-creation,Builtin,2,50854,0x107760760,316,MathExp
code-creation,Builtin,2,50864,0x1077608a0,316,MathExpm1
code-creation,Builtin,2,50874,0x1077609e0,272,MathFround
code-creation,Builtin,2,50883,0x107760b00,304,MathImul
code-creation,Builtin,2,50892,0x107760c40,316,MathLog
code-creation,Builtin,2,50901,0x107760d80,316,MathLog1p
code-creation,Builtin,2,50910,0x107760ec0,316,MathLog10
code-creation,Builtin,2,50920,0x107761000,316,MathLog2
code-creation,Builtin,2,50929,0x107761140,316,MathSin
code-creation,Builtin,2,50938,0x107761280,180,MathSign
code-creation,Builtin,2,50948,0x107761340,316,MathSinh
code-creation,Builtin,2,50957,0x107761480,268,MathSqrt
code-creation,Builtin,2,50966,0x1077615a0,316,MathTan
code-creation,Builtin,2,50975,0x1077616e0,316,MathTanh
code-creation,Builtin,2,50984,0x107761820,1048,MathHypot
code-creation,Builtin,2,50994,0x107761c40,316,MathRandom
code-creation,Builtin,2,51003,0x107761d80,2984,NumberPrototypeToString
code-creation,Builtin,2,51014,0x107762940,136,NumberIsFinite
code-creation,Builtin,2,51024,0x1077629e0,344,NumberIsInteger
code-creation,Builtin,2,51034,0x107762b40,116,NumberIsNaN
code-creation,Builtin,2,51044,0x107762bc0,372,NumberIsSafeInteger
code-creation,Builtin,2,51054,0x107762d40,160,NumberPrototypeValueOf
code-creation,Builtin,2,51065,0x107762e00,196,NumberParseFloat
code-creation,Builtin,2,51075,0x107762ee0,248,ParseInt
code-creation,Builtin,2,51085,0x107762fe0,84,NumberParseInt
code-creation,Builtin,2,51095,0x107763040,856,Add
code-creation,Builtin,2,51106,0x1077633a0,424,Subtract
code-creation,Builtin,2,51115,0x107763560,608,Multiply
tick,0x7ff808957d23,51146,0,0x0,6
code-creation,Builtin,2,51157,0x1077637e0,532,Divide
code-creation,Builtin,2,51168,0x107763a00,588,Modulus
code-creation,Builtin,2,51177,0x107763c60,524,Exponentiate
code-creation,Builtin,2,51187,0x107763e80,340,Negate
code-creation,Builtin,2,51196,0x107763fe0,112,BitwiseNot
code-creation,Builtin,2,51205,0x107764060,112,Decrement
code-creation,Builtin,2,51215,0x1077640e0,112,Increment
code-creation,Builtin,2,51224,0x107764160,392,ShiftLeft
code-creation,Builtin,2,51233,0x107764300,392,ShiftRight
code-creation,Builtin,2,51243,0x1077644a0,508,ShiftRightLogical
code-creation,Builtin,2,51253,0x1077646a0,388,BitwiseAnd
code-creation,Builtin,2,51262,0x107764840,388,BitwiseOr
code-creation,Builtin,2,51272,0x1077649e0,388,BitwiseXor
code-creation,Builtin,2,51281,0x107764b80,796,LessThan
code-creation,Builtin,2,51290,0x107764ea0,796,LessThanOrEqual
code-creation,Builtin,2,51300,0x1077651c0,796,GreaterThan
code-creation,Builtin,2,51310,0x1077654e0,796,GreaterThanOrEqual
code-creation,Builtin,2,51320,0x107765800,860,Equal
code-creation,Builtin,2,51329,0x107765b60,348,StrictEqual
code-creation,Builtin,2,51338,0x107765cc0,3036,ObjectFromEntries
code-creation,Builtin,2,51348,0x1077668a0,752,CreateObjectWithoutProperties
code-creation,Builtin,2,51359,0x107766ba0,144,ObjectIsExtensible
code-creation,Builtin,2,51369,0x107766c40,148,ObjectPreventExtensions
code-creation,Builtin,2,51380,0x107766ce0,144,ObjectGetPrototypeOf
code-creation,Builtin,2,51390,0x107766d80,300,ObjectSetPrototypeOf
code-creation,Builtin,2,51461,0x107766ec0,80,ObjectPrototypeToString
code-creation,Builtin,2,51478,0x107766f20,96,ObjectPrototypeValueOf
code-creation,Builtin,2,51490,0x107766fa0,164,ObjectPrototypeToLocaleString
code-creation,Builtin,2,51522,0x107767060,924,FulfillPromise
code-creation,Builtin,2,51533,0x107767400,1064,RejectPromise
code-creation,Builtin,2,51543,0x107767840,2488,NewPromiseCapability
code-creation,Builtin,2,51554,0x107768200,164,PromiseCapabilityDefaultReject
code-creation,Builtin,2,51566,0x1077682c0,148,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,51579,0x107768360,1428,PerformPromiseThen
code-creation,Builtin,2,51589,0x107768900,648,PromiseReject
code-creation,Builtin,2,51599,0x107768ba0,332,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,51610,0x107768d00,104,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,51622,0x107768d80,4604,PromiseAll
code-creation,Builtin,2,51632,0x107769f80,4944,PromiseAllSettled
code-creation,Builtin,2,51642,0x10776b2e0,1152,PromiseAllResolveElementClosure
code-creation,Builtin,2,51653,0x10776b780,1436,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,51665,0x10776bd20,1440,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,51677,0x10776c2e0,1224,PromiseAnyRejectElementClosure
code-creation,Builtin,2,51688,0x10776c7c0,2388,PromiseAny
code-creation,Builtin,2,51697,0x10776d120,2940,PromiseConstructor
code-creation,Builtin,2,51708,0x10776dca0,296,PromisePrototypeCatch
tick,0x7ff808922ae6,53452,0,0x0,6
tick,0x7ff808921e26,53737,0,0x0,6
code-creation,Builtin,2,54274,0x10776dde0,88,PromiseValueThunkFinally
code-creation,Builtin,2,54307,0x10776de40,84,PromiseThrowerFinally
code-creation,Builtin,2,54337,0x10776dea0,924,PromiseCatchFinally
code-creation,Builtin,2,54667,0x10776e240,924,PromiseThenFinally
code-creation,Builtin,2,54680,0x10776e5e0,1748,PromisePrototypeFinally
code-creation,Builtin,2,54692,0x10776ecc0,1336,PromiseRace
code-creation,Builtin,2,54703,0x10776f200,268,PromiseFulfillReactionJob
code-creation,Builtin,2,54714,0x10776f320,364,PromiseRejectReactionJob
code-creation,Builtin,2,54725,0x10776f4a0,156,PromiseResolveTrampoline
code-creation,Builtin,2,54737,0x10776f540,652,PromiseResolve
code-creation,Builtin,2,54754,0x10776f7e0,708,ResolvePromise
code-creation,Builtin,2,54764,0x10776fac0,2236,PromisePrototypeThen
code-creation,Builtin,2,54775,0x107770380,1184,PromiseResolveThenableJob
code-creation,Builtin,2,54786,0x107770840,444,ProxyConstructor
tick,0x7ff8089760e6,54961,0,0x0,6
code-creation,Builtin,2,54972,0x107770a00,1760,ProxyDeleteProperty
code-creation,Builtin,2,54985,0x107771100,2108,ProxyGetProperty
code-creation,Builtin,2,54996,0x107771940,1060,ProxyGetPrototypeOf
code-creation,Builtin,2,55006,0x107771d80,1668,ProxyHasProperty
code-creation,Builtin,2,55016,0x107772420,760,ProxyIsExtensible
code-creation,Builtin,2,55026,0x107772720,800,ProxyPreventExtensions
code-creation,Builtin,2,55037,0x107772a60,1168,ProxyRevocable
code-creation,Builtin,2,55047,0x107772f00,120,ProxyRevoke
code-creation,Builtin,2,55056,0x107772f80,2204,ProxySetProperty
code-creation,Builtin,2,55066,0x107773820,1292,ProxySetPrototypeOf
code-creation,Builtin,2,55077,0x107773d40,208,ReflectIsExtensible
code-creation,Builtin,2,55088,0x107773e20,212,ReflectPreventExtensions
code-creation,Builtin,2,55099,0x107773f00,188,ReflectGetPrototypeOf
code-creation,Builtin,2,55110,0x107773fc0,292,ReflectSetPrototypeOf
code-creation,Builtin,2,55121,0x107774100,284,ReflectGet
code-creation,Builtin,2,55131,0x107774220,160,ReflectDeleteProperty
code-creation,Builtin,2,55142,0x1077742e0,148,ReflectHas
code-creation,Builtin,2,55152,0x107774380,5280,RegExpPrototypeExecSlow
code-creation,Builtin,2,55163,0x107775840,5268,RegExpPrototypeExec
code-creation,Builtin,2,55174,0x107776ce0,2360,RegExpPrototypeMatchAll
code-creation,Builtin,2,55184,0x107777620,9544,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,55195,0x107779b80,9008,RegExpMatchFast
code-creation,Builtin,2,55205,0x10777bec0,3596,RegExpPrototypeMatch
code-creation,Builtin,2,55216,0x10777cce0,6368,RegExpReplace
code-creation,Builtin,2,55225,0x10777e5e0,524,RegExpPrototypeReplace
code-creation,Builtin,2,55236,0x10777e800,1428,RegExpSearchFast
code-creation,Builtin,2,55246,0x10777eda0,1636,RegExpPrototypeSearch
code-creation,Builtin,2,55813,0x10777f420,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,56931,0x10777f500,5880,RegExpSplit
tick,0x7ff80896f6f6,57278,0,0x0,6
tick,0x7ff808922ae6,57291,0,0x0,6
code-creation,Builtin,2,57304,0x107780c00,476,RegExpPrototypeSplit
code-creation,Builtin,2,57318,0x107780de0,2260,RegExpPrototypeTest
code-creation,Builtin,2,57329,0x1077816c0,1372,RegExpPrototypeTestFast
code-creation,Builtin,2,57340,0x107781c20,228,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,57351,0x107781d20,244,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,57362,0x107781e20,244,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,57373,0x107781f20,244,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,57385,0x107782020,244,RegExpPrototypeLinearGetter
code-creation,Builtin,2,57396,0x107782120,244,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,57407,0x107782220,272,RegExpPrototypeStickyGetter
code-creation,Builtin,2,57418,0x107782340,272,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,57429,0x107782460,2268,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,57440,0x107782d40,1516,StringPrototypeAt
code-creation,Builtin,2,57451,0x107783340,2992,StringPrototypeEndsWith
code-creation,Builtin,2,57462,0x107783f00,480,CreateHTML
code-creation,Builtin,2,57471,0x107784100,164,StringPrototypeAnchor
code-creation,Builtin,2,57482,0x1077841c0,128,StringPrototypeBig
code-creation,Builtin,2,57492,0x107784260,128,StringPrototypeBlink
code-creation,Builtin,2,57502,0x107784300,128,StringPrototypeBold
code-creation,Builtin,2,57513,0x1077843a0,168,StringPrototypeFontcolor
code-creation,Builtin,2,57524,0x107784460,168,StringPrototypeFontsize
code-creation,Builtin,2,57534,0x107784520,128,StringPrototypeFixed
code-creation,Builtin,2,57545,0x1077845c0,128,StringPrototypeItalics
code-creation,Builtin,2,57556,0x107784660,168,StringPrototypeLink
code-creation,Builtin,2,57566,0x107784720,128,StringPrototypeSmall
code-creation,Builtin,2,57576,0x1077847c0,128,StringPrototypeStrike
code-creation,Builtin,2,57587,0x107784860,128,StringPrototypeSub
code-creation,Builtin,2,57597,0x107784900,128,StringPrototypeSup
code-creation,Builtin,2,57608,0x1077849a0,1028,StringPrototypeIncludes
code-creation,Builtin,2,57619,0x107784dc0,628,StringPrototypeIndexOf
code-creation,Builtin,2,57630,0x107785040,344,StringPrototypeIterator
code-creation,Builtin,2,57641,0x1077851a0,2044,StringIteratorPrototypeNext
code-creation,Builtin,2,57653,0x1077859a0,1304,StringPrototypeMatch
code-creation,Builtin,2,57664,0x107785ec0,1304,StringPrototypeSearch
code-creation,Builtin,2,57674,0x1077863e0,824,StringPrototypePadStart
code-creation,Builtin,2,57685,0x107786720,828,StringPrototypePadEnd
code-creation,Builtin,2,57695,0x107786a60,120,StringRepeat
code-creation,Builtin,2,57705,0x107786ae0,396,StringPrototypeRepeat
code-creation,Builtin,2,57715,0x107786c80,10976,StringPrototypeReplaceAll
code-creation,Builtin,2,57726,0x107789780,3400,StringPrototypeSlice
code-creation,Builtin,2,57737,0x10778a4e0,3004,StringPrototypeStartsWith
code-creation,Builtin,2,57748,0x10778b0a0,3340,StringPrototypeSubstr
code-creation,Builtin,2,57759,0x10778bdc0,3276,StringPrototypeSubstring
code-creation,Builtin,2,57769,0x10778caa0,6928,StringPrototypeTrim
code-creation,Builtin,2,57799,0x10778e5c0,6336,StringPrototypeTrimStart
code-creation,Builtin,2,57813,0x10778fea0,5860,StringPrototypeTrimEnd
code-creation,Builtin,2,57824,0x1077915a0,160,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,57835,0x107791660,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,57847,0x107791700,172,SymbolPrototypeToString
code-creation,Builtin,2,57857,0x1077917c0,156,SymbolPrototypeValueOf
code-creation,Builtin,2,57868,0x107791860,828,TypedArrayPrototypeAt
code-creation,Builtin,2,57879,0x107791ba0,9796,CreateTypedArray
code-creation,Builtin,2,57890,0x107794200,996,TypedArrayPrototypeEvery
code-creation,Builtin,2,57901,0x107794600,372,TypedArrayPrototypeEntries
code-creation,Builtin,2,57913,0x107794780,3504,TypedArrayPrototypeFilter
code-creation,Builtin,2,57943,0x107795540,996,TypedArrayPrototypeFind
code-creation,Builtin,2,57955,0x107795940,1000,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,57966,0x107795d40,864,TypedArrayPrototypeForEach
code-creation,Builtin,2,57978,0x1077960c0,2348,TypedArrayFrom
code-creation,Builtin,2,57988,0x107796a00,356,TypedArrayPrototypeKeys
code-creation,Builtin,2,57999,0x107796b80,1028,TypedArrayOf
code-creation,Builtin,2,58009,0x107796fa0,952,TypedArrayPrototypeReduce
code-creation,Builtin,2,58020,0x107797360,944,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,58032,0x107797720,2408,TypedArrayPrototypeSet
code-creation,Builtin,2,58043,0x1077980a0,2952,TypedArrayPrototypeSlice
code-creation,Builtin,2,58054,0x107798c40,992,TypedArrayPrototypeSome
code-creation,Builtin,2,58064,0x107799040,1116,TypedArrayMergeSort
code-creation,Builtin,2,58075,0x1077994a0,1652,TypedArrayPrototypeSort
code-creation,Builtin,2,58087,0x107799b20,2724,TypedArrayPrototypeSubArray
code-creation,Builtin,2,58099,0x10779a5e0,372,TypedArrayPrototypeValues
code-creation,Builtin,2,58111,0x10779a760,972,WeakRefConstructor
code-creation,Builtin,2,58121,0x10779ab40,184,WeakRefDeref
code-creation,Builtin,2,58132,0x10779ac00,680,NewSloppyArgumentsElements
code-creation,Builtin,2,58143,0x10779aec0,296,NewStrictArgumentsElements
code-creation,Builtin,2,58155,0x10779b000,320,NewRestArgumentsElements
code-creation,Builtin,2,58166,0x10779b160,1388,FastNewSloppyArguments
code-creation,Builtin,2,58177,0x10779b6e0,524,FastNewStrictArguments
code-creation,Builtin,2,58187,0x10779b900,552,FastNewRestArguments
code-creation,Builtin,2,58198,0x10779bb40,696,StringSlowFlatten
code-creation,Builtin,2,58209,0x10779be00,2000,StringIndexOf
tick,0x7ff808922ae6,58261,0,0x0,6
code-creation,Builtin,2,58275,0x10779c5e0,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,58289,0x10779c600,20,TestHelperPlus1
code-creation,Builtin,2,58299,0x10779c620,20,TestHelperPlus2
code-creation,Builtin,2,58309,0x10779c640,96,NewSmiBox
code-creation,Builtin,2,58320,0x10779c6c0,24,ReturnTwoValues
code-creation,Builtin,2,58330,0x10779c6e0,32,Load_FastSmiElements_0
code-creation,Builtin,2,58342,0x10779c720,32,Load_FastObjectElements_0
code-creation,Builtin,2,58353,0x10779c760,144,Load_FastDoubleElements_0
code-creation,Builtin,2,58364,0x10779c800,32,Store_FastSmiElements_0
code-creation,Builtin,2,58375,0x10779c840,112,Store_FastObjectElements_0
code-creation,Builtin,2,58388,0x10779c8c0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,58399,0x10779c900,36,Delete_FastSmiElements_0
code-creation,Builtin,2,58410,0x10779c940,36,Delete_FastObjectElements_0
code-creation,Builtin,2,58421,0x10779c980,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,58432,0x10779c9c0,308,SortCompareDefault
code-creation,Builtin,2,58443,0x10779cb00,92,SortCompareUserFn
code-creation,Builtin,2,58454,0x10779cb60,8,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,58467,0x10779cb80,340,Copy
code-creation,Builtin,2,58476,0x10779cce0,5988,MergeAt
code-creation,Builtin,2,58486,0x10779e460,792,GallopLeft
code-creation,Builtin,2,58496,0x10779e780,832,GallopRight
code-creation,Builtin,2,58506,0x10779eae0,3952,ArrayTimSort
code-creation,Builtin,2,58517,0x10779fa60,2116,ArrayPrototypeSort
code-creation,Builtin,2,58527,0x1077a02c0,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,58538,0x1077a0340,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,58549,0x1077a03c0,76,WasmTaggedToFloat64
code-creation,Builtin,2,58560,0x1077a0420,72,WasmMemoryGrow
code-creation,Builtin,2,58570,0x1077a0480,100,WasmTableInit
code-creation,Builtin,2,58581,0x1077a0500,100,WasmTableCopy
code-creation,Builtin,2,58591,0x1077a0580,84,WasmTableFill
code-creation,Builtin,2,58601,0x1077a05e0,72,WasmTableGrow
code-creation,Builtin,2,58611,0x1077a0640,144,WasmTableGet
code-creation,Builtin,2,58621,0x1077a06e0,252,WasmTableSet
code-creation,Builtin,2,58631,0x1077a07e0,88,WasmRefFunc
code-creation,Builtin,2,58641,0x1077a0840,144,WasmAllocateFixedArray
code-creation,Builtin,2,58652,0x1077a08e0,44,WasmThrow
code-creation,Builtin,2,58661,0x1077a0920,52,WasmRethrow
code-creation,Builtin,2,58688,0x1077a0960,44,WasmTriggerTierUp
code-creation,Builtin,2,58699,0x1077a09a0,32,WasmStackGuard
code-creation,Builtin,2,58709,0x1077a09e0,32,WasmStackOverflow
code-creation,Builtin,2,58719,0x1077a0a20,40,WasmTraceMemory
code-creation,Builtin,2,58729,0x1077a0a60,32,WasmTraceEnter
code-creation,Builtin,2,58739,0x1077a0aa0,40,WasmTraceExit
code-creation,Builtin,2,58748,0x1077a0ae0,332,WasmAllocateJSArray
code-creation,Builtin,2,58800,0x1077a0c40,104,WasmAllocatePair
code-creation,Builtin,2,58912,0x1077a0cc0,48,WasmAllocateRtt
code-creation,Builtin,2,58938,0x1077a0d00,112,WasmAllocateStructWithRtt
code-creation,Builtin,2,58951,0x1077a0d80,128,WasmAllocateArrayWithRtt
code-creation,Builtin,2,58962,0x1077a0e20,240,WasmAllocateObjectWrapper
code-creation,Builtin,2,58973,0x1077a0f20,52,WasmSubtypeCheck
code-creation,Builtin,2,58984,0x1077a0f60,8,WasmInt32ToNumber
code-creation,Builtin,2,58994,0x1077a0f80,116,WasmUint32ToNumber
code-creation,Builtin,2,59004,0x1077a1000,144,UintPtr53ToNumber
code-creation,Builtin,2,59014,0x1077a10a0,96,WasmAtomicNotify
code-creation,Builtin,2,59024,0x1077a1120,116,WasmI32AtomicWait64
code-creation,Builtin,2,59035,0x1077a11a0,116,WasmI64AtomicWait64
code-creation,Builtin,2,59045,0x1077a1220,580,WasmGetOwnProperty
code-creation,Builtin,2,59056,0x1077a1480,40,WasmTrap
code-creation,Builtin,2,59065,0x1077a14c0,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,59076,0x1077a14e0,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,59087,0x1077a1500,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,59098,0x1077a1520,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,59108,0x1077a1540,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,59120,0x1077a1560,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,59130,0x1077a1580,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,59141,0x1077a15a0,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,59153,0x1077a15c0,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,59165,0x1077a15e0,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,59176,0x1077a1600,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,59187,0x1077a1620,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,59198,0x1077a1640,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,59210,0x1077a1660,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,59221,0x1077a1680,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,59232,0x1077a16a0,168,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,59245,0x1077a1760,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,59257,0x1077a1780,112,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,59277,0x1077a1800,108,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,59289,0x1077a1880,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,59302,0x1077a18a0,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,59315,0x1077a1980,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,59327,0x1077a1a80,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,59340,0x1077a1aa0,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,59353,0x1077a1ac0,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,59366,0x1077a1ae0,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,59379,0x1077a1b00,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,59391,0x1077a1ba0,8,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,59403,0x1077a1bc0,32,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,59416,0x1077a1c00,32,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,59429,0x1077a1c40,32,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,59442,0x1077a1c80,2196,Load_GenericElementsAccessor_0
code-creation,Builtin,2,59455,0x1077a2520,24,Store_GenericElementsAccessor_0
tick,0x7ff808922ae6,59564,0,0x0,6
code-creation,Builtin,2,59585,0x1077a2540,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,59600,0x1077a2580,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,59634,0x1077a25a0,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,59647,0x1077a2660,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,59659,0x1077a2720,112,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,59671,0x1077a27a0,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,59682,0x1077a27e0,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,59695,0x1077a2880,108,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,59706,0x1077a2900,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,59718,0x1077a2920,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,59730,0x1077a29c0,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,59742,0x1077a29e0,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,59754,0x1077a2a00,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,59767,0x1077a2c80,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,59778,0x1077a2d60,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,59790,0x1077a2da0,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,59802,0x1077a2e80,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,59814,0x1077a2f80,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,59826,0x1077a2fc0,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,59838,0x1077a30a0,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,59850,0x1077a30c0,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,59862,0x1077a30e0,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,59873,0x1077a31a0,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,59884,0x1077a31c0,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,59896,0x1077a31e0,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,59908,0x1077a32a0,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,59920,0x1077a32c0,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,59931,0x1077a32e0,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,59944,0x1077a33a0,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,59955,0x1077a33c0,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,59968,0x1077a33e0,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,59980,0x1077a34a0,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,59992,0x1077a3540,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,60006,0x1077a3600,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,60019,0x1077a36c0,12,CollatorConstructor
code-creation,Builtin,2,60029,0x1077a36e0,12,CollatorInternalCompare
code-creation,Builtin,2,60041,0x1077a3700,12,CollatorPrototypeCompare
code-creation,Builtin,2,60053,0x1077a3720,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,60064,0x1077a3740,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,60076,0x1077a3760,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,60087,0x1077a3780,12,DatePrototypeToLocaleString
code-creation,Builtin,2,60100,0x1077a37a0,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,60112,0x1077a37c0,12,DateTimeFormatConstructor
code-creation,Builtin,2,60149,0x1077a37e0,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,60163,0x1077a3800,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,60174,0x1077a3820,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,60186,0x1077a3840,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,60198,0x1077a3860,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,60211,0x1077a3880,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,60223,0x1077a38a0,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,60234,0x1077a38c0,12,DisplayNamesConstructor
code-creation,Builtin,2,60246,0x1077a38e0,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,60272,0x1077a3900,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,60285,0x1077a3920,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,60296,0x1077a3940,12,IntlGetCanonicalLocales
code-creation,Builtin,2,60307,0x1077a3960,12,ListFormatConstructor
code-creation,Builtin,2,60318,0x1077a3980,224,ListFormatPrototypeFormat
code-creation,Builtin,2,60330,0x1077a3a80,224,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,60342,0x1077a3b80,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,60354,0x1077a3ba0,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,60366,0x1077a3bc0,12,LocaleConstructor
code-creation,Builtin,2,60377,0x1077a3be0,12,LocalePrototypeBaseName
code-creation,Builtin,2,60388,0x1077a3c00,12,LocalePrototypeCalendar
code-creation,Builtin,2,60400,0x1077a3c20,12,LocalePrototypeCalendars
code-creation,Builtin,2,60412,0x1077a3c40,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,60423,0x1077a3c60,12,LocalePrototypeCollation
code-creation,Builtin,2,60435,0x1077a3c80,12,LocalePrototypeCollations
code-creation,Builtin,2,60447,0x1077a3ca0,12,LocalePrototypeHourCycle
code-creation,Builtin,2,60459,0x1077a3cc0,12,LocalePrototypeHourCycles
code-creation,Builtin,2,60470,0x1077a3ce0,12,LocalePrototypeLanguage
code-creation,Builtin,2,60481,0x1077a3d00,12,LocalePrototypeMaximize
tick,0x107cf1198,61010,0,0x0,6
code-creation,Builtin,2,61024,0x1077a3d20,12,LocalePrototypeMinimize
code-creation,Builtin,2,61037,0x1077a3d40,12,LocalePrototypeNumeric
code-creation,Builtin,2,61047,0x1077a3d60,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,61058,0x1077a3d80,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,61070,0x1077a3da0,12,LocalePrototypeRegion
code-creation,Builtin,2,61080,0x1077a3dc0,12,LocalePrototypeScript
code-creation,Builtin,2,61090,0x1077a3de0,12,LocalePrototypeTextInfo
code-creation,Builtin,2,61100,0x1077a3e00,12,LocalePrototypeTimeZones
code-creation,Builtin,2,61111,0x1077a3e20,12,LocalePrototypeToString
code-creation,Builtin,2,61572,0x1077a3e40,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,61587,0x1077a3e60,12,NumberFormatConstructor
code-creation,Builtin,2,61598,0x1077a3e80,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,61609,0x1077a3ea0,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,61620,0x1077a3ec0,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,61631,0x1077a3ee0,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,61643,0x1077a3f00,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,61654,0x1077a3f20,12,PluralRulesConstructor
code-creation,Builtin,2,61664,0x1077a3f40,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,61676,0x1077a3f60,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,61686,0x1077a3f80,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,61697,0x1077a3fa0,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,61708,0x1077a3fc0,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,61719,0x1077a3fe0,12,RelativeTimeFormatPrototypeFormatToParts
tick,0x7ff808922ae6,61795,0,0x0,6
code-creation,Builtin,2,61808,0x1077a4000,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,61822,0x1077a4020,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,61834,0x1077a4040,12,SegmenterConstructor
code-creation,Builtin,2,61844,0x1077a4060,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,61855,0x1077a4080,12,SegmenterPrototypeSegment
code-creation,Builtin,2,61866,0x1077a40a0,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,61876,0x1077a40c0,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,61887,0x1077a40e0,12,SegmentsPrototypeContaining
code-creation,Builtin,2,61897,0x1077a4100,12,SegmentsPrototypeIterator
code-creation,Builtin,2,61968,0x1077a4120,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,61981,0x1077a4140,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,61992,0x1077a4160,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,62003,0x1077a4180,200,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,62034,0x1077a4260,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,62046,0x1077a4280,632,StringToLowerCaseIntl
code-creation,Builtin,2,62056,0x1077a4500,12,V8BreakIteratorConstructor
code-creation,Builtin,2,62072,0x1077a4520,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,62083,0x1077a4540,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,62094,0x1077a4560,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,62105,0x1077a4580,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,62115,0x1077a45a0,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,62126,0x1077a45c0,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,62137,0x1077a45e0,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,62147,0x1077a4600,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,62158,0x1077a4620,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,62169,0x1077a4640,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,62179,0x1077a4660,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,62191,0x1077a4680,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,62207,0x1077a46a0,24,Wide
code-creation,BytecodeHandler,0,62217,0x1077a46c0,24,ExtraWide
code-creation,BytecodeHandler,0,62227,0x1077a46e0,104,DebugBreakWide
code-creation,BytecodeHandler,0,62237,0x1077a4760,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,62248,0x1077a47e0,164,DebugBreak0
code-creation,BytecodeHandler,0,62258,0x1077a48a0,104,DebugBreak1
code-creation,BytecodeHandler,0,62268,0x1077a4920,104,DebugBreak2
code-creation,BytecodeHandler,0,62277,0x1077a49a0,104,DebugBreak3
code-creation,BytecodeHandler,0,62287,0x1077a4a20,104,DebugBreak4
code-creation,BytecodeHandler,0,62297,0x1077a4aa0,104,DebugBreak5
code-creation,BytecodeHandler,0,62307,0x1077a4b20,104,DebugBreak6
code-creation,BytecodeHandler,0,62317,0x1077a4ba0,32,Ldar
code-creation,BytecodeHandler,0,62326,0x1077a4be0,68,LdaZero
code-creation,BytecodeHandler,0,62335,0x1077a4c40,76,LdaSmi
code-creation,BytecodeHandler,0,62345,0x1077a4ca0,68,LdaUndefined
code-creation,BytecodeHandler,0,62355,0x1077a4d00,68,LdaNull
code-creation,BytecodeHandler,0,62848,0x1077a4d60,68,LdaTheHole
tick,0x7ff80896f6ee,62942,0,0x0,6
code-creation,BytecodeHandler,0,63315,0x1077a4dc0,20,LdaTrue
code-creation,BytecodeHandler,0,63336,0x1077a4de0,20,LdaFalse
code-creation,BytecodeHandler,0,63347,0x1077a4e00,76,LdaConstant
code-creation,BytecodeHandler,0,63357,0x1077a4e60,132,LdaContextSlot
code-creation,BytecodeHandler,0,63368,0x1077a4f00,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,63380,0x1077a4fa0,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,63391,0x1077a5000,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,63402,0x1077a5060,32,Star
tick,0x7ff808922ae6,64195,0,0x0,6
code-creation,BytecodeHandler,0,64217,0x1077a50a0,40,Mov
code-creation,BytecodeHandler,0,64231,0x1077a50e0,40,PushContext
code-creation,BytecodeHandler,0,64241,0x1077a5120,36,PopContext
code-creation,BytecodeHandler,0,64252,0x1077a5160,48,TestReferenceEqual
code-creation,BytecodeHandler,0,64262,0x1077a51a0,52,TestUndetectable
code-creation,BytecodeHandler,0,64272,0x1077a51e0,36,TestNull
code-creation,BytecodeHandler,0,64282,0x1077a5220,36,TestUndefined
code-creation,BytecodeHandler,0,64292,0x1077a5260,336,TestTypeOf
code-creation,BytecodeHandler,0,64302,0x1077a53c0,4892,LdaGlobal
code-creation,BytecodeHandler,0,64312,0x1077a66e0,3700,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,64323,0x1077a7560,168,StaGlobal
code-creation,BytecodeHandler,0,64332,0x1077a7620,176,StaContextSlot
code-creation,BytecodeHandler,0,64342,0x1077a76e0,132,StaCurrentContextSlot
code-creation,BytecodeHandler,0,64353,0x1077a7780,124,LdaLookupSlot
code-creation,BytecodeHandler,0,64363,0x1077a7800,240,LdaLookupContextSlot
code-creation,BytecodeHandler,0,64374,0x1077a7900,3944,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,64384,0x1077a8880,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,64395,0x1077a8900,240,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,64424,0x1077a8a00,3908,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,64437,0x1077a9960,220,StaLookupSlot
code-creation,BytecodeHandler,0,64447,0x1077a9a40,4452,LdaNamedProperty
code-creation,BytecodeHandler,0,64458,0x1077aabc0,124,LdaNamedPropertyNoFeedback
code-creation,BytecodeHandler,0,64482,0x1077aac40,180,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,64493,0x1077aad00,212,LdaKeyedProperty
code-creation,BytecodeHandler,0,64503,0x1077aade0,160,LdaModuleVariable
code-creation,BytecodeHandler,0,64513,0x1077aaea0,312,StaModuleVariable
code-creation,BytecodeHandler,0,64523,0x1077aafe0,172,StaNamedProperty
code-creation,BytecodeHandler,0,64533,0x1077ab0a0,136,StaNamedPropertyNoFeedback
code-creation,BytecodeHandler,0,64543,0x1077ab140,172,StaNamedOwnProperty
code-creation,BytecodeHandler,0,64554,0x1077ab200,164,StaKeyedProperty
code-creation,BytecodeHandler,0,64564,0x1077ab2c0,164,StaInArrayLiteral
code-creation,BytecodeHandler,0,64574,0x1077ab380,196,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,64584,0x1077ab460,160,CollectTypeProfile
code-creation,BytecodeHandler,0,64595,0x1077ab520,1028,Add
code-creation,BytecodeHandler,0,64603,0x1077ab940,1064,Sub
code-creation,BytecodeHandler,0,64612,0x1077abd80,1024,Mul
code-creation,BytecodeHandler,0,64621,0x1077ac1a0,984,Div
code-creation,BytecodeHandler,0,64630,0x1077ac580,912,Mod
code-creation,BytecodeHandler,0,64639,0x1077ac920,184,Exp
code-creation,BytecodeHandler,0,64648,0x1077ac9e0,876,BitwiseOr
code-creation,BytecodeHandler,0,64657,0x1077acd60,888,BitwiseXor
code-creation,BytecodeHandler,0,64667,0x1077ad0e0,888,BitwiseAnd
code-creation,BytecodeHandler,0,64676,0x1077ad460,900,ShiftLeft
code-creation,BytecodeHandler,0,64685,0x1077ad800,900,ShiftRight
code-creation,BytecodeHandler,0,64695,0x1077adba0,1020,ShiftRightLogical
code-creation,BytecodeHandler,0,64705,0x1077adfa0,956,AddSmi
code-creation,BytecodeHandler,0,64714,0x1077ae360,1000,SubSmi
code-creation,BytecodeHandler,0,64723,0x1077ae760,912,MulSmi
code-creation,BytecodeHandler,0,64732,0x1077aeb00,920,DivSmi
code-creation,BytecodeHandler,0,64741,0x1077aeea0,816,ModSmi
code-creation,BytecodeHandler,0,64750,0x1077af1e0,184,ExpSmi
code-creation,BytecodeHandler,0,64759,0x1077af2a0,488,BitwiseOrSmi
code-creation,BytecodeHandler,0,64769,0x1077af4a0,488,BitwiseXorSmi
code-creation,BytecodeHandler,0,64792,0x1077af6a0,488,BitwiseAndSmi
code-creation,BytecodeHandler,0,64803,0x1077af8a0,488,ShiftLeftSmi
code-creation,BytecodeHandler,0,64813,0x1077afaa0,488,ShiftRightSmi
code-creation,BytecodeHandler,0,64822,0x1077afca0,640,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,64833,0x1077aff40,656,Inc
code-creation,BytecodeHandler,0,64842,0x1077b01e0,656,Dec
code-creation,BytecodeHandler,0,64851,0x1077b0480,640,Negate
code-creation,BytecodeHandler,0,64860,0x1077b0720,480,BitwiseNot
code-creation,BytecodeHandler,0,64869,0x1077b0920,108,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,64880,0x1077b09a0,36,LogicalNot
code-creation,BytecodeHandler,0,64889,0x1077b09e0,208,TypeOf
code-creation,BytecodeHandler,0,64899,0x1077b0ac0,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,64909,0x1077b0b40,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,64919,0x1077b0bc0,40,GetSuperConstructor
code-creation,BytecodeHandler,0,64929,0x1077b0c00,1176,CallAnyReceiver
code-creation,BytecodeHandler,0,64939,0x1077b10a0,1176,CallProperty
code-creation,BytecodeHandler,0,64949,0x1077b1540,1056,CallProperty0
code-creation,BytecodeHandler,0,64959,0x1077b1980,1072,CallProperty1
code-creation,BytecodeHandler,0,64969,0x1077b1dc0,1084,CallProperty2
code-creation,BytecodeHandler,0,64978,0x1077b2200,1056,CallUndefinedReceiver
code-creation,BytecodeHandler,0,64989,0x1077b2640,1088,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,64999,0x1077b2aa0,1068,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,65009,0x1077b2ee0,1080,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,65020,0x1077b3320,60,CallNoFeedback
code-creation,BytecodeHandler,0,65042,0x1077b3360,1176,CallWithSpread
code-creation,BytecodeHandler,0,65052,0x1077b3800,124,CallRuntime
code-creation,BytecodeHandler,0,65062,0x1077b3880,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,65072,0x1077b3920,80,CallJSRuntime
code-creation,BytecodeHandler,0,65081,0x1077b3980,1504,InvokeIntrinsic
code-creation,BytecodeHandler,0,65091,0x1077b3f80,1068,Construct
code-creation,BytecodeHandler,0,65101,0x1077b43c0,556,ConstructWithSpread
code-creation,BytecodeHandler,0,65111,0x1077b4600,1936,TestEqual
code-creation,BytecodeHandler,0,65120,0x1077b4da0,1064,TestEqualStrict
code-creation,BytecodeHandler,0,65130,0x1077b51e0,1624,TestLessThan
code-creation,BytecodeHandler,0,65140,0x1077b5840,1624,TestGreaterThan
code-creation,BytecodeHandler,0,65150,0x1077b5ea0,1624,TestLessThanOrEqual
code-creation,BytecodeHandler,0,65160,0x1077b6500,1624,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,65170,0x1077b6b60,868,TestInstanceOf
code-creation,BytecodeHandler,0,65180,0x1077b6ee0,156,TestIn
code-creation,BytecodeHandler,0,65189,0x1077b6f80,112,ToName
code-creation,BytecodeHandler,0,65198,0x1077b7000,212,ToNumber
code-creation,BytecodeHandler,0,65207,0x1077b70e0,232,ToNumeric
code-creation,BytecodeHandler,0,65217,0x1077b71e0,112,ToObject
code-creation,BytecodeHandler,0,65226,0x1077b7260,116,ToString
code-creation,BytecodeHandler,0,65235,0x1077b72e0,400,CreateRegExpLiteral
code-creation,BytecodeHandler,0,65245,0x1077b7480,1476,CreateArrayLiteral
code-creation,BytecodeHandler,0,65255,0x1077b7a60,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,65266,0x1077b7ac0,820,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,65277,0x1077b7e00,2188,CreateObjectLiteral
code-creation,BytecodeHandler,0,65287,0x1077b86a0,220,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,65298,0x1077b8780,168,CloneObject
code-creation,BytecodeHandler,0,65308,0x1077b8840,212,GetTemplateObject
code-creation,BytecodeHandler,0,65318,0x1077b8920,328,CreateClosure
code-creation,BytecodeHandler,0,65327,0x1077b8a80,120,CreateBlockContext
code-creation,BytecodeHandler,0,65337,0x1077b8b00,132,CreateCatchContext
code-creation,BytecodeHandler,0,65347,0x1077b8ba0,256,CreateFunctionContext
tick,0x7ff8088db22d,65421,0,0x0,6
code-creation,BytecodeHandler,0,65463,0x1077b8cc0,256,CreateEvalContext
code-creation,BytecodeHandler,0,65482,0x1077b8de0,132,CreateWithContext
code-creation,BytecodeHandler,0,65492,0x1077b8e80,1560,CreateMappedArguments
code-creation,BytecodeHandler,0,65503,0x1077b94a0,588,CreateUnmappedArguments
code-creation,BytecodeHandler,0,65514,0x1077b9700,628,CreateRestParameter
code-creation,BytecodeHandler,0,65524,0x1077b9980,532,JumpLoop
code-creation,BytecodeHandler,0,65533,0x1077b9ba0,44,Jump
code-creation,BytecodeHandler,0,65542,0x1077b9be0,56,JumpConstant
code-creation,BytecodeHandler,0,65552,0x1077b9c20,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,65562,0x1077b9c80,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,65895,0x1077b9ce0,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,65908,0x1077b9d40,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,65919,0x1077b9da0,84,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,65930,0x1077b9e00,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,65941,0x1077b9e60,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,65951,0x1077b9ec0,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,65962,0x1077b9f20,152,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,65973,0x1077b9fc0,152,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,65985,0x1077ba060,136,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,65995,0x1077ba100,136,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,66006,0x1077ba1a0,64,JumpIfTrue
code-creation,BytecodeHandler,0,66015,0x1077ba200,64,JumpIfFalse
code-creation,BytecodeHandler,0,66025,0x1077ba260,64,JumpIfNull
code-creation,BytecodeHandler,0,66034,0x1077ba2c0,64,JumpIfNotNull
code-creation,BytecodeHandler,0,66087,0x1077ba320,64,JumpIfUndefined
code-creation,BytecodeHandler,0,66137,0x1077ba380,64,JumpIfNotUndefined
code-creation,BytecodeHandler,0,66155,0x1077ba3e0,72,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,66166,0x1077ba440,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,66310,0x1077ba4a0,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,66349,0x1077ba520,464,ForInEnumerate
code-creation,BytecodeHandler,0,66361,0x1077ba700,252,ForInPrepare
code-creation,BytecodeHandler,0,66371,0x1077ba800,60,ForInContinue
code-creation,BytecodeHandler,0,66381,0x1077ba840,256,ForInNext
code-creation,BytecodeHandler,0,66391,0x1077ba960,48,ForInStep
code-creation,BytecodeHandler,0,66401,0x1077ba9a0,36,SetPendingMessage
code-creation,BytecodeHandler,0,66411,0x1077ba9e0,116,Throw
code-creation,BytecodeHandler,0,66420,0x1077baa60,116,ReThrow
code-creation,BytecodeHandler,0,66430,0x1077baae0,112,Return
code-creation,BytecodeHandler,0,66439,0x1077bab60,196,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,66450,0x1077bac40,132,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,66461,0x1077bace0,132,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,66472,0x1077bad80,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,66483,0x1077bae20,120,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,66494,0x1077baea0,556,SuspendGenerator
code-creation,BytecodeHandler,0,66504,0x1077bb0e0,128,ResumeGenerator
code-creation,BytecodeHandler,0,66513,0x1077bb180,152,GetIterator
code-creation,BytecodeHandler,0,66523,0x1077bb220,116,Debugger
code-creation,BytecodeHandler,0,66532,0x1077bb2a0,124,IncBlockCounter
code-creation,BytecodeHandler,0,66542,0x1077bb320,56,Abort
code-creation,BytecodeHandler,0,66551,0x1077bb360,32,Star0
code-creation,BytecodeHandler,0,66561,0x1077bb3a0,60,Illegal
code-creation,BytecodeHandler,0,66571,0x1077bb3e0,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,66581,0x1077bb460,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,66591,0x1077bb4e0,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,66601,0x1077bb560,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,66611,0x1077bb5e0,108,DebugBreak5.Wide
tick,0x7ff808922ae6,66657,0,0x0,6
code-creation,BytecodeHandler,0,66670,0x1077bb660,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,66681,0x1077bb6e0,32,Ldar.Wide
code-creation,BytecodeHandler,0,66691,0x1077bb720,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,66701,0x1077bb760,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,66711,0x1077bb7a0,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,66722,0x1077bb800,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,66733,0x1077bb860,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,66744,0x1077bb8a0,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,66756,0x1077bb8e0,32,Star.Wide
code-creation,BytecodeHandler,0,66765,0x1077bb920,40,Mov.Wide
code-creation,BytecodeHandler,0,66775,0x1077bb960,40,PushContext.Wide
code-creation,BytecodeHandler,0,66785,0x1077bb9a0,36,PopContext.Wide
code-creation,BytecodeHandler,0,66795,0x1077bb9e0,48,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,66806,0x1077bba20,3832,LdaGlobal.Wide
code-creation,BytecodeHandler,0,66816,0x1077bc920,3764,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,66827,0x1077bd7e0,172,StaGlobal.Wide
code-creation,BytecodeHandler,0,66837,0x1077bd8a0,176,StaContextSlot.Wide
code-creation,BytecodeHandler,0,66847,0x1077bd960,132,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,66858,0x1077bda00,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,66869,0x1077bdaa0,244,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,66880,0x1077bdba0,4012,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,66891,0x1077beb60,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,66902,0x1077bec00,244,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,66914,0x1077bed00,3976,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,66925,0x1077bfca0,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,66936,0x1077bfd80,4456,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,66961,0x1077c0f00,128,LdaNamedPropertyNoFeedback.Wide
code-creation,BytecodeHandler,0,66973,0x1077c0fa0,188,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,66984,0x1077c1060,160,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,66995,0x1077c1120,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,67005,0x1077c11e0,316,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,67016,0x1077c1320,176,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,67026,0x1077c13e0,140,StaNamedPropertyNoFeedback.Wide
code-creation,BytecodeHandler,0,67038,0x1077c1480,176,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,67048,0x1077c1540,168,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,67059,0x1077c1600,168,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,67069,0x1077c16c0,200,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,67081,0x1077c17a0,164,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,67092,0x1077c1860,984,Add.Wide
code-creation,BytecodeHandler,0,67101,0x1077c1c40,1020,Sub.Wide
code-creation,BytecodeHandler,0,67110,0x1077c2040,972,Mul.Wide
code-creation,BytecodeHandler,0,67120,0x1077c2420,988,Div.Wide
code-creation,BytecodeHandler,0,67129,0x1077c2800,916,Mod.Wide
code-creation,BytecodeHandler,0,67139,0x1077c2ba0,188,Exp.Wide
code-creation,BytecodeHandler,0,67148,0x1077c2c60,904,BitwiseOr.Wide
code-creation,BytecodeHandler,0,67158,0x1077c3000,920,BitwiseXor.Wide
code-creation,BytecodeHandler,0,67168,0x1077c33a0,920,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,67178,0x1077c3740,932,ShiftLeft.Wide
code-creation,BytecodeHandler,0,67188,0x1077c3b00,932,ShiftRight.Wide
code-creation,BytecodeHandler,0,67198,0x1077c3ec0,1048,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,67208,0x1077c42e0,916,AddSmi.Wide
code-creation,BytecodeHandler,0,67218,0x1077c4680,960,SubSmi.Wide
code-creation,BytecodeHandler,0,67227,0x1077c4a60,912,MulSmi.Wide
code-creation,BytecodeHandler,0,67237,0x1077c4e00,916,DivSmi.Wide
code-creation,BytecodeHandler,0,67247,0x1077c51a0,816,ModSmi.Wide
code-creation,BytecodeHandler,0,67256,0x1077c54e0,184,ExpSmi.Wide
code-creation,BytecodeHandler,0,67266,0x1077c55a0,496,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,67276,0x1077c57a0,496,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,67287,0x1077c59a0,496,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,67297,0x1077c5ba0,496,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,67307,0x1077c5da0,496,ShiftRightSmi.Wide
tick,0x7ff808922ae6,68757,0,0x0,6
tick,0x7ff808921e26,70495,0,0x0,6
code-creation,BytecodeHandler,0,70682,0x1077c5fa0,648,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,70714,0x1077c6240,616,Inc.Wide
code-creation,BytecodeHandler,0,70726,0x1077c64c0,616,Dec.Wide
tick,0x7ff80896f061,71691,0,0x0,6
tick,0x7ff808921e26,71997,0,0x0,6
code-creation,BytecodeHandler,0,72078,0x1077c6740,644,Negate.Wide
code-creation,BytecodeHandler,0,72097,0x1077c69e0,492,BitwiseNot.Wide
code-creation,BytecodeHandler,0,72110,0x1077c6be0,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,72331,0x1077c6c60,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,72347,0x1077c6ce0,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,72359,0x1077c6d20,1176,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,72371,0x1077c71c0,1176,CallProperty.Wide
code-creation,BytecodeHandler,0,72382,0x1077c7660,1060,CallProperty0.Wide
code-creation,BytecodeHandler,0,72393,0x1077c7aa0,1076,CallProperty1.Wide
code-creation,BytecodeHandler,0,72404,0x1077c7ee0,1088,CallProperty2.Wide
code-creation,BytecodeHandler,0,72415,0x1077c8340,1060,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,72427,0x1077c8780,1092,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,72438,0x1077c8be0,1068,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,72449,0x1077c9020,1084,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,72461,0x1077c9460,64,CallNoFeedback.Wide
code-creation,BytecodeHandler,0,72472,0x1077c94c0,1176,CallWithSpread.Wide
code-creation,BytecodeHandler,0,72503,0x1077c9960,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,72514,0x1077c9a00,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,72526,0x1077c9ac0,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,72537,0x1077c9b20,1508,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,72547,0x1077ca120,1012,Construct.Wide
code-creation,BytecodeHandler,0,72558,0x1077ca520,492,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,72569,0x1077ca720,1964,TestEqual.Wide
code-creation,BytecodeHandler,0,72579,0x1077caee0,1068,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,72590,0x1077cb320,1512,TestLessThan.Wide
code-creation,BytecodeHandler,0,72601,0x1077cb920,1512,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,72612,0x1077cbf20,1512,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,72623,0x1077cc520,1512,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,72634,0x1077ccb20,872,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,72645,0x1077ccea0,160,TestIn.Wide
code-creation,BytecodeHandler,0,72655,0x1077ccf60,116,ToName.Wide
code-creation,BytecodeHandler,0,72665,0x1077ccfe0,216,ToNumber.Wide
code-creation,BytecodeHandler,0,72675,0x1077cd0c0,236,ToNumeric.Wide
code-creation,BytecodeHandler,0,72686,0x1077cd1c0,116,ToObject.Wide
code-creation,BytecodeHandler,0,72775,0x1077cd240,404,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,72851,0x1077cd3e0,1384,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,72911,0x1077cd960,820,CreateEmptyArrayLiteral.Wide
tick,0x7ff80884ea66,73273,0,0x0,6
code-creation,BytecodeHandler,0,73402,0x1077cdca0,2088,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,73424,0x1077ce4e0,172,CloneObject.Wide
code-creation,BytecodeHandler,0,73465,0x1077ce5a0,164,GetTemplateObject.Wide
tick,0x7ff80882a87f,74289,0,0x0,6
tick,0x7ff808921e26,77574,0,0x0,6
code-creation,BytecodeHandler,0,77609,0x1077ce660,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,77625,0x1077ce7c0,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,77637,0x1077ce840,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,77649,0x1077ce8e0,256,CreateFunctionContext.Wide
tick,0x7ff808957d9d,78964,0,0x0,6
tick,0x7ff808921e26,82578,0,0x0,6
code-creation,BytecodeHandler,0,82612,0x1077cea00,256,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,82628,0x1077ceb20,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,82641,0x1077cebc0,552,JumpLoop.Wide
code-creation,BytecodeHandler,0,82652,0x1077cee00,44,Jump.Wide
code-creation,BytecodeHandler,0,82663,0x1077cee40,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,82674,0x1077cee80,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,82686,0x1077ceee0,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,82699,0x1077cef40,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,82710,0x1077cefa0,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,82723,0x1077cf000,84,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,82736,0x1077cf060,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,82748,0x1077cf0c0,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,82760,0x1077cf120,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,82772,0x1077cf180,152,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,82784,0x1077cf220,152,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,82797,0x1077cf2c0,136,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,82809,0x1077cf360,136,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,82820,0x1077cf400,64,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,82831,0x1077cf460,64,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,82842,0x1077cf4c0,64,JumpIfNull.Wide
code-creation,BytecodeHandler,0,82853,0x1077cf520,64,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,82864,0x1077cf580,64,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,82875,0x1077cf5e0,64,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,82906,0x1077cf640,72,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,82919,0x1077cf6a0,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,82930,0x1077cf700,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,82942,0x1077cf780,468,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,82954,0x1077cf960,252,ForInPrepare.Wide
code-creation,BytecodeHandler,0,82964,0x1077cfa60,60,ForInContinue.Wide
code-creation,BytecodeHandler,0,82975,0x1077cfaa0,260,ForInNext.Wide
code-creation,BytecodeHandler,0,82986,0x1077cfbc0,48,ForInStep.Wide
code-creation,BytecodeHandler,0,82997,0x1077cfc00,156,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,83010,0x1077cfca0,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,83022,0x1077cfd60,120,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,83034,0x1077cfde0,568,SuspendGenerator.Wide
tick,0x7ff808922ae6,83074,0,0x0,6
code-creation,BytecodeHandler,0,83089,0x1077d0020,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,83102,0x1077d00c0,156,GetIterator.Wide
code-creation,BytecodeHandler,0,83113,0x1077d0160,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,83124,0x1077d0200,56,Abort.Wide
code-creation,BytecodeHandler,0,83135,0x1077d0240,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,83146,0x1077d02c0,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,83157,0x1077d0340,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,83168,0x1077d03c0,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,83180,0x1077d0440,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,83191,0x1077d04c0,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,83202,0x1077d0540,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,83213,0x1077d0580,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,83224,0x1077d05a0,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,83235,0x1077d05e0,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83247,0x1077d0640,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83260,0x1077d06a0,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83272,0x1077d06e0,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83285,0x1077d0720,28,Star.ExtraWide
code-creation,BytecodeHandler,0,83296,0x1077d0740,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,83306,0x1077d0780,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,83317,0x1077d07c0,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,83329,0x1077d0800,48,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,83341,0x1077d0840,3820,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,83352,0x1077d1740,3752,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,83364,0x1077d2600,168,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,83376,0x1077d26c0,172,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83387,0x1077d2780,132,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83400,0x1077d2820,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,83411,0x1077d28c0,240,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,83423,0x1077d29c0,4000,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,83436,0x1077d3980,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,83448,0x1077d3a20,240,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,83462,0x1077d3b20,3964,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,83475,0x1077d4aa0,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,83486,0x1077d4b80,4440,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,83498,0x1077d5ce0,124,LdaNamedPropertyNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,83511,0x1077d5d60,184,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,83524,0x1077d5e20,156,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,83535,0x1077d5ec0,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,83547,0x1077d5f80,316,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,83573,0x1077d60c0,172,StaNamedProperty.ExtraWide
tick,0x106fb417a,84221,0,0x0,6
code-creation,BytecodeHandler,0,84239,0x1077d6180,136,StaNamedPropertyNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,84254,0x1077d6220,172,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,84267,0x1077d62e0,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,84279,0x1077d63a0,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,84307,0x1077d6460,196,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,84332,0x1077d6540,164,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,84345,0x1077d6600,980,Add.ExtraWide
code-creation,BytecodeHandler,0,84355,0x1077d69e0,1016,Sub.ExtraWide
code-creation,BytecodeHandler,0,84366,0x1077d6de0,968,Mul.ExtraWide
code-creation,BytecodeHandler,0,84377,0x1077d71c0,984,Div.ExtraWide
code-creation,BytecodeHandler,0,84387,0x1077d75a0,912,Mod.ExtraWide
code-creation,BytecodeHandler,0,84398,0x1077d7940,188,Exp.ExtraWide
code-creation,BytecodeHandler,0,84409,0x1077d7a00,904,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,84420,0x1077d7da0,916,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,84431,0x1077d8140,916,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,84442,0x1077d84e0,928,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,84453,0x1077d88a0,928,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,84464,0x1077d8c60,1048,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,84476,0x1077d9080,916,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,84487,0x1077d9420,956,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,84498,0x1077d97e0,908,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,84517,0x1077d9b80,916,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,84529,0x1077d9f20,812,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,84539,0x1077da260,184,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,84550,0x1077da320,492,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,84562,0x1077da520,492,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,84573,0x1077da720,492,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,84585,0x1077da920,492,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,84596,0x1077dab20,492,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,84607,0x1077dad20,644,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,84619,0x1077dafc0,616,Inc.ExtraWide
code-creation,BytecodeHandler,0,84630,0x1077db240,616,Dec.ExtraWide
code-creation,BytecodeHandler,0,84640,0x1077db4c0,644,Negate.ExtraWide
code-creation,BytecodeHandler,0,84651,0x1077db760,488,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,84663,0x1077db960,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,84675,0x1077db9e0,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,84687,0x1077dba60,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,84700,0x1077dbaa0,1172,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,84711,0x1077dbf40,1172,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,84723,0x1077dc3e0,1052,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,84734,0x1077dc800,1068,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,84746,0x1077dcc40,1080,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,84758,0x1077dd080,1056,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,84770,0x1077dd4c0,1092,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,84782,0x1077dd920,1068,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,84795,0x1077ddd60,1080,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,84807,0x1077de1a0,60,CallNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,84819,0x1077de1e0,1172,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,84831,0x1077de680,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,84842,0x1077de720,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,84854,0x1077de7e0,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,84887,0x1077de840,1508,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,84900,0x1077dee40,1008,Construct.ExtraWide
code-creation,BytecodeHandler,0,84911,0x1077df240,488,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,84923,0x1077df440,1964,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,84935,0x1077dfc00,1068,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,84946,0x1077e0040,1508,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,84957,0x1077e0640,1508,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,84969,0x1077e0c40,1508,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,84982,0x1077e1240,1508,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,84994,0x1077e1840,872,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,85006,0x1077e1bc0,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,85017,0x1077e1c60,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,85027,0x1077e1ce0,216,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,85039,0x1077e1dc0,236,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,85050,0x1077e1ec0,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,85061,0x1077e1f40,400,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,85073,0x1077e20e0,1384,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,85085,0x1077e2660,820,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,85098,0x1077e29a0,2088,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,85110,0x1077e31e0,168,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,85121,0x1077e32a0,160,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,85133,0x1077e3360,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,85145,0x1077e34c0,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,85157,0x1077e3540,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,85170,0x1077e35e0,252,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,85182,0x1077e36e0,252,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,85194,0x1077e37e0,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,85206,0x1077e3880,552,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,85217,0x1077e3ac0,44,Jump.ExtraWide
tick,0x7ff80896f061,85709,0,0x0,6
code-creation,BytecodeHandler,0,85727,0x1077e3b00,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,85743,0x1077e3b40,76,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,85756,0x1077e3ba0,76,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,85769,0x1077e3c00,76,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,85848,0x1077e3c60,76,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,85884,0x1077e3cc0,84,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,85898,0x1077e3d20,76,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,85910,0x1077e3d80,76,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,85923,0x1077e3de0,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,85935,0x1077e3e40,148,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,85948,0x1077e3ee0,148,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,85962,0x1077e3f80,136,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,85974,0x1077e4020,136,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,85987,0x1077e40c0,64,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,85998,0x1077e4120,64,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,86010,0x1077e4180,64,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,86022,0x1077e41e0,64,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,86034,0x1077e4240,64,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,86046,0x1077e42a0,64,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,86058,0x1077e4300,68,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,86070,0x1077e4360,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,86082,0x1077e43c0,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,86114,0x1077e4440,464,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,86126,0x1077e4620,252,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,86139,0x1077e4720,56,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,86150,0x1077e4760,256,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,86161,0x1077e4880,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,86173,0x1077e48c0,156,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,86185,0x1077e4960,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,86198,0x1077e4a20,120,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,86211,0x1077e4aa0,564,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,86223,0x1077e4ce0,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,86235,0x1077e4d60,152,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,86247,0x1077e4e00,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,86258,0x1077e4e80,56,Abort.ExtraWide
tick,0x106ff9944,86496,0,0x0,5
new,MemoryChunk,0x216c70d80000,262144
new,MemoryChunk,0x216c3ae80000,262144
tick,0x107cfbbd2,87806,0,0x0,5
tick,0x1073cf465,89116,0,0x0,5
new,MemoryChunk,0x216c20640000,262144
tick,0x1073d0884,90166,0,0x0,5
tick,0x1073cf465,91466,0,0x0,5
new,MemoryChunk,0x216c7df40000,262144
tick,0x1072d0e0a,92755,0,0x0,5
tick,0x10741b860,93853,0,0x0,6
code-creation,Eval,10,94771,0x216c7df78c2e,5, node:internal/main/run_main_module:1:1,0x216c7df78ad8,~
script-source,90,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x216c7df78c2e,90,0,632,C0O0C4O632,,
code-creation,Function,10,94896,0x216c7df78ce6,58, node:internal/main/run_main_module:1:1,0x216c7df78b98,~
code-source-info,0x216c7df78ce6,90,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
tick,0x107037a60,95126,0,0x0,6
code-creation,LazyCompile,10,95632,0x216c7df78f36,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x216c014cf8c8,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n  */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
tick,0x7ff808957ef2,96816,0,0x0,3,0x10739e050,0x216c7df78ce9
code-source-info,0x216c7df78f36,9,10315,10658,C0O10324C2O10335C4O10331C9O10351C13O10372C14O10392C19O10405C24O10409C29O10409C35O10550C37O10560C47O10608C60O10566C65O10560C66O10629C71O10629C75O10656,,
code-creation,LazyCompile,10,96972,0x216c7df79c46,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x216c014cf7f8,~
code-source-info,0x216c7df79c46,9,9528,10089,C0O9546C6O9561C12O9590C16O9598C17O9626C22O9634C23O9647C30O9690C37O9721C45O9690C63O9820C70O9820C75O9855C89O9890C103O9847C108O9928C109O9940C124O9970C126O9983C141O10003C152O10022C160O10054C165O10003C170O10077C174O10085,,
tick,0x106ff913a,97471,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c7df78ce9
code-creation,Eval,10,97666,0x216c7df7aba6,5, node:internal/bootstrap/pre_execution:1:1,0x216c7df7a800,~
script-source,91,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  shouldNotRegisterESMLoader\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  // TODO(joyeecheung): snapshot fast APIs (which need to work with\n  // array buffers\x2C whose connection with C++ needs to be rebuilt after\n  // deserialization).\n  const {\n    hrtime\x2C\n    hrtimeBigInt\n  } = require('internal/process/per_thread').getFastAPIs(binding);\n\n  process.hrtime = hrtime;\n  process.hrtime.bigint = hrtimeBigInt;\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    configurable: false\x2C\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {}\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  CJSLoader.Module._initPaths();\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x216c7df7aba6,91,0,15915,C0O0C4O15915,,
tick,0x7ff80884ea41,99930,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c7df78ce9
tick,0x7ff808957cc0,99941,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c7df78ce9
code-creation,Function,10,99956,0x216c7df7b6b6,426, node:internal/bootstrap/pre_execution:1:1,0x216c7df7ab10,~
code-source-info,0x216c7df7b6b6,91,0,15915,C0O0C190O25C196O43C202O67C208O78C214O93C220O122C226O211C232O211C237O162C243O180C249O276C255O276C260O248C266O324C272O324C277O313C283O385C289O385C294O411C299O351C305O434C311O434C315O434C317O15518C324O15539C330O15561C336O15583C342O15606C348O15623C354O15641C360O15671C366O15697C372O15720C378O15750C384O15782C390O15804C396O15831C402O15854C408O15874C414O15897C420O15533C425O15914,,
code-creation,Eval,10,100303,0x216c7df7cfa6,5, node:internal/options:1:1,0x216c7df7cde0,~
script-source,92,node:internal/options,'use strict';\n\nconst { getOptions\x2C shouldNotRegisterESMLoader } = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\n\n// getOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  shouldNotRegisterESMLoader\n};\n
code-source-info,0x216c7df7cfa6,92,0,1612,C0O0C4O1612,,
code-creation,Function,10,100514,0x216c7df7d32e,139, node:internal/options:1:1,0x216c7df7cf10,~
code-source-info,0x216c7df7d32e,92,0,1612,C0O0C43O66C46O66C51O23C57O35C62O125C63O125C65O136C66O136C68O152C69O152C71O1401C78O1540C84O1558C90O1582C133O1416C138O1611,,
code-creation,LazyCompile,10,100628,0x216c7df7d7ce,69,internalBinding node:internal/bootstrap/loaders:164:45,0x216c014cf348,~
tick,0x7ff8088ccc6b,100712,0,0x0,3,0x10739e050,0x216c7df7d35c,0x216c7df79cad,0x216c7df78f7d,0x216c7df7b79e,0x216c7df79cad,0x216c7df78f7d,0x216c7df78ce9
code-source-info,0x216c7df7d7ce,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
code-creation,LazyCompile,10,101035,0x216c7df7debe,213,prepareMainThreadExecution node:internal/bootstrap/pre_execution:22:36,0x216c7df7abd8,~
code-source-info,0x216c7df7debe,91,498,2387,C10O641C15O641C18O743C21O743C25O778C28O778C31O807C34O807C37O827C40O827C43O852C46O852C49O1055C52O1067C57O1071C63O1095C66O1103C77O1159C82O1163C87O1132C91O1124C95O1190C98O1190C101O1282C104O1282C107O1388C110O1388C113O1410C116O1410C119O1469C122O1469C125O1792C128O1792C131O1867C134O1867C137O2064C140O2064C143O2091C146O2091C149O2125C152O2125C155O2153C158O2153C161O2173C164O2173C167O2198C170O2198C173O2242C179O2242C184O2284C189O2302C195O2284C199O2332C202O2332C205O2356C208O2356C212O2386,,
new,MemoryChunk,0x216c15940000,262144
code-creation,LazyCompile,10,101243,0x216c7df7f0e6,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x216cb0d31b08,~
script-source,19,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x216c7df7f0e6,19,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x7ff8088ccc66,104802,0,0x0,3,0x10739e050,0x216c7df7decd,0x216c7df78cf5
tick,0x7ff80884eabf,104821,0,0x0,3,0x10739e050,0x216c7df7decd,0x216c7df78cf5
tick,0x7ff808957f70,104831,0,0x0,3,0x10739e050,0x216c7df7decd,0x216c7df78cf5
code-creation,LazyCompile,10,105048,0x216c15943916,432,patchProcessObject node:internal/bootstrap/pre_execution:81:28,0x216c7df7ac28,~
code-source-info,0x216c15943916,91,2416,4258,C0O2450C6O2450C11O2496C19O2496C24O2734C30O2734C35O2772C40O2773C46O2703C51O2715C56O2798C61O2813C65O2825C68O2833C75O2847C79O2866C90O2887C98O2973C104O2977C111O2866C116O2989C119O2997C129O3015C133O3005C137O3028C144O3055C151O3059C158O3073C164O3107C171O3111C178O3073C185O3189C191O3189C199O3222C202O3230C210O3245C218O3261C225O3265C229O3245C234O3238C244O3433C253O3433C258O3479C267O3479C272O3532C281O3532C286O3592C295O3592C300O3650C309O3650C314O3710C323O3710C328O3774C337O3774C342O3839C351O3839C356O3910C365O3910C370O3980C379O3980C384O4040C393O4040C398O4110C409O4110C414O4180C425O4180C431O4257,,
code-creation,LazyCompile,10,105315,0x216c15943fb6,113,getFastAPIs node:internal/process/per_thread:57:21,0x216cb0d3c6f0,~
script-source,23,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nfunction getFastAPIs(binding) {\n  const {\n    hrtime: _hrtime\n  } = binding.getFastAPIs();\n\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  const hrValues = new Uint32Array(_hrtime.buffer);\n\n  function hrtime(time) {\n    _hrtime.hrtime();\n\n    if (time !== undefined) {\n      validateArray(time\x2C 'time');\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n      }\n\n      const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1]\x2C\n      hrValues[2]\x2C\n    ];\n  }\n\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  const hrBigintValues = new BigUint64Array(_hrtime.buffer\x2C 0\x2C 1);\n  function hrtimeBigInt() {\n    _hrtime.hrtimeBigInt();\n    return hrBigintValues[0];\n  }\n\n  return {\n    hrtime\x2C\n    hrtimeBigInt\x2C\n  };\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  getFastAPIs\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\n};\n
code-source-info,0x216c15943fb6,23,1229,2412,C0O1229C24O1285C29O1285C34O1263C40O1500C50O1524C57O1500C62O1500C64O2232C74O2259C86O2232C91O2232C93O2367C100O2380C106O2392C112O2410,,
tick,0x107142466,106469,0,0x0,3,0x10739e050,0x216c1594393e,0x216c7df7ded3,0x216c7df78cf5
code-creation,LazyCompile,10,106718,0x216c1594568e,175,resolve node:path:1091:10,0x216c14563910,~
script-source,35,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instancee\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
tick,0x7ff808957d23,112154,0,0x0,3,0x10739e050,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
tick,0x7ff808839b7c,112166,0,0x0,3,0x10739e050,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
tick,0x7ff808839d16,112176,0,0x0,3,0x10739e050,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
tick,0x1071426a1,112184,0,0x0,3,0x10739e050,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
tick,0x7ff808957d1e,112193,0,0x0,3,0x10739e050,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
code-source-info,0x216c1594568e,35,33782,34692,C0O33782C3O33817C6O33848C8O33878C12O33885C16O33898C18O33892C25O33902C27O33946C28O33948C35O33959C42O33965C45O33965C49O33984C57O33984C62O34058C68O34065C73O34082C75O34107C87O34133C92O34155C99O34182C107O34221C109O34217C113O33921C118O33860C121O34437C126O34483C137O34452C143O34569C147O34599C152O34610C156O34625C157O34656C163O34663C174O34688,,
code-creation,LazyCompile,10,112337,0x216c159488d6,30,validateString node:internal/validators:117:24,0x216cb0d19d68,~
script-source,17,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C {\n    nullable = false\x2C\n    allowArray = false\x2C\n    allowFunction = false\x2C\n  } = {}) => {\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C { minLength = 0 } = {}) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  if (typeof signal !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C signal);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C { allowZero = true } = {}) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
tick,0x7ff808957d06,127733,0,0x0,3,0x10739e050,0x216c159456c7,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
tick,0x106ea14a3,127746,0,0x0,3,0x10739e050,0x216c159456c7,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
code-source-info,0x216c159488d6,17,3398,3507,C0O3416C6O3451C22O3457C27O3451C29O3506,,
code-creation,LazyCompile,10,128160,0x216c15949206,13, node:path:1082:10,0x216c145638c0,~
code-source-info,0x216c15949206,35,33631,33650,C0O33645C3O33645C8O33645C12O33650,,
code-creation,LazyCompile,10,128225,0x216c15949316,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x216c4dfbe558,~
script-source,89,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x216c15949316,89,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
tick,0x106eb8daa,128788,0,0x0,2,0x10739e050,0x216c15945717,0x216c159439fb,0x216c7df7ded3,0x216c7df78cf5
code-creation,LazyCompile,10,128865,0x216c1594998e,442,normalizeString node:path:66:25,0x216c14563428,~
code-source-info,0x216c1594998e,35,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,128995,0x216c15949d1e,8,isPosixPathSeparator node:path:56:30,0x216c14563388,~
code-source-info,0x216c15949d1e,35,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,129142,0x216c1594a096,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:129:33,0x216c7df7ac78,~
code-source-info,0x216c1594a096,91,4292,4517,C16O4344C21O4344C26O4370C28O4387C36O4417C43O4480C49O4498C56O4387C62O4516,,
code-creation,LazyCompile,10,129215,0x216c1594a226,82,getOptionValue node:internal/options:28:24,0x216c7df7d078,~
code-source-info,0x216c1594a226,92,692,932,C0O725C3O725C7O767C15O767C22O817C30O839C38O839C43O826C47O817C53O854C55O879C60O885C61O907C66O907C74O922C81O930,,
code-creation,LazyCompile,10,129270,0x216c1594a58e,33,getOptionsFromBinding node:internal/options:14:31,0x216c7df7cfd8,~
code-source-info,0x216c1594a58e,92,439,537,C0O446C6O469C11O496C15O481C28O517C32O535,,
code-creation,LazyCompile,10,129972,0x216c1594a98e,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:221:33,0x216c7df7af20,~
code-source-info,0x216c1594a98e,91,6760,6987,C0O6802C6O6802C11O6775C16O6874C22O6874C27O6845C32O6916C35O6941C40O6916C45O6986,,
tick,0x7ff8088e91b6,130086,0,0x0,3,0x10739e050,0x216c7df7deda,0x216c7df78cf5
code-creation,LazyCompile,10,130131,0x216c1594ab36,77,toggleTraceCategoryState node:internal/process/per_thread:385:34,0x216cb0d3cce0,~
code-source-info,0x216c1594ab36,23,11040,11337,C0O11064C4O11093C10O11128C16O11159C21O11203C26O11204C33O11149C39O11228C44O11249C49O11249C55O11268C61O11300C66O11321C71O11321C76O11336,,
code-creation,LazyCompile,10,130194,0x216c1594acf6,42,setupPerfHooks node:internal/bootstrap/pre_execution:227:24,0x216c7df7af70,~
code-source-info,0x216c1594acf6,91,7012,7132,C0O7019C6O7019C11O7055C16O7056C20O7079C26O7079C31O7109C36O7110C41O7131,,
code-creation,LazyCompile,10,130266,0x216c1594ae86,42,refreshTimeOrigin node:internal/perf/performance:118:27,0x216c18bf84d8,~
script-source,69,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  TypeError\x2C\n} = primordials;\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarks\x2C\n} = require('internal/perf/usertiming');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    // eslint-disable-next-line no-restricted-syntax\n    throw new TypeError('Illegal constructor');\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x216c1594ae86,69,2596,2753,C0O2603C7O2624C10O2636C25O2720C28O2720C35O2603C41O2752,,
code-creation,LazyCompile,10,130657,0x216c1594b3c6,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x216c14575910,~
script-source,41,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x216c1594b3c6,41,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,130797,0x216c1594b646,62,setupInspectorHooks node:internal/bootstrap/pre_execution:232:29,0x216c7df7afc0,~
code-source-info,0x216c1594b646,91,7162,7715,C0O7505C6O7509C11O7534C17O7599C23O7599C28O7569C33O7583C38O7645C44O7645C49O7673C54O7674C61O7714,,
code-creation,Eval,10,130953,0x216c1594ba06,5, node:internal/inspector_async_hook:1:1,0x216c1594b840,~
script-source,93,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x216c1594ba06,93,0,1972,C0O0C4O1972,,
code-creation,Function,10,131240,0x216c1594bc36,79, node:internal/inspector_async_hook:1:1,0x216c1594b970,~
code-source-info,0x216c1594bc36,93,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
tick,0x1073f92e0,131315,1,0x106d4ba80,6,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1594b65d,0x216c7df7dee6,0x216c7df78cf5
code-creation,LazyCompile,10,131440,0x216c1594c13e,69,setupWarningHandler node:internal/bootstrap/pre_execution:141:29,0x216c7df7acc8,~
code-source-info,0x216c1594c13e,91,4547,4744,C0O4582C6O4582C11O4566C16O4621C24O4625C33O4669C38O4673C45O4690C50O4705C53O4713C61O4713C68O4743,,
code-creation,LazyCompile,10,131645,0x216c1594c2ae,20,addListener node:events:490:58,0x216c014f24d8,~
script-source,13,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  inspect\n} = require('internal/util/inspect');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @returns {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catcheable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    const { inspect } = require('internal/util/inspect');\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target\x2C { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError());\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError());\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x216c1594c2ae,13,14253,14325,C0O14274C14O14281C19O14323,,
tick,0x107ff1b54,134754,0,0x0,3,0x10739e050,0x216c1594c17b,0x216c7df7deec,0x216c7df78cf5
tick,0x7ff80896f26a,134775,0,0x0,3,0x10739e050,0x216c1594c17b,0x216c7df7deec,0x216c7df78cf5
code-creation,LazyCompile,10,134910,0x216c1594e53e,387,_addListener node:events:422:22,0x216c014f2438,~
code-source-info,0x216c1594e53e,13,12040,14055,C0O12082C2O12091C4O12105C6O12118C9O12118C13O12162C18O12173C20O12205C22O12231C27O12231C32O12229C39O12255C40O12275C46O12441C52O12483C60O12536C77O12483C82O12715C87O12734C89O12751C93O12766C97O12877C99O12890C103O12906C109O12915C115O12944C121O13049C129O13083C140O13094C149O13104C166O13117C175O13127C182O13073C193O13202C197O13232C202O13232C209O13279C214O13279C219O13337C222O13341C227O13371C228O13377C233O13393C240O13400C245O13417C251O13433C252O13449C256O13582C264O13679C278O13689C281O13689C295O13639C304O13755C307O13763C312O13755C327O13715C333O13794C339O13582C345O13876C347O13883C351O13922C353O13932C357O13948C359O13955C363O13988C367O13977C371O14002C374O14010C379O14010C384O14039C386O14053,,
tick,0x1072b096c,135037,0,0x0,2,0x10739e050,0x216c1594e547,0x216c1594c2bc,0x216c1594c17b,0x216c7df7deec,0x216c7df78cf5
code-creation,LazyCompile,10,135064,0x216c1594e886,15,checkListener node:events:130:23,0x216c014f1d98,~
code-source-info,0x216c1594e886,13,3673,3729,C0O3688C8O3688C14O3728,,
code-creation,LazyCompile,10,135131,0x216c1594e986,30, node:internal/validators:227:42,0x216cb0d1a1d0,~
code-source-info,0x216c1594e986,17,6933,7049,C0O6954C6O6991C22O6997C27O6991C29O7048,,
code-creation,LazyCompile,10,135288,0x216c1594ec26,401,emit node:events:343:44,0x216c014f2378,~
code-source-info,0x216c1594ec26,13,9744,12016,C0O9744C8O9778C10O9784C14O9821C19O9832C21O9864C27O9886C29O9885C34O9927C42O9932C52O9927C57O9961C61O9990C69O10021C73O10039C74O10052C75O10111C79O10134C81O10151C88O10158C93O10169C94O10178C98O10187C100O10205C102O10194C110O10250C112O10262C122O10307C128O10317C134O10262C139O10332C147O10357C159O10406C176O10406C188O10332C199O10680C201O10680C202O10732C204O10771C212O10771C218O10759C226O10837C234O10835C235O10870C240O10967C248O10967C254O11011C256O11023C260O11033C262O11033C263O11094C265O11100C269O11111C271O11142C272O11155C273O11159C279O11223C285O11223C292O11377C298O11430C314O11430C321O11507C326O11537C330O11537C335O11575C337O11580C339O11580C344O11615C346O11624C351O11628C357O11628C364O11890C370O11945C386O11945C391O11589C396O11562C399O12002C400O12014,,
code-creation,LazyCompile,10,135439,0x216c1594eff6,172,startListeningIfSignal node:internal/process/signal:22:32,0x216c4dfbd008,~
script-source,88,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x216c1594eff6,88,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,135623,0x216c1594f3c6,19,isSignal node:internal/process/signal:17:18,0x216c4dfbce50,~
code-source-info,0x216c1594f3c6,88,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,135711,0x216c1594f576,75,setupDebugEnv node:internal/bootstrap/pre_execution:193:23,0x216c7df7ae30,~
code-source-info,0x216c1594f576,91,6010,6220,C0O6017C6O6017C11O6050C19O6078C24O6082C29O6051C34O6097C42O6101C48O6145C54O6145C59O6182C64O6195C69O6196C74O6219,,
code-creation,LazyCompile,10,135810,0x216c1594f91e,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x216c14574cb8,~
script-source,40,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x216c1594f91e,40,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
tick,0x7ff8088ccc7d,136226,0,0x0,3,0x10739e050,0x216c1594f593,0x216c7df7df20,0x216c7df78cf5
code-creation,LazyCompile,10,136266,0x216c1595001e,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:172:40,0x216c7df7ad68,~
code-source-info,0x216c1595001e,91,5574,5760,C0O5581C8O5586C14O5626C15O5633C16O5667C22O5667C27O5648C32O5717C38O5750C43O5750C48O5759,,
code-creation,LazyCompile,10,136352,0x216c1595029e,62,initializeReport node:internal/bootstrap/pre_execution:182:26,0x216c7df7adb8,~
code-source-info,0x216c1595029e,91,5787,5986,C0O5787C8O5813C16O5813C21O5802C27O5851C42O5872C47O5944C55O5851C61O5985,,
code-creation,Eval,10,136555,0x216c15950856,5, node:internal/process/report:1:1,0x216c15950640,~
script-source,94,node:internal/process/report,'use strict';\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined && typeof file !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('file'\x2C 'String'\x2C file);\n    } else if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x216c15950856,94,0,2623,C0O0C4O2623,,
code-creation,Function,10,136836,0x216c1595137e,315, node:internal/process/report:1:1,0x216c159507c0,~
code-source-info,0x216c1595137e,94,0,2623,C0O0C51O66C54O66C59O92C64O24C70O48C76O189C79O189C84O110C90O129C96O147C102O169C108O232C111O232C115O232C117O269C123O312C128O316C136O756C290O2572C297O2593C303O2613C309O2587C314O2622,,
code-creation,LazyCompile,10,137114,0x216c1595304e,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:201:40,0x216c7df7ae80,~
code-source-info,0x216c1595304e,91,6321,6417,C0O6357C6O6357C11O6336C16O6396C20O6416,,
code-creation,LazyCompile,10,137193,0x216c159531a6,57,addSignalHandler node:internal/process/report:97:26,0x216c15950888,~
code-source-info,0x216c159531a6,94,2222,2368,C0O2232C5O2239C10O2239C16O2269C22O2304C27O2313C32O2313C38O2331C41O2339C49O2339C56O2367,,
code-creation,LazyCompile,10,137265,0x216c15953776,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:207:46,0x216c7df7aed0,~
tick,0x7ff808922ae6,137353,0,0x0,3,0x10739e050,0x216c7df7df38,0x216c7df78cf5
code-source-info,0x216c15953776,91,6464,6726,C0O6464C8O6486C18O6486C23O6530C25O6547C26O6554C27O6558C35O6558C40O6588C45O6589C50O6649C58O6649C63O6627C69O6667C74O6675C79O6678C84O6675C91O6725,,
code-creation,LazyCompile,10,137460,0x216c15953a16,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:337:37,0x216c7df7b0a0,~
code-source-info,0x216c15953a16,91,10478,11007,C0O10485C3O10497C8O10501C14O10539C20O10539C25O10583C33O10606C38O10610C46O10583C52O10636C53O10646C57O10636C61O10727C64O10742C73O10800C76O10808C81O10812C90O10859C93O10874C102O10916C108O10916C113O10940C118O10941C124O10980C127O10995C132O10980C137O11006,,
code-creation,LazyCompile,10,137565,0x216c15953bb6,21,assert node:internal/assert:11:16,0x216cb0d17750,~
script-source,16,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x216c15953bb6,16,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,Eval,10,138283,0x216c15954a76,5, node:child_process:1:1,0x216c15954590,~
script-source,95,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeLastIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeSet\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst {\n  promisify\x2C\n  convertToValidSignal\x2C\n  createDeferredPromise\x2C\n  getSystemErrorName\n} = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nlet debug = require('internal/util/debuglog').debuglog(\n  'child_process'\x2C\n  (fn) => {\n    debug = fn;\n  }\n);\nconst { Buffer } = require('buffer');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\n\nconst {\n  AbortError\x2C\n  codes: errorCodes\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = errorCodes;\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { getValidatedPath } = require('internal/fs/utils');\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst child_process = require('internal/child_process');\nconst {\n  getValidStdio\x2C\n  setupChannel\x2C\n  ChildProcess\x2C\n  stdioStringToArray\n} = child_process;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n/**\n * Spawns a new Node.js process + fork.\n * @param {string} modulePath\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   detached?: boolean;\n *   env?: Object;\n *   execPath?: string;\n *   execArgv?: string[];\n *   gid?: number;\n *   serialization?: string;\n *   signal?: AbortSignal;\n *   killSignal?: string | number;\n *   silent?: boolean;\n *   stdio?: Array | string;\n *   uid?: number;\n *   windowsVerbatimArguments?: boolean;\n *   timeout?: number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction fork(modulePath /* \x2C args\x2C options */) {\n  validateString(modulePath\x2C 'modulePath');\n\n  // Get options and args arguments.\n  let execArgv;\n  let options = {};\n  let args = [];\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  }\n\n  if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && arguments[pos] != null) {\n    if (typeof arguments[pos] !== 'object') {\n      throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`\x2C arguments[pos]);\n    }\n\n    options = { ...arguments[pos++] };\n  }\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\n    }\n  }\n\n  args = [...execArgv\x2C modulePath\x2C ...args];\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\n  } else if (!ArrayIsArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\n    // and stderr from the parent if silent isn't set.\n    options.stdio = stdioStringToArray(\n      options.silent ? 'pipe' : 'inherit'\x2C\n      'ipc');\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\n  }\n\n  options.execPath = options.execPath || process.execPath;\n  options.shell = false;\n\n  return spawn(options.execPath\x2C args\x2C options);\n}\n\nfunction _forkChild(fd\x2C serializationMode) {\n  // set process.send()\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process\x2C p\x2C serializationMode);\n  process.on('newListener'\x2C function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.refCounted();\n  });\n  process.on('removeListener'\x2C function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\n  });\n}\n\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command\x2C\n    options: options\x2C\n    callback: callback\n  };\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction exec(command\x2C options\x2C callback) {\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\n  return module.exports.execFile(opts.file\x2C\n                                 opts.options\x2C\n                                 opts.callback);\n}\n\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\n\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout\x2C stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(exec)\n});\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction execFile(file /* \x2C args\x2C options\x2C callback */) {\n  let args = [];\n  let callback;\n  let options;\n\n  // Parse the optional positional parameters.\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\n    options = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\n    callback = arguments[pos++];\n  }\n\n  if (!callback && pos < arguments.length && arguments[pos] != null) {\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C arguments[pos]);\n  }\n\n  options = {\n    encoding: 'utf8'\x2C\n    timeout: 0\x2C\n    maxBuffer: MAX_BUFFER\x2C\n    killSignal: 'SIGTERM'\x2C\n    cwd: null\x2C\n    env: null\x2C\n    shell: false\x2C\n    ...options\n  };\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file\x2C args\x2C {\n    cwd: options.cwd\x2C\n    env: options.env\x2C\n    gid: options.gid\x2C\n    shell: options.shell\x2C\n    signal: options.signal\x2C\n    uid: options.uid\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exithandler(code\x2C signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding ||\n      (\n        child.stdout &&\n        child.stdout.readableEncoding\n      )) {\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding ||\n      (\n        child.stderr &&\n        child.stderr.readableEncoding\n      )) {\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null\x2C stdout\x2C stderr);\n      return;\n    }\n\n    if (args.length !== 0)\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\n\n    if (!ex) {\n      // eslint-disable-next-line no-restricted-syntax\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code < 0 ? getSystemErrorName(code) : code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex\x2C stdout\x2C stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }\x2C options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      const slice = encoding ? StringPrototypeSlice :\n        (buf\x2C ...args) => buf.slice(...args);\n      stdoutLen += length;\n\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout\x2C chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      stderrLen += length;\n\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr\x2C\n                           chunk.slice(0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\n        kill();\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener('close'\x2C exithandler);\n  child.addListener('error'\x2C errorhandler);\n\n  return child;\n}\n\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(execFile)\n});\n\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\n  validateString(file\x2C 'file');\n\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = {};\n  else\n    validateObject(options\x2C 'options');\n\n  let cwd = options.cwd;\n\n  // Validate the cwd\x2C if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\n  }\n\n  // Validate detached\x2C if present.\n  if (options.detached != null) {\n    validateBoolean(options.detached\x2C 'options.detached');\n  }\n\n  // Validate the uid\x2C if present.\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\n  }\n\n  // Validate the gid\x2C if present.\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\n  }\n\n  // Validate the shell\x2C if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\n                                   ['boolean'\x2C 'string']\x2C options.shell);\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n  }\n\n  // Validate windowsHide\x2C if present.\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\n  }\n\n  // Validate windowsVerbatimArguments\x2C if present.\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments\x2C\n                    'options.windowsVerbatimArguments');\n  }\n\n  if (options.shell) {\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\n    // Set the shell\x2C switches\x2C and commands.\n    if (process.platform === 'win32') {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else\n        file = process.env.comspec || 'cmd.exe';\n      // '/d /s /c' is used only for cmd.exe.\n      if (RegExpPrototypeTest(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file)) {\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = ['-c'\x2C command];\n      }\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c'\x2C command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    ArrayPrototypeUnshift(args\x2C options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args\x2C file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = [];\n\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\n  // collect coverage for programs that spawn with white-listed environment.\n  if (process.env.NODE_V8_COVERAGE &&\n      !ObjectPrototypeHasOwnProperty(options.env || {}\x2C 'NODE_V8_COVERAGE')) {\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\n  }\n\n  let envKeys = [];\n  // Prototype values are intentionally included.\n  for (const key in env) {\n    ArrayPrototypePush(envKeys\x2C key);\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\n    // keeping only the first one (in lexicographic order)\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(\n      ArrayPrototypeSort(envKeys)\x2C\n      (key) => {\n        const uppercaseKey = StringPrototypeToUpperCase(key);\n        if (sawKey.has(uppercaseKey)) {\n          return false;\n        }\n        sawKey.add(uppercaseKey);\n        return true;\n      }\n    );\n  }\n\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== undefined) {\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\n    }\n  }\n\n  return {\n    // Make a shallow copy so we don't clobber the user's options object.\n    ...options\x2C\n    args\x2C\n    cwd\x2C\n    detached: !!options.detached\x2C\n    envPairs\x2C\n    file\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\n  };\n}\n\nfunction abortChildProcess(child\x2C killSignal) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit('error'\x2C new AbortError());\n    }\n  } catch (err) {\n    child.emit('error'\x2C err);\n  }\n}\n\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction spawn(file\x2C args\x2C options) {\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug('spawn'\x2C options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit('error'\x2C err);\n        }\n        timeoutId = null;\n      }\n    }\x2C options.timeout);\n\n    child.once('exit'\x2C () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\n      child.once('exit'\x2C\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child\x2C killSignal);\n    }\n  }\n\n  return child;\n}\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nfunction spawnSync(file\x2C args\x2C options) {\n  options = {\n    maxBuffer: MAX_BUFFER\x2C\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\n  };\n\n  debug('spawnSync'\x2C options);\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  // Validate and translate the kill signal\x2C if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\n\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === 'string') {\n        pipe.input = Buffer.from(input\x2C options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\n                                       ['Buffer'\x2C\n                                        'TypedArray'\x2C\n                                        'DataView'\x2C\n                                        'string']\x2C\n                                       input);\n      }\n    }\n  }\n\n  return child_process.spawnSync(options);\n}\n\n\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n  } else if (ret.status !== 0) {\n    let msg = 'Command failed: ';\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    // eslint-disable-next-line no-restricted-syntax\n    err = new Error(msg);\n  }\n  if (err) {\n    ObjectAssign(err\x2C ret);\n  }\n  return err;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} command\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execFileSync(command\x2C args\x2C options) {\n  options = normalizeSpawnArguments(command\x2C args\x2C options);\n\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(options.file\x2C\n                        ArrayPrototypeSlice(options.args\x2C 1)\x2C options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C options.args\x2C undefined);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execSync(command\x2C options) {\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\n  const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file\x2C opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C opts.args\x2C command);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\n                               'a positive number'\x2C\n                               maxBuffer);\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\n                                   ['string'\x2C 'number']\x2C\n                                   killSignal);\n  }\n}\n\nmodule.exports = {\n  _forkChild\x2C\n  ChildProcess\x2C\n  exec\x2C\n  execFile\x2C\n  execFileSync\x2C\n  execSync\x2C\n  fork\x2C\n  spawn\x2C\n  spawnSync\n};\n
tick,0x7ff808957f54,141354,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff80896f1a0,141368,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808922ae6,141378,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-source-info,0x216c15954a76,95,0,24635,C0O0C4O24635,,
code-creation,Function,10,141411,0x216c159554e6,748, node:child_process:1:1,0x216c159549e0,~
code-source-info,0x216c159554e6,95,0,24635,C0O0C235O1159C241O1175C247O1199C253O1225C259O1247C265O1276C271O1298C277O1321C283O1343C289O1367C295O1392C301O1401C307O1420C313O1436C318O1460C324O1493C330O1516C336O1527C342O1551C348O1692C351O1692C356O1607C361O1620C367O1644C373O1669C379O1748C382O1748C387O1726C393O1792C396O1792C401O1825C414O1826C420O1792C422O1909C425O1909C430O1898C436O1971C439O1971C444O1936C450O1953C456O2049C459O2049C464O2012C470O2033C475O2087C481O2112C487O2146C493O2183C499O2207C505O2278C508O2278C513O2249C519O2263C525O2326C528O2326C533O2305C539O2457C542O2457C547O2366C553O2377C559O2400C565O2419C571O2437C577O2511C580O2511C584O2511C586O2628C589O2556C595O2573C601O2589C607O2605C613O2663C619O2663C621O6605C626O7009C636O7049C647O6972C652O12818C662O12858C673O12777C678O24506C688O24527C694O24541C700O24557C706O24565C712O24577C718O24593C724O24605C730O24613C736O24622C742O24521C747O24634,,
code-creation,LazyCompile,10,142064,0x216c15957ace,82,debuglog node:internal/util/debuglog:71:18,0x216c14574ff0,~
code-source-info,0x216c15957ace,40,2232,3279,C0O2232C28O2357C32O2357C34O2789C35O2789C37O2811C41O2811C43O2899C48O3128C58O3149C63O3174C74O3128C79O3263C81O3277,,
tick,0x7ff8088bfaba,142321,1,0x106d4ba80,6,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,Eval,10,143115,0x216c1595a886,5, node:internal/child_process:1:1,0x216c1595a188,~
script-source,96,node:internal/child_process,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototype\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\n    ERR_IPC_CHANNEL_CLOSED\x2C\n    ERR_IPC_DISCONNECTED\x2C\n    ERR_IPC_ONE_PIPE\x2C\n    ERR_IPC_SYNC_FORK\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst inspect = require('internal/util/inspect').inspect;\nconst assert = require('internal/assert');\n\nconst { Process } = internalBinding('process_wrap');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { TCP } = internalBinding('tcp_wrap');\nconst { TTY } = internalBinding('tty_wrap');\nconst { UDP } = internalBinding('udp_wrap');\nconst SocketList = require('internal/socket_list');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst spawn_sync = internalBinding('spawn_sync');\nconst { kStateSymbol } = require('internal/dgram');\n\nconst {\n  UV_EACCES\x2C\n  UV_EAGAIN\x2C\n  UV_EINVAL\x2C\n  UV_EMFILE\x2C\n  UV_ENFILE\x2C\n  UV_ENOENT\x2C\n  UV_ENOSYS\x2C\n  UV_ESRCH\n} = internalBinding('uv');\n\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\n\n// Lazy loaded for startup performance and to allow monkey patching of\n// internalBinding('http_parser').HTTPParser.\nlet freeParser;\nlet HTTPParser;\n\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol('kChannelHandle');\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\n\n// This object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'net.Server': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C server\x2C options) {\n      return server._handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const server = new net.Server();\n      server.listen(handle\x2C () => {\n        emit(server);\n      });\n    }\n  }\x2C\n\n  'net.Socket': {\n    send(message\x2C socket\x2C options) {\n      if (!socket._handle)\n        return;\n\n      // If the socket was created by net.Server\n      if (socket.server) {\n        // The worker should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\n\n        // The server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the workers\n        if (firstTime) socket.server._setupWorker(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      const handle = socket._handle;\n\n      // Remove handle from socket object\x2C it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n\n        if (freeParser === undefined)\n          freeParser = require('_http_common').freeParser;\n        if (HTTPParser === undefined)\n          HTTPParser = require('_http_common').HTTPParser;\n\n        // In case of an HTTP connection socket\x2C release the associated\n        // resources\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser\x2C null\x2C socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n\n      return handle;\n    }\x2C\n\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\n      // Store the handle after successfully sending it\x2C so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingMessage as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingMessage);\n          target._pendingMessage =\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new net.Socket({\n        handle: handle\x2C\n        readable: true\x2C\n        writable: true\n      });\n\n      // If the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // Add socket to connections list\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  }\x2C\n\n  'dgram.Native': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'dgram.Socket': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C socket\x2C options) {\n      message.dgramType = socket.type;\n\n      return socket[kStateSymbol].handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle\x2C () => {\n        emit(socket);\n      });\n    }\n  }\n};\n\nfunction stdioStringToArray(stdio\x2C channel) {\n  const options = [];\n\n  switch (stdio) {\n    case 'ignore':\n    case 'overlapped':\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  if (channel) ArrayPrototypePush(options\x2C channel);\n\n  return options;\n}\n\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onexit = (exitCode\x2C signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode\x2C syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\n      this.emit('error'\x2C err);\n    } else {\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched\x2C\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output\x2C if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio\x2C this);\n\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream\x2C e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe\x2C readable) {\n  return net.Socket({ handle: pipe\x2C readable\x2C writable: !readable });\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n\n  validateObject(options\x2C 'options');\n\n  // If no `stdio` option was given - use default\n  let stdio = options.stdio || 'pipe';\n\n  stdio = getValidStdio(stdio\x2C false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\n                [undefined\x2C 'json'\x2C 'advanced']);\n  const serialization = options.serialization || 'json';\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else if (!ArrayIsArray(options.envPairs)) {\n      throw new ERR_INVALID_ARG_TYPE('options.envPairs'\x2C\n                                     'Array'\x2C\n                                     options.envPairs);\n    }\n\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs\x2C\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\n  }\n\n  validateString(options.file\x2C 'options.file');\n  this.spawnfile = options.file;\n\n  if (options.args === undefined) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args\x2C 'options.args');\n    this.spawnargs = options.args;\n  }\n\n  const err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error\x2C not throw an exception.\n  if (err === UV_EACCES ||\n      err === UV_EAGAIN ||\n      err === UV_EMFILE ||\n      err === UV_ENFILE ||\n      err === UV_ENOENT) {\n    process.nextTick(onErrorNT\x2C this\x2C err);\n\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err\x2C 'spawn');\n  } else {\n    process.nextTick(onSpawnNT\x2C this);\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\n    // otherwise we might attempt to read from the stream when at the same time\n    // the child process does.\n    if (stream.type === 'wrap') {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n\n    if (stream.handle) {\n      // When i === 0 - we're dealing with stdin\n      // (which is the only one writable pipe).\n      stream.socket = createSocket(this.pid !== 0 ?\n        stream.handle : null\x2C i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close'\x2C () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n    stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n    stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n    stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio\x2C\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\n\n  return err;\n};\n\n\nfunction onErrorNT(self\x2C err) {\n  self._handle.onexit(err);\n}\n\n\nfunction onSpawnNT(self) {\n  self.emit('spawn');\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err\x2C 'kill');\n    } else {\n      /* Other error\x2C almost certainly EPERM. */\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n  }\n\n  // The methods keeping track of the counter are being used to track the\n  // listener count on the child process object as well as when writes are\n  // in progress. Once the user has explicitly requested a certain state\x2C these\n  // methods become no-ops in order to not interfere with the user's intentions.\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit('unref');\n    }\n  }\n\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n\n  get fd() {\n    return this.#channel ? this.#channel.fd : undefined;\n  }\n}\n\nconst channelDeprecationMsg = '_channel is deprecated. ' +\n                              'Use ChildProcess.channel instead.';\n\nlet serialization;\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\n    get: deprecate(() => {\n      return target.channel;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    set: deprecate((val) => {\n      target.channel = val;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n\n  target._handleQueue = null;\n  target._pendingMessage = null;\n\n  if (serialization === undefined)\n    serialization = require('internal/child_process/serialization');\n  const {\n    initMessageChannel\x2C\n    parseChannelMessages\x2C\n    writeChannelMessage\n  } = serialization[serializationMode];\n\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n\n      for (const message of parseChannelMessages(channel\x2C pool)) {\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (isInternal(message)) {\n          if (message.cmd === 'NODE_HANDLE') {\n            handleMessage(message\x2C pendingHandle\x2C true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message\x2C undefined\x2C true);\n          }\n        } else {\n          handleMessage(message\x2C undefined\x2C false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // Object where socket lists will live\n  channel.sockets = { got: {}\x2C send: {} };\n\n  // Handlers will go through this\n  target.on('internalMessage'\x2C function(message\x2C handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\n        message.cmd === 'NODE_HANDLE_NACK') {\n\n      if (target._pendingMessage) {\n        if (message.cmd === 'NODE_HANDLE_ACK') {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ ===\n                   MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning('Handle did not reach the receiving process ' +\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\n        }\n      }\n\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message\x2C\n                     target._pendingMessage.handle\x2C\n                     target._pendingMessage.options\x2C\n                     target._pendingMessage.callback);\n      }\n\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // It is possible that the handle is not received because of some error on\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\n    // sender about it by sending a NODE_HANDLE_NACK message.\n    if (!handle)\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\n\n    const obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle.setSimultaneousAccepts(false);\n    }\n\n    // Convert handle object\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\n    });\n  });\n\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined) {\n      validateObject(options\x2C 'options');\n    }\n\n    options = { swallowErrors: false\x2C ...options };\n\n    if (this.connected) {\n      return this._send(message\x2C handle\x2C options\x2C callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n    } else {\n      process.nextTick(() => this.emit('error'\x2C ex));\n    }\n    return false;\n  };\n\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new ERR_MISSING_ARGS('message');\n\n    // Non-serializable messages should not reach the remote\n    // end point; as any failure in the stringification there\n    // will result in error message that is weakly consumable.\n    // So perform a final check on message prior to sending.\n    if (typeof message !== 'string' &&\n        typeof message !== 'object' &&\n        typeof message !== 'number' &&\n        typeof message !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\n    }\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = { swallowErrors: options };\n    }\n\n    let obj;\n\n    // Package messages with a handle object\n    if (handle) {\n      // This message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE'\x2C\n        type: null\x2C\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue\x2C {\n          callback: callback\x2C\n          handle: handle\x2C\n          options: options\x2C\n          message: message.msg\x2C\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = ReflectApply(handleConversion[message.type].send\x2C\n                            target\x2C [message\x2C handle\x2C options]);\n\n      // If handle was sent twice\x2C or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue &&\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\n      // Queue request anyway to avoid out-of-order messages.\n      ArrayPrototypePush(this._handleQueue\x2C {\n        callback: callback\x2C\n        handle: null\x2C\n        options: options\x2C\n        message: message\x2C\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    const req = new WriteWrap();\n\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\n      }\n\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === 'function')\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === 'function') {\n        process.nextTick(callback\x2C null);\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err\x2C 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback\x2C ex);\n        } else {\n          process.nextTick(() => this.emit('error'\x2C ex));\n        }\n      }\n    }\n\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // Connected will be set to false immediately when a disconnect() is\n  // requested\x2C even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested\x2C messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested\x2C channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n    this[kChannelHandle] = null;\n\n    if (this._pendingMessage)\n      closePendingHandle(this);\n\n    let fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read\x2C then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message'\x2C finish);\n      this.once('internalMessage'\x2C finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  function emit(event\x2C message\x2C handle) {\n    target.emit(event\x2C message\x2C handle);\n  }\n\n  function handleMessage(message\x2C handle\x2C internal) {\n    if (!target.channel)\n      return;\n\n    const eventName = (internal ? 'internalMessage' : 'message');\n\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\n  }\n\n  channel.readStart();\n  return control;\n}\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction isInternal(message) {\n  return (message !== null &&\n          typeof message === 'object' &&\n          typeof message.cmd === 'string' &&\n          message.cmd.length > INTERNAL_PREFIX.length &&\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\n            INTERNAL_PREFIX);\n}\n\nconst nop = FunctionPrototype;\n\nfunction getValidStdio(stdio\x2C sync) {\n  let ipc;\n  let ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse\x2C and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See https://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\n    function cleanup() {\n      for (let i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\n               (typeof stdio === 'number' && stdio < 0)) {\n      const a = {\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\n        readable: i === 0\x2C\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n\n      ArrayPrototypePush(acc\x2C a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'pipe'\x2C\n        handle: ipc\x2C\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'inherit'\x2C\n        fd: i\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'fd'\x2C\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      const handle = getHandleWrapType(stdio) ?\n        stdio :\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'wrap'\x2C\n        wrapType: getHandleWrapType(handle)\x2C\n        handle: handle\x2C\n        _stdio: stdio\n      });\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n    }\n\n    return acc;\n  }\x2C []);\n\n  return { stdio\x2C ipc\x2C ipcFd };\n}\n\n\nfunction getSocketList(type\x2C worker\x2C key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker\x2C key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\n  }\n}\n\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  ChildProcess\x2C\n  kChannelHandle\x2C\n  setupChannel\x2C\n  getValidStdio\x2C\n  stdioStringToArray\x2C\n  spawnSync\n};\n
tick,0x106c71a8b,146547,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808957d9d,146562,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff8088ccc64,146577,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-source-info,0x216c1595a886,96,0,30948,C0O0C4O30948,,
code-creation,Function,10,146612,0x216c1595bea6,1253, node:internal/child_process:1:1,0x216c1595a7f0,~
code-source-info,0x216c1595bea6,96,0,30948,C0O0C293O25C299O41C305O63C311O87C317O110C322O131C328O156C334O180C339O204C345O220C351O244C356O254C362O564C368O564C373O294C384O325C390O351C396O378C402O407C408O440C414O468C420O494C426O516C432O539C438O674C444O674C449O602C455O619C461O637C467O654C473O727C479O727C483O727C485O758C491O758C495O758C497O788C503O788C507O788C509O822C515O822C520O854C524O822C526O879C532O879C536O879C538O928C541O928C546O916C552O1069C555O1069C560O971C566O984C572O1005C578O1027C584O1049C590O1144C593O1144C598O1109C604O1126C610O1190C613O1190C618O1182C624O1235C627O1235C632O1227C638O1280C641O1280C646O1272C652O1328C658O1328C663O1386C669O1386C674O1417C679O1369C685O1471C691O1471C696O1435C702O1457C708O1527C714O1527C719O1505C725O1578C728O1578C732O1578C734O1634C740O1634C745O1617C751O1776C754O1776C759O1672C765O1685C771O1698C777O1711C783O1724C789O1737C795O1750C801O1763C807O1808C813O1824C819O1980C820O1980C822O1996C823O1996C825O2044C827O2044C829O2070C832O2070C836O2070C838O2119C841O2119C845O2119C847O2270C852O2288C857O2326C865O2392C879O2469C884O2507C892O2581C906O2745C911O2751C919O4312C927O5065C941O5545C946O5584C954O5650C968O5729C973O5768C981O5895C997O2270C999O7893C1007O7917C1012O7859C1017O7929C1020O7929C1025O8936C1034O8952C1038O12897C1047O12912C1051O13596C1060O13610C1064O13683C1073O13699C1125O13782C1181O13760C1183O14756C1188O14783C1191O14756C1193O14857C1194O14857C1196O26358C1198O26358C1200O26691C1202O26691C1204O30825C1211O30846C1217O30862C1223O30880C1229O30896C1235O30913C1241O30935C1247O30840C1252O30947,,
code-creation,Function,10,146762,0x216c1595c61e,35,<instance_members_initializer> node:internal/child_process:527:3,0x216c1595b560,~
code-source-info,0x216c1595c61e,96,13799,13856,C3O13810C16O13826C26O13851C34O13856,,
tick,0x1076b656e,146994,0,0x0,0,0x216c1595c016,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,Eval,10,148213,0x216c159607f6,5, node:net:1:1,0x216c15960008,~
script-source,97,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  Boolean\x2C\n  Error\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  uvExceptionWithHostPort\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kSetNoDelay] = false;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        value: 0\x2C writable: true\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\n        self._readableState);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  const er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect'\x2C\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n\n  // Backwards compatibility: assume true when `enable` is omitted\n  const newValue = enable === undefined ? true : !!enable;\n  if (this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = newValue;\n    this._handle.setNoDelay(newValue);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting\x2C msecs) {\n  if (!this._handle) {\n    this.once('connect'\x2C () => this.setKeepAlive(setting\x2C msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting\x2C ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  get: function() {\n    return this.connecting;\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close'\x2C isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    this._peername = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getpeername(this._peername);\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: options.family\x2C\n    hints: options.hints || 0\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n  };\n\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C pipeName\x2C -1\x2C -1\x2C\n                    backlog\x2C undefined\x2C options.exclusive);\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0x216c159607f6,97,0,47197,C0O0C4O47197,,
code-creation,Function,10,152780,0x216c159636d6,2513, node:net:1:1,0x216c15960760,~
code-source-info,0x216c159636d6,97,0,47197,C0O0C411O1159C417O1175C423O1200C429O1211C435O1220C441O1230C447O1245C453O1263C459O1287C464O1311C469O1358C475O1358C479O1358C481O1392C487O1392C491O1392C493O1423C499O1423C504O1456C518O1457C524O1423C526O1581C532O1581C537O1511C543O1519C548O1529C553O1539C559O1563C565O1621C571O1621C575O1621C577O1705C580O1705C585O1659C591O1676C597O1689C603O1748C609O1748C614O1737C620O1795C623O1795C628O1775C634O1845C637O1845C642O1828C648O1940C651O1940C656O1887C662O1894C668O1923C674O2035C677O2035C682O1979C688O1987C694O2017C700O2166C706O2166C711O2075C717O2089C728O2130C734O2147C740O2364C746O2364C751O2209C757O2226C763O2242C769O2258C774O2278C780O2289C785O2305C790O2325C796O2336C802O2349C808O2744C814O2744C819O2744C824O2428C830O2460C836O2486C842O2513C848O2538C854O2566C860O2597C866O2625C872O2648C878O2673C884O2691C890O2716C896O2797C902O2797C907O2780C913O2952C919O2952C924O2839C930O2862C936O2882C942O2899C948O2917C954O2933C960O3012C963O3012C967O3012C969O3110C975O3110C980O3052C986O3084C992O3190C993O3190C995O3203C996O3203C998O3212C999O3212C1001O3227C1002O3227C1004O3268C1010O3268C1015O3251C1021O3308C1027O3308C1032O3295C1038O3363C1040O3363C1042O3400C1044O3400C1046O3425C1049O3433C1056O3442C1059O3425C1061O3469C1065O3469C1067O6921C1070O6921C1074O6921C1076O6965C1079O6965C1083O6965C1085O7010C1088O7010C1092O7010C1094O10628C1097O10656C1105O10674C1110O10681C1115O10628C1120O10693C1126O10729C1131O10693C1136O10769C1139O10776C1148O10798C1152O11024C1155O11031C1164O11048C1168O12594C1171O12601C1178O12622C1182O12644C1185O12651C1194O12672C1198O13182C1201O13189C1210O13210C1214O13665C1217O13672C1226O13695C1230O13948C1233O13955C1242O13973C1246O14023C1252O14051C1266O14086C1274O14023C1279O14136C1285O14164C1299O14190C1307O14136C1312O14275C1318O14303C1332O14337C1340O14275C1345O14659C1351O14687C1365O14721C1373O14659C1378O14807C1384O14835C1389O14846C1395O14869C1406O14807C1411O15234C1414O15241C1423O15257C1427O15492C1430O15499C1439O15513C1443O15706C1446O15713C1455O15729C1459O16069C1462O16076C1471O16093C1475O16283C1478O16290C1487O16305C1491O16642C1494O16649C1503O16671C1507O16824C1510O16831C1519O16850C1523O17809C1526O17816C1535O17839C1539O18300C1547O18300C1552O18420C1560O18420C1565O18519C1573O18519C1578O18615C1586O18615C1596O18706C1599O18713C1608O18736C1616O19018C1624O19018C1634O19116C1642O19116C1652O19205C1655O19212C1660O19222C1664O19240C1672O19292C1675O19299C1684O19323C1692O20090C1695O20097C1704O20115C1712O20189C1715O20196C1724O20213C1732O20457C1740O20457C1750O20597C1758O20597C1768O24069C1771O24076C1780O24094C1788O28495C1791O28502C1800O28516C1808O28709C1811O28716C1820O28732C1828O31467C1831O31495C1843O31519C1852O31467C1862O31531C1868O31531C1878O35517C1881O35524C1892O35543C1900O36991C1903O36998C1916O37015C1924O40972C1930O41000C1951O41033C1963O40972C1973O41124C1976O41131C1989O41149C1997O42219C2000O42226C2013O42251C2021O43010C2024O43017C2037O43033C2045O43905C2048O43912C2061O43942C2069O44420C2072O44427C2084O44450C2097O44474C2105O44792C2111O44817C2132O44841C2144O44881C2156O44792C2166O44928C2172O44956C2189O44982C2201O45017C2213O44928C2223O45059C2226O45066C2239O45089C2247O45335C2250O45342C2263O45356C2271O45459C2274O45466C2287O45482C2295O45590C2297O45645C2298O45645C2300O45652C2311O45675C2312O45675C2314O45699C2323O46407C2328O46679C2338O46721C2348O46759C2358O46776C2368O47035C2378O47064C2388O47075C2398O47097C2408O47113C2418O47131C2428O47141C2438O47151C2448O47169C2503O46694C2512O47196,,
tick,0x7ff808922ae6,153053,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808957d23,153079,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808957d1e,153093,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808957f70,153106,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808779478,153146,1,0x106d4ba80,6,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,Eval,10,153527,0x216c15968e4e,5, node:internal/net:1:1,0x216c15968c78,~
script-source,98,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n
code-source-info,0x216c15968e4e,98,0,1749,C0O0C4O1749,,
code-creation,Function,10,153746,0x216c1596924e,617, node:internal/net:1:1,0x216c15968db8,~
code-source-info,0x216c1596924e,98,0,1749,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O1633C576O1654C582O1662C588O1672C594O1682C601O1721C611O1648C616O1748,,
code-creation,Eval,10,154147,0x216c1596aa26,5, node:internal/dtrace:1:1,0x216c1596a8d0,~
script-source,99,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n};\n
code-source-info,0x216c1596aa26,99,0,568,C0O0C4O568,,
code-creation,Function,10,154240,0x216c1596af0e,140, node:internal/dtrace:1:1,0x216c1596a990,~
code-source-info,0x216c1596af0e,99,0,568,C0O30C3O30C8O322C17O334C25O68C36O109C47O151C58O192C69O234C80O277C91O368C98O389C104O419C110O450C116O480C122O511C128O543C134O383C139O567,,
tick,0x106eb393e,154421,0,0x0,2,0x10739e050,0x216c15963ce1,0x216c7df79cad,0x216c7df78f7d,0x216c1595c091,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,LazyCompile,10,154523,0x216c1596be46,34,protoGetter node:net:703:21,0x216c15960c38,~
code-source-info,0x216c1596be46,97,18158,18298,C0O18179C8O18207C13O18218C20O18282C27O18179C33O18297,,
code-creation,Eval,10,155337,0x216c15971116,5, node:dgram:1:1,0x216c15970ba0,~
script-source,100,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n} = require('internal/dgram');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MISSING_ARGS\x2C\n  ERR_SOCKET_ALREADY_BOUND\x2C\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\n  ERR_SOCKET_BUFFER_SIZE\x2C\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\n  ERR_INVALID_FD_TYPE\n} = errors.codes;\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateString\x2C\n  validateNumber\x2C\n  validatePort\x2C\n} = require('internal/validators');\nconst { Buffer } = require('buffer');\nconst { deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst EventEmitter = require('events');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n\nconst {\n  constants: { UV_UDP_IPV6ONLY }\x2C\n  UDP\x2C\n  SendWrap\n} = internalBinding('udp_wrap');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\n\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\n\n// Lazily loaded\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster) _cluster = require('cluster');\n  return _cluster;\n}\n\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\n\n\nfunction Socket(type\x2C listener) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n\n  let options;\n  if (type !== null && typeof type === 'object') {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n\n  const handle = newHandle(type\x2C lookup);\n  handle[owner_symbol] = this;\n\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n\n  if (typeof listener === 'function')\n    this.on('message'\x2C listener);\n\n  this[kStateSymbol] = {\n    handle\x2C\n    receiving: false\x2C\n    bindState: BIND_STATE_UNBOUND\x2C\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\n    queue: undefined\x2C\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\n    ipv6Only: options && options.ipv6Only\x2C\n    recvBufferSize\x2C\n    sendBufferSize\n  };\n\n  if (options?.signal !== undefined) {\n    const { signal } = options;\n    validateAbortSignal(signal\x2C 'options.signal');\n    const onAborted = () => {\n      this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener('abort'\x2C onAborted);\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n}\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\n\n\nfunction createSocket(type\x2C listener) {\n  return new Socket(type\x2C listener);\n}\n\n\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n\n  state.handle.onmessage = onMessage;\n  // Todo: handle errors\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n\n  if (state.recvBufferSize)\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\n\n  if (state.sendBufferSize)\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self\x2C newHandle) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n\n  // Set up the handle that we got from primary.\n  newHandle.lookup = oldHandle.lookup;\n  newHandle.bind = oldHandle.bind;\n  newHandle.send = oldHandle.send;\n  newHandle[owner_symbol] = self;\n\n  // Replace the existing handle by the handle we got from primary.\n  oldHandle.close();\n  state.handle = newHandle;\n  // Check if the udp handle was connected and set the state accordingly\n  if (isConnected(self))\n    state.connectState = CONNECT_STATE_CONNECTED;\n}\n\nfunction bufferSize(self\x2C size\x2C buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\n  if (ret === undefined) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\n\n// Query primary process to get the server handle and utilize it.\nfunction bindServerHandle(self\x2C options\x2C errCb) {\n  const cluster = lazyLoadCluster();\n\n  const state = self[kStateSymbol];\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n\n    if (!state.handle) {\n      // Handle has been closed in the mean time.\n      return handle.close();\n    }\n\n    replaceHandle(self\x2C handle);\n    startListening(self);\n  });\n}\n\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\n  let port = port_;\n\n  healthCheck(this);\n  const state = this[kStateSymbol];\n\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n\n  state.bindState = BIND_STATE_BINDING;\n\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === 'function') {\n    function removeListeners() {\n      this.removeListener('error'\x2C removeListeners);\n      this.removeListener('listening'\x2C onListening);\n    }\n\n    function onListening() {\n      FunctionPrototypeCall(removeListeners\x2C this);\n      FunctionPrototypeCall(cb\x2C this);\n    }\n\n    this.on('error'\x2C removeListeners);\n    this.on('listening'\x2C onListening);\n  }\n\n  if (port !== null &&\n      typeof port === 'object' &&\n      typeof port.recvStart === 'function') {\n    replaceHandle(this\x2C port);\n    startListening(this);\n    return this;\n  }\n\n  // Open an existing fd instead of creating a new one.\n  if (port !== null && typeof port === 'object' &&\n      isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive = !!port.exclusive;\n    const state = this[kStateSymbol];\n\n    const cluster = lazyLoadCluster();\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: null\x2C\n        port: null\x2C\n        addressType: this.type\x2C\n        fd\x2C\n        flags: null\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = errnoException(err\x2C 'open');\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n      return this;\n    }\n\n    const type = guessHandleType(fd);\n    if (type !== 'UDP')\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state.handle.open(fd);\n\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    // Check if the udp handle was connected and set the state accordingly\n    if (isConnected(this))\n      state.connectState = CONNECT_STATE_CONNECTED;\n\n    startListening(this);\n    return this;\n  }\n\n  let address;\n  let exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // Defaulting address for bind to all interfaces\n  if (!address) {\n    if (this.type === 'udp4')\n      address = '0.0.0.0';\n    else\n      address = '::';\n  }\n\n  // Resolve address first\n  state.handle.lookup(address\x2C (err\x2C ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit('error'\x2C err);\n      return;\n    }\n\n    const cluster = lazyLoadCluster();\n\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: ip\x2C\n        port: port\x2C\n        addressType: this.type\x2C\n        fd: -1\x2C\n        flags: flags\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n    } else {\n      if (!state.handle)\n        return; // Handle has been closed in the mean time\n\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\n      if (err) {\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\n  port = validatePort(port\x2C 'Port'\x2C { allowZero: false });\n  if (typeof address === 'function') {\n    callback = address;\n    address = '';\n  } else if (address === undefined) {\n    address = '';\n  }\n\n  validateString(address\x2C 'address');\n\n  const state = this[kStateSymbol];\n\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\n                                        port\x2C address\x2C callback));\n    return;\n  }\n\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\n};\n\n\nfunction _connect(port\x2C address\x2C callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once('connect'\x2C callback);\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doConnect\x2C\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\n    );\n  };\n\n  state.handle.lookup(address\x2C afterDns);\n}\n\n\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n\n  if (!ex) {\n    const err = state.handle.connect(ip\x2C port);\n    if (err) {\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\n    }\n  }\n\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener('connect'\x2C callback);\n        callback(ex);\n      } else {\n        self.emit('error'\x2C ex);\n      }\n    });\n  }\n\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit('connect'));\n}\n\n\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err\x2C 'connect');\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\n\n\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer\x2C\n                                   offset\x2C\n                                   length\x2C\n                                   port\x2C\n                                   address\x2C\n                                   callback) {\n  validateNumber(offset\x2C 'offset');\n  validateNumber(length\x2C 'length');\n  validateNumber(port\x2C 'port');\n  validateString(address\x2C 'address');\n\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\n};\n\n\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (let i = 0\x2C l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self\x2C toEnqueue) {\n  const state = self[kStateSymbol];\n\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\n  // event handler that flushes the send queue after binding is done.\n  if (state.queue === undefined) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\n    self.once('listening'\x2C onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\n  FunctionPrototypeCall(clearQueue\x2C this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening'\x2C onListenSuccess);\n  this[kStateSymbol].queue = undefined;\n}\n\n\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = undefined;\n\n  // Flush the send queue.\n  for (const queueEntry of queue)\n    queueEntry();\n}\n\nfunction isConnected(self) {\n  try {\n    self.remoteAddress();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n\n// valid combinations\n// For connectionless sockets\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port)\n// send(bufferOrList\x2C port\x2C address\x2C callback)\n// send(bufferOrList\x2C port\x2C address)\n// send(bufferOrList\x2C port\x2C callback)\n// send(bufferOrList\x2C port)\n// For connected sockets\n// send(buffer\x2C offset\x2C length\x2C callback)\n// send(buffer\x2C offset\x2C length)\n// send(bufferOrList\x2C callback)\n// send(bufferOrList)\nSocket.prototype.send = function(buffer\x2C\n                                 offset\x2C\n                                 length\x2C\n                                 port\x2C\n                                 address\x2C\n                                 callback) {\n\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || (port && typeof port !== 'function')) {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === 'number') {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n      if (typeof port === 'function') {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                     ['Buffer'\x2C\n                                      'TypedArray'\x2C\n                                      'DataView'\x2C\n                                      'string']\x2C\n                                     buffer);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  if (!connected)\n    port = validatePort(port\x2C 'Port'\x2C { allowZero: false });\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address && typeof address !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('address'\x2C ['string'\x2C 'falsy']\x2C address);\n  }\n\n  healthCheck(this);\n\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (list.length === 0)\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\n                                        list\x2C port\x2C address\x2C callback));\n    return;\n  }\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doSend\x2C\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\n    );\n  };\n\n  if (!connected) {\n    state.handle.lookup(address\x2C afterDns);\n  } else {\n    afterDns(null\x2C null);\n  }\n};\n\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n\n  if (ex) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n      return;\n    }\n\n    process.nextTick(() => self.emit('error'\x2C ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n\n  const req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n\n  let err;\n  if (port)\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\n  else\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\n\n  if (err >= 1) {\n    // Synchronous finish. The return code is msg_length + 1 so that we can\n    // distinguish between synchronous success and asynchronous success.\n    if (callback)\n      process.nextTick(callback\x2C null\x2C err - 1);\n    return;\n  }\n\n  if (err && callback) {\n    // Don't emit as error\x2C dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\n    process.nextTick(callback\x2C ex);\n  }\n}\n\nfunction afterSend(err\x2C sent) {\n  if (err) {\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err\x2C sent);\n}\n\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n\n  if (typeof callback === 'function')\n    this.on('close'\x2C callback);\n\n  if (queue !== undefined) {\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\n    return this;\n  }\n\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             socketCloseNT\x2C\n                             this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  healthCheck(this);\n\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err\x2C 'getsockname');\n  }\n\n  return out;\n};\n\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err\x2C 'getpeername');\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress\x2C 'interfaceAddress');\n\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastInterface');\n  }\n};\n\nSocket.prototype.addMembership = function(multicastAddress\x2C\n                                          interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress\x2C\n                                           interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropMembership');\n  }\n};\n\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\n                                                        groupAddress\x2C\n                                                        interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\n                                                          groupAddress\x2C\n                                                          interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\n  }\n};\n\n\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\n                                                         groupAddress\x2C\n                                                         interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\n                                                           groupAddress\x2C\n                                                           interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\n  }\n};\n\n\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    // Error message from dgram_legacy.js.\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\n\n\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n\n  if (!state.receiving)\n    return;\n\n  state.handle.recvStop();\n  state.receiving = false;\n}\n\n\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message'\x2C buf\x2C rinfo);\n}\n\n\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.unref();\n\n  return this;\n};\n\n\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\n};\n\n\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\n};\n\n\n// Deprecated private APIs.\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\n});\n\n\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\n\n\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\n\nmodule.exports = {\n  _createSocketHandle: deprecate(\n    _createSocketHandle\x2C\n    'dgram._createSocketHandle() is deprecated'\x2C\n    'DEP0112'\n  )\x2C\n  createSocket\x2C\n  Socket\n};\n
code-source-info,0x216c15971116,100,0,27515,C0O0C4O27515,,
code-creation,Function,10,158260,0x216c15973086,1498, node:dgram:1:1,0x216c15971080,~
code-source-info,0x216c15973086,100,0,27515,C0O0C273O1159C279O1168C285O1184C291O1206C297O1231C303O1256C308O1280C313O1304C319O1351C325O1351C330O1443C336O1443C341O1389C347O1405C352O1428C358O1498C361O1498C366O1478C372O1791C377O1533C383O1557C389O1577C395O1605C401O1635C407O1661C413O1694C419O1728C425O1760C431O1896C437O1896C442O1808C448O1819C454O1842C460O1860C466O1878C472O1947C478O1947C483O1936C489O1988C495O1988C500O1974C505O2044C511O2044C516O2022C522O2097C528O2097C532O2097C534O2203C540O2203C545O2126C556O2167C562O2184C568O2265C571O2265C576O2293C581O2244C587O2363C590O2363C595O2363C600O2322C606O2343C611O2350C617O2420C618O2420C620O2450C622O2450C624O2478C626O2478C628O2517C629O2517C631O2553C633O2553C635O2588C637O2588C639O2612C640O2612C642O2638C643O2638C645O2678C646O2678C648O2813C652O2806C654O2866C658O2859C660O4187C663O4215C671O4239C676O4187C681O4251C687O4251C692O6160C695O6167C704O6182C708O9783C711O9790C720O9808C724O11618C727O11625C736O11646C740O12034C743O12041C752O12058C756O15025C759O15032C768O15047C772O19339C775O19346C784O19362C788O19993C791O20000C800O20018C804O20213C807O20220C816O20244C820O20560C823O20567C832O20590C836O20744C839O20751C848O20768C852O20948C855O20955C864O20981C868O21179C871O21186C880O21217C884O21423C887O21430C896O21462C900O21729C903O21736C912O21760C916O22140C919O22147C928O22172C932O22554C935O22561C944O22599C948O23212C951O23219C960O23258C964O24467C967O24474C976O24488C980O24601C983O24608C992O24624C996O24739C999O24746C1008O24774C1012O24837C1015O24844C1024O24872C1028O24935C1031O24942C1040O24970C1044O25033C1047O25040C1056O25068C1060O25159C1063O25187C1076O25218C1087O25218C1096O25345C1107O25345C1116O25159C1121O25472C1124O25500C1137O25534C1148O25534C1157O25667C1168O25667C1177O25472C1182O25800C1185O25828C1198O25862C1209O25862C1218O25995C1229O25995C1238O25800C1243O26128C1246O26156C1259O26186C1270O26186C1279O26311C1290O26311C1299O26128C1304O26436C1307O26464C1320O26498C1331O26498C1340O26631C1351O26631C1360O26436C1365O26764C1368O26771C1373O26796C1384O26796C1389O26794C1393O26906C1396O26913C1401O26940C1412O26940C1417O26938C1421O27229C1434O27253C1442O27293C1450O27204C1455O27341C1469O27383C1480O27489C1486O27505C1492O27356C1497O27514,,
tick,0x106c71890,158442,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c09d,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff80896f243,158466,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c09d,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
tick,0x7ff808957d23,158479,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c09d,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,Eval,10,158756,0x216c159764fe,5, node:internal/dgram:1:1,0x216c159762e8,~
script-source,101,node:internal/dgram,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\nconst { UDP } = internalBinding('udp_wrap');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  isInt32\x2C\n  validateFunction\x2C\n} = require('internal/validators');\nconst { UV_EINVAL } = internalBinding('uv');\nconst {\n  ERR_SOCKET_BAD_TYPE\x2C\n} = codes;\nconst kStateSymbol = Symbol('state symbol');\nlet dns;  // Lazy load for startup performance.\n\n\nfunction lookup4(lookup\x2C address\x2C callback) {\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\n}\n\n\nfunction lookup6(lookup\x2C address\x2C callback) {\n  return lookup(address || '::1'\x2C 6\x2C callback);\n}\n\nfunction newHandle(type\x2C lookup) {\n  if (lookup === undefined) {\n    if (dns === undefined) {\n      dns = require('dns');\n    }\n\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup\x2C 'lookup');\n  }\n\n  if (type === 'udp4') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new ERR_SOCKET_BAD_TYPE();\n}\n\n\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  const handle = newHandle(addressType);\n  let err;\n\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== 'UDP') {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address\x2C port || 0\x2C flags);\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\n\nmodule.exports = {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\n};\n
code-source-info,0x216c159764fe,101,0,1849,C0O0C4O1849,,
code-creation,Function,10,159007,0x216c159767d6,196, node:internal/dgram:1:1,0x216c15976468,~
code-source-info,0x216c159767d6,101,0,1849,C0O0C56O25C62O50C67O94C73O94C78O84C83O138C86O138C91O130C97O195C100O195C105O175C111O263C117O263C122O230C128O241C134O317C137O317C142O303C148O350C154O403C157O403C162O431C163O431C165O1776C172O1797C178O1813C184O1836C190O1791C195O1848,,
tick,0x7ff808957f70,159077,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c159731d6,0x216c7df79cad,0x216c7df78f7d,0x216c1595c09d,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,LazyCompile,10,159419,0x216c15978ebe,126,deprecate node:internal/util:81:19,0x216c014e9498,~
script-source,12,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  if (code !== undefined && typeof code !== 'string')\n    throw new ERR_INVALID_ARG_TYPE('code'\x2C 'string'\x2C code);\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nfunction promisify(original) {\n  if (typeof original !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('original'\x2C 'Function'\x2C original);\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('util.promisify.custom'\x2C 'Function'\x2C fn);\n    }\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet DOMException;\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  if (DOMException === undefined)\n    DOMException = internalBinding('messaging').DOMException;\n  return new DOMException(message\x2C name);\n});\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\n};\n
code-source-info,0x216c15978ebe,12,1940,3027,C0O1940C26O1960C31O1972C37O1986C42O2002C44O2012C45O2020C55O2076C73O2082C78O2076C79O2148C80O2148C82O2723C95O2723C100O2763C103O2770C109O2963C115O2989C119O2984C123O3007C125O3025,,
tick,0x7ff808957ed9,160853,0,0x0,3,0x10739e050,0x216c159734c5,0x216c7df79cad,0x216c7df78f7d,0x216c1595c09d,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,Eval,10,161169,0x216c1597b456,5, node:internal/socket_list:1:1,0x216c1597b2f0,~
script-source,102,node:internal/socket_list,'use strict';\n\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\n\nconst EventEmitter = require('events');\n\n// This object keeps track of the sockets that are sent\nclass SocketListSend extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\n  }\n\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\n    const self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\n\n    function onclose() {\n      self.child.removeListener('internalMessage'\x2C onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect'\x2C onclose);\n      self.child.removeListener('internalMessage'\x2C onreply);\n\n      callback(null\x2C msg);\n    }\n\n    this.child.once('disconnect'\x2C onclose);\n    this.child.on('internalMessage'\x2C onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\n      if (err) return callback(err);\n      callback(null\x2C msg.count);\n    });\n  }\n}\n\n\n// This object keeps track of the sockets that are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child._send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\n        key: self.key\n      }\x2C undefined\x2C true);\n    }\n\n    this.child.on('internalMessage'\x2C (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty'\x2C onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child._send({\n          cmd: 'NODE_SOCKET_COUNT'\x2C\n          key: this.key\x2C\n          count: this.connections\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify the previous owner of the socket about its state change\n    obj.socket.once('close'\x2C () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty'\x2C this);\n    });\n  }\n}\n\nmodule.exports = { SocketListSend\x2C SocketListReceive };\n
code-source-info,0x216c1597b456,102,0,2705,C0O0C4O2705,,
code-creation,Function,10,161485,0x216c1597baa6,126, node:internal/socket_list:1:1,0x216c1597b3c0,~
code-source-info,0x216c1597baa6,102,0,2705,C0O0C8O57C11O57C16O83C21O23C27O113C30O113C35O218C73O1525C101O2649C108O2668C114O2684C120O2664C125O2704,,
tick,0x7ff808957d92,161529,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c1595c138,0x216c7df79cad,0x216c7df78f7d,0x216c1595572a,0x216c7df79cad,0x216c7df78f7d,0x216c15953a82,0x216c7df7df3e,0x216c7df78cf5
code-creation,LazyCompile,10,161767,0x216c1597c5c6,14,customPromiseExecFunction node:child_process:231:35,0x216c15955058,~
code-source-info,0x216c1597c5c6,95,6605,6969,C0O6605C9O6619C13O6967,,
code-creation,LazyCompile,10,161886,0x216c1597e5de,129,_forkChild node:child_process:170:20,0x216c15954af8,~
code-source-info,0x216c1597e5de,95,4921,5391,C0O4921C8O4983C19O4992C22O5006C29O4983C35O5016C40O5016C45O5030C50O5030C54O5057C72O5057C77O5057C79O5104C84O5112C97O5112C103O5244C108O5252C121O5252C128O5390,,
new,MemoryChunk,0x216c44000000,262144
code-creation,LazyCompile,10,162333,0x216c1597ef8e,374,setupChannel node:internal/child_process:572:22,0x216c1595ab38,~
code-source-info,0x216c1597ef8e,96,14893,26332,C0O14893C37O14950C49O14950C54O14950C56O14974C61O14989C65O15002C72O15009C77O15025C81O15039C94O15060C103O15091C115O15145C121O15091C134O15189C146O15245C152O15189C161O15039C166O15335C170O15355C174O15365C178O15388C182O15399C190O15436C198O15452C207O15450C215O15591C224O15604C228O15515C233O15539C239O15565C245O15648C246O15648C248O15656C251O15656C255O15687C259O15709C263O15719C270O15734C274O16961C281O16977C285O17040C288O17047C301O17047C307O19416C314O19428C318O20155C325O20168C329O24862C333O24879C337O24890C344O24908C348O25339C355O25358C359O26292C362O26300C367O26300C371O26315C373O26330,,
code-creation,LazyCompile,10,162426,0x216c4400359e,56,Control node:internal/child_process:531:14,0x216c1595b368,~
code-source-info,0x216c4400359e,96,13872,13929,C3O13888C11O13888C40O13901C48O13915C55O13928,,
code-creation,LazyCompile,10,162480,0x216c440036ce,21,EventEmitter node:events:87:22,0x216c014f1350,~
code-source-info,0x216c440036ce,13,2482,2530,C0O2493C3O2506C8O2511C13O2511C20O2529,,
tick,0x10730c358,162556,0,0x0,3,0x10739e050,0x216c440036db,0x216c440035a9,0x216c1597efbf,0x216c1597e626,0x216c15953a8c,0x216c7df7df3e,0x216c7df78cf5
code-creation,LazyCompile,10,162591,0x216c44003826,149,EventEmitter.init node:events:197:29,0x216c014f2048,~
code-source-info,0x216c44003826,13,5582,6171,C0O5603C6O5639C13O5651C16O5651C21O5677C25O5647C30O5693C32O5708C37O5708C41O5706C45O5732C46O5750C50O5788C60O5781C64O5820C71O5828C80O5855C85O5876C93O5855C98O5929C100O5934C105O5946C108O5959C113O5946C117O5944C123O6115C125O6120C131O6145C138O6155C140O6154C143O6130C148O6170,,
code-creation,Eval,10,162906,0x216c440040be,5, node:internal/child_process/serialization:1:1,0x216c44003dc8,~
script-source,103,node:internal/child_process/serialization,'use strict';\n\nconst {\n  JSONParse\x2C\n  JSONStringify\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\nconst { Buffer } = require('buffer');\nconst { StringDecoder } = require('string_decoder');\nconst v8 = require('v8');\nconst { isArrayBufferView } = require('internal/util/types');\nconst assert = require('internal/assert');\nconst { streamBaseState\x2C kLastWriteWasAsync } = internalBinding('stream_wrap');\n\nconst kMessageBuffer = Symbol('kMessageBuffer');\nconst kJSONBuffer = Symbol('kJSONBuffer');\nconst kStringDecoder = Symbol('kStringDecoder');\n\n// Extend V8's serializer APIs to give more JSON-like behaviour in\n// some cases; in particular\x2C for native objects this serializes them the same\n// way that JSON does rather than throwing an exception.\nconst kArrayBufferViewTag = 0;\nconst kNotArrayBufferViewTag = 1;\nclass ChildProcessSerializer extends v8.DefaultSerializer {\n  _writeHostObject(object) {\n    if (isArrayBufferView(object)) {\n      this.writeUint32(kArrayBufferViewTag);\n      return super._writeHostObject(object);\n    }\n    this.writeUint32(kNotArrayBufferViewTag);\n    this.writeValue({ ...object });\n  }\n}\n\nclass ChildProcessDeserializer extends v8.DefaultDeserializer {\n  _readHostObject() {\n    const tag = this.readUint32();\n    if (tag === kArrayBufferViewTag)\n      return super._readHostObject();\n\n    assert(tag === kNotArrayBufferViewTag);\n    return this.readValue();\n  }\n}\n\n// Messages are parsed in either of the following formats:\n// - Newline-delimited JSON\x2C or\n// - V8-serialized buffers\x2C prefixed with their length as a big endian uint32\n//   (aka 'advanced')\nconst advanced = {\n  initMessageChannel(channel) {\n    channel[kMessageBuffer] = Buffer.alloc(0);\n    channel.buffering = false;\n  }\x2C\n\n  *parseChannelMessages(channel\x2C readData) {\n    if (readData.length === 0) return;\n\n    let messageBuffer = Buffer.concat([channel[kMessageBuffer]\x2C readData]);\n    while (messageBuffer.length > 4) {\n      const size = messageBuffer.readUInt32BE();\n      if (messageBuffer.length < 4 + size) {\n        break;\n      }\n\n      const deserializer = new ChildProcessDeserializer(\n        TypedArrayPrototypeSubarray(messageBuffer\x2C 4\x2C 4 + size));\n      messageBuffer = TypedArrayPrototypeSubarray(messageBuffer\x2C 4 + size);\n\n      deserializer.readHeader();\n      yield deserializer.readValue();\n    }\n    channel[kMessageBuffer] = messageBuffer;\n    channel.buffering = messageBuffer.length > 0;\n  }\x2C\n\n  writeChannelMessage(channel\x2C req\x2C message\x2C handle) {\n    const ser = new ChildProcessSerializer();\n    ser.writeHeader();\n    ser.writeValue(message);\n    const serializedMessage = ser.releaseBuffer();\n    const sizeBuffer = Buffer.allocUnsafe(4);\n    sizeBuffer.writeUInt32BE(serializedMessage.length);\n\n    const buffer = Buffer.concat([\n      sizeBuffer\x2C\n      serializedMessage\x2C\n    ]);\n    const result = channel.writeBuffer(req\x2C buffer\x2C handle);\n    // Mirror what stream_base_commons.js does for Buffer retention.\n    if (streamBaseState[kLastWriteWasAsync])\n      req.buffer = buffer;\n    return result;\n  }\x2C\n};\n\nconst json = {\n  initMessageChannel(channel) {\n    channel[kJSONBuffer] = '';\n    channel[kStringDecoder] = undefined;\n  }\x2C\n\n  *parseChannelMessages(channel\x2C readData) {\n    if (readData.length === 0) return;\n\n    if (channel[kStringDecoder] === undefined)\n      channel[kStringDecoder] = new StringDecoder('utf8');\n    const chunks =\n      StringPrototypeSplit(channel[kStringDecoder].write(readData)\x2C '\\n');\n    const numCompleteChunks = chunks.length - 1;\n    // Last line does not have trailing linebreak\n    const incompleteChunk = chunks[numCompleteChunks];\n    if (numCompleteChunks === 0) {\n      channel[kJSONBuffer] += incompleteChunk;\n    } else {\n      chunks[0] = channel[kJSONBuffer] + chunks[0];\n      for (let i = 0; i < numCompleteChunks; i++)\n        yield JSONParse(chunks[i]);\n      channel[kJSONBuffer] = incompleteChunk;\n    }\n    channel.buffering = channel[kJSONBuffer].length !== 0;\n  }\x2C\n\n  writeChannelMessage(channel\x2C req\x2C message\x2C handle) {\n    const string = JSONStringify(message) + '\\n';\n    return channel.writeUtf8String(req\x2C string\x2C handle);\n  }\x2C\n};\n\nmodule.exports = { advanced\x2C json };\n
code-source-info,0x216c440040be,103,0,4203,C0O0C4O4203,,
code-creation,Function,10,163377,0x216c44004936,369, node:internal/child_process/serialization:1:1,0x216c44004028,~
code-source-info,0x216c44004936,103,0,4203,C0O0C56O25C62O38C68O55C74O79C79O89C85O154C88O154C93O143C99O199C102O199C107O181C113O237C116O237C121O282C124O282C129O260C135O329C138O329C142O329C144O405C147O405C152O365C158O382C164O461C167O461C171O461C173O507C176O507C180O507C182O553C185O553C189O553C191O811C192O811C194O845C196O845C202O888C237O848C243O1201C278O1159C280O1644C285O1648C293O1764C301O2460C312O3094C317O3098C325O3208C333O3997C344O4166C351O4185C357O4195C363O4181C368O4202,,
code-creation,LazyCompile,10,163591,0x216c44005296,23,initMessageChannel node:internal/child_process/serialization:100:21,0x216c44004320,~
code-source-info,0x216c44005296,103,3116,3203,C0O3132C2O3140C7O3153C11O3163C13O3171C17O3187C22O3202,,
tick,0x107295c5c,163664,0,0x0,0,0x1073ae290,0x216c440052a7,0x216c1597f089,0x216c1597e626,0x216c15953a8c,0x216c7df7df3e,0x216c7df78cf5
code-creation,LazyCompile,10,163732,0x216c440059fe,19,_getMaxListeners node:events:274:26,0x216c014f2218,~
code-source-info,0x216c440059fe,13,7772,7896,C0O7792C6O7825C9O7845C13O7865C14O7880C18O7894,,
code-creation,LazyCompile,10,163777,0x216c44005b06,5,get node:events:136:16,0x216c014f1e38,~
code-source-info,0x216c44005b06,13,3826,3866,C0O3835C4O3862,,
code-creation,LazyCompile,10,163860,0x216c44005d76,322,arrayClone node:events:751:20,0x216c014f2ae0,~
code-source-info,0x216c44005d76,13,21217,21671,C0O21356C42O21378C50O21389C62O21397C71O21402C72O21415C80O21426C92O21434C104O21442C113O21447C114O21460C122O21471C134O21479C146O21487C158O21495C167O21500C168O21513C176O21524C188O21532C200O21540C212O21548C224O21556C233O21561C234O21574C242O21585C254O21593C266O21601C278O21609C290O21617C302O21625C311O21630C312O21637C317O21644C321O21669,,
code-creation,LazyCompile,10,163936,0x216c44006016,30,onNewListener node:child_process:176:51,0x216c1597e488,~
code-source-info,0x216c44006016,95,5152,5239,C0O5165C2O5174C9O5196C14O5214C19O5222C24O5222C29O5238,,
code-creation,LazyCompile,10,164076,0x216c44006376,455,initializePolicy node:internal/bootstrap/pre_execution:365:26,0x216c7df7b140,~
code-source-info,0x216c44006376,91,11306,13104,C0O11340C10O11340C15O11383C17O11413C21O11421C35O11421C41O11546C49O11546C55O11523C60O11538C65O11665C67O11682C75O11686C81O11701C87O11702C94O11742C100O11774C108O11756C116O11831C120O11853C126O11853C132O11831C138O11867C149O11883C153O11897C161O11911C167O11969C175O11969C180O12003C190O12003C197O12078C207O12078C212O12120C214O12173C222O12173C227O12251C235O12251C241O12219C246O12231C251O12300C257O12300C263O12350C269O12350C275O12409C277O12435C279O12459C283O12440C288O12549C290O12565C295O12500C300O12528C305O12591C311O12627C317O12627C322O12668C328O12668C334O12697C340O12717C344O12704C349O12737C356O12784C358O12813C360O12854C366O12876C376O12876C383O12854C389O12468C394O12422C397O12911C401O12938C415O12944C420O12938C421O13027C429O13027C435O13068C441O13092C447O13069C454O13103,,
code-creation,LazyCompile,10,164188,0x216c44006756,63,initializeClusterIPC node:internal/bootstrap/pre_execution:356:30,0x216c7df7b0f0,~
code-source-info,0x216c44006756,91,11038,11279,C0O11045C3O11057C10O11061C18O11076C23O11080C29O11118C35O11118C40O11150C45O11150C49O11239C52O11254C62O11278,,
code-creation,LazyCompile,10,164248,0x216c440068d6,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:458:38,0x216c7df7b280,~
code-source-info,0x216c440068d6,91,14759,14908,C0O14803C6O14803C11O14774C16O14854C21O14883C26O14907,,
code-creation,Eval,10,164576,0x216c4400721e,5, node:internal/source_map/source_map_cache:1:1,0x216c44006ea8,~
script-source,104,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err.stack);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x216c4400721e,104,0,7654,C0O0C4O7654,,
tick,0x7ff808957cf9,165395,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c440068dc,0x216c7df7df50,0x216c7df78cf5
code-creation,Function,10,165423,0x216c440078a6,435, node:internal/source_map/source_map_cache:1:1,0x216c44007188,~
code-source-info,0x216c440078a6,104,0,7654,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7518C399O7539C405O7556C411O7580C417O7604C423O7627C429O7533C434O7653,,
code-creation,Eval,10,165760,0x216c440088f6,5, node:internal/util/iterable_weak_map:1:1,0x216c44008698,~
script-source,105,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x216c440088f6,105,0,1958,C0O0C4O1958,,
code-creation,Function,10,165999,0x216c44009066,196, node:internal/util/iterable_weak_map:1:1,0x216c44008860,~
code-source-info,0x216c44009066,105,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,166030,0x216c440091f6,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x216c44008b80,~
code-source-info,0x216c440091f6,105,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
tick,0x106d4a33b,166190,1,0x106d4ba80,6,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c440079dd,0x216c7df79cad,0x216c7df78f7d,0x216c440068dc,0x216c7df7df50,0x216c7df78cf5
code-creation,Eval,10,166402,0x216c44009d86,5, node:internal/modules/cjs/helpers:1:1,0x216c44009ac0,~
script-source,106,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet(['require'\x2C 'node'\x2C ...userConditions]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object) {\n  // Make built-in modules available directly (loaded lazily).\n  const { builtinModules } = require('internal/modules/cjs/loader').Module;\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x216c44009d86,106,0,6319,C0O0C4O6319,,
code-creation,Function,10,167097,0x216c4400a2d6,462, node:internal/modules/cjs/helpers:1:1,0x216c44009cf0,~
code-source-info,0x216c4400a2d6,106,0,6319,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O935C334O970C335O970C391O935C396O935C398O1528C400O1528C405O1528C407O6159C414O6180C420O6206C426O6223C432O6239C438O6259C444O6282C450O6306C456O6174C461O6318,,
code-creation,LazyCompile,10,167297,0x216c4400ae26,27,SafeSet node:internal/per_context/primordials:364:16,0x216c014c9f90,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(global[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x216c4400ae26,6,10527,10544,C3O10533C7O10539C11O10533C26O10543,,
tick,0x7ff808957cf9,168655,0,0x0,3,0x10739e050,0x216c4400a45d,0x216c7df79cad,0x216c7df78f7d,0x216c440079dd,0x216c7df79cad,0x216c7df78f7d,0x216c440068dc,0x216c7df7df50,0x216c7df78cf5
tick,0x1070fffa0,168711,0,0x0,3,0x10739e050,0x216c4400a466,0x216c7df79cad,0x216c7df78f7d,0x216c440079dd,0x216c7df79cad,0x216c7df78f7d,0x216c440068dc,0x216c7df7df50,0x216c7df78cf5
code-creation,LazyCompile,10,168732,0x216c4400bc76,27,SafeMap node:internal/per_context/primordials:351:16,0x216c014c9e08,~
code-source-info,0x216c4400bc76,6,10200,10217,C3O10206C7O10212C11O10206C26O10216,,
code-creation,LazyCompile,10,168830,0x216c4400bdfe,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x216c44008978,~
code-source-info,0x216c4400bdfe,105,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,168882,0x216c4400c196,27,SafeWeakMap node:internal/per_context/primordials:357:16,0x216c014c9ec8,~
code-source-info,0x216c4400c196,6,10371,10388,C3O10377C7O10383C11O10377C26O10387,,
code-creation,LazyCompile,10,168936,0x216c4400c2ae,27,SafeFinalizationRegistry node:internal/per_context/primordials:378:16,0x216c014ca118,~
code-source-info,0x216c4400c2ae,6,10977,11022,C3O10997C7O11003C11O10997C26O11021,,
code-creation,LazyCompile,10,169136,0x216c4400ca4e,492,initializeDeprecations node:internal/bootstrap/pre_execution:250:32,0x216c7df7b010,~
code-source-info,0x216c4400ca4e,91,7941,10440,C0O7941C11O7970C19O7970C24O7956C29O8025C39O8025C44O8216C52O8216C57O8257C65O8257C70O8310C99O8302C127O8302C130O8628C141O8648C145O8690C156O8764C167O8854C178O8809C187O8675C196O8913C199O8646C203O8291C269O9190C277O9190C282O9169C287O9219C289O9247C304O9268C311O9386C315O9247C320O9418C324O9448C334O9484C344O9561C351O9466C356O9464C360O9647C370O9689C381O9671C386O9669C390O10028C394O10028C396O10039C407O10060C418O10089C426O10131C434O10039C439O10244C445O10244C447O10254C458O10275C469O10303C477O10344C485O10254C491O10439,,
code-creation,LazyCompile,10,169271,0x216c4400cfb6,53,initializeWASI node:internal/bootstrap/pre_execution:414:24,0x216c7df7b190,~
code-source-info,0x216c4400cfb6,91,13129,13335,C0O13161C6O13161C11O13144C16O13227C21O13231C29O13231C35O13246C37O13277C43O13277C47O13271C52O13334,,
code-creation,LazyCompile,10,169374,0x216c4400d18e,51,initializeCJSLoader node:internal/bootstrap/pre_execution:421:29,0x216c7df7b1e0,~
code-source-info,0x216c4400d18e,91,13365,13623,C0O13390C6O13390C11O13442C16O13449C21O13449C25O13541C36O13562C41O13598C45O13556C50O13622,,
tick,0x1072dfa79,169898,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,170571,0x216c4400f106,5, node:internal/modules/cjs/loader:1:1,0x216c4400e810,~
script-source,107,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C request\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C request\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C request\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(match\x2C request\x2C parentPath\x2C pkgPath) {\n  const { resolved\x2C exact } = match;\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  let actual = tryFile(filename);\n  if (!exact && !actual) {\n    const exts = ObjectKeys(Module._extensions);\n    actual = tryExtensions(filename\x2C exts\x2C false) ||\n      tryPackage(filename\x2C exts\x2C false\x2C request);\n  }\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const ESMLoader = asyncESM.ESMLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !ESMLoader.cjsCache.has(this))\n    ESMLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.ESMLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier) {\n        const loader = asyncESM.ESMLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {}\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
tick,0x7ff80896f243,175156,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957f54,175168,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957f0d,175178,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957d23,175188,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c4400f106,107,0,40182,C0O0C4O40182,,
code-creation,Function,10,175217,0x216c44010ea6,2547, node:internal/modules/cjs/loader:1:1,0x216c4400f070,~
code-source-info,0x216c44010ea6,107,0,40182,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13498C2107O13498C2109O14282C2116O14282C2118O14300C2126O14317C2134O16993C2141O16993C2143O17070C2147O17078C2155O17070C2157O17086C2161O17149C2169O17173C2179O18757C2187O18781C2195O19927C2203O19954C2211O21502C2223O21520C2235O21897C2249O21502C2259O21502C2261O23185C2269O23198C2277O26129C2285O26153C2293O30233C2297O30240C2311O30255C2319O31169C2323O31176C2337O31194C2345O31632C2346O31632C2348O31667C2349O31667C2351O32724C2355O32731C2369O32750C2377O34632C2381O34639C2395O34658C2403O36402C2407O36409C2421O36430C2429O36830C2433O36837C2447O36858C2455O37671C2461O37721C2467O37671C2469O38305C2475O38326C2483O38344C2491O38362C2499O39331C2507O39354C2515O39941C2523O39970C2531O40158C2537O40172C2546O40181,,
tick,0x107101be2,175888,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44011244,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,175933,0x216c44014f26,5, node:internal/modules/package_json_reader:1:1,0x216c44014d70,~
script-source,108,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x216c44014f26,108,0,983,C0O0C4O983,,
code-creation,Function,10,176090,0x216c44015086,113, node:internal/modules/package_json_reader:1:1,0x216c44014e90,~
code-source-info,0x216c44015086,108,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
code-creation,Eval,10,176306,0x216c440158ce,5, node:internal/process/esm_loader:1:1,0x216c440156c8,~
script-source,109,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { Loader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback = async function(wrap\x2C specifier) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nlet ESMLoader = new Loader();\nexports.ESMLoader = ESMLoader;\n\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  const userLoader = getOptionValue('--experimental-loader');\n  if (!userLoader)\n    return;\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n  // If --experimental-loader is specified\x2C create a loader with user hooks.\n  // Otherwise create the default loader.\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n  return (async () => {\n    const hooks =\n        await ESMLoader.import(userLoader\x2C pathToFileURL(cwd).href);\n    ESMLoader = new Loader();\n    ESMLoader.hook(hooks);\n    ESMLoader.runGlobalPreloadCode();\n    return exports.ESMLoader = ESMLoader;\n  })();\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(ESMLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x216c440158ce,109,0,2326,C0O0C4O2326,,
code-creation,Function,10,176603,0x216c44015bb6,189, node:internal/process/esm_loader:1:1,0x216c44015838,~
code-source-info,0x216c44015bb6,109,0,2326,C0O0C45O69C51O69C56O95C61O25C67O122C73O122C78O111C84O213C90O213C95O172C101O278C107O278C112O260C118O336C124O336C129O313C135O368C142O403C146O704C153O744C157O1156C160O1156C165O1156C167O1170C172O1188C176O1971C183O1987C188O2325,,
tick,0x106ea757d,177177,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,177325,0x216c440168c6,5, node:internal/modules/esm/loader:1:1,0x216c440165c0,~
script-source,110,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  FunctionPrototypeBind\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_RETURN_PROPERTY\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { URL\x2C pathToFileURL\x2C isURLInstance } = require('internal/url');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require(\n  'internal/modules/esm/get_source');\nconst { defaultTransformSource } = require(\n  'internal/modules/esm/transform_source');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/* A Loader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph. */\nclass Loader {\n  constructor() {\n    // Methods which translate input code or other information\n    // into es modules\n    this.translators = translators;\n\n    // Registry of loaded modules\x2C akin to `require.cache`\n    this.moduleMap = new ModuleMap();\n\n    // Map of already-loaded CJS modules to use\n    this.cjsCache = new SafeWeakMap();\n\n    // This hook is called before the first root module is imported. It's a\n    // function that returns a piece of code that runs as a sloppy-mode script.\n    // The script may evaluate to a function that can be called with a\n    // `getBuiltin` helper that can be used to retrieve builtins.\n    // If the hook returns `null` instead of a source string\x2C it opts out of\n    // running any preload code.\n    // The preload code runs as soon as the hook module has finished evaluating.\n    this._getGlobalPreloadCode = null;\n    // The resolver has the signature\n    //   (specifier : string\x2C parentURL : string\x2C defaultResolve)\n    //       -> Promise<{ url : string }>\n    // where defaultResolve is ModuleRequest.resolve (having the same\n    // signature itself).\n    this._resolve = defaultResolve;\n    // This hook is called after the module is resolved but before a translator\n    // is chosen to load it; the format returned by this function is the name\n    // of a translator.\n    this._getFormat = defaultGetFormat;\n    // This hook is called just before the source code of an ES module file\n    // is loaded.\n    this._getSource = defaultGetSource;\n    // This hook is called just after the source code of an ES module file\n    // is loaded\x2C but before anything is done with the string.\n    this._transformSource = defaultTransformSource;\n    // The index for assigning unique URLs to anonymous module evaluation\n    this.evalIndex = 0;\n  }\n\n  async resolve(specifier\x2C parentURL) {\n    const isMain = parentURL === undefined;\n    if (!isMain && typeof parentURL !== 'string' && !isURLInstance(parentURL))\n      throw new ERR_INVALID_ARG_TYPE('parentURL'\x2C ['string'\x2C 'URL']\x2C parentURL);\n\n    const resolveResponse = await this._resolve(\n      specifier\x2C { parentURL\x2C conditions: DEFAULT_CONDITIONS }\x2C defaultResolve);\n    if (typeof resolveResponse !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C 'loader resolve'\x2C resolveResponse);\n    }\n\n    const { url } = resolveResponse;\n    if (typeof url !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C 'loader resolve'\x2C 'url'\x2C url);\n    }\n    return url;\n  }\n\n  async getFormat(url) {\n    const getFormatResponse = await this._getFormat(\n      url\x2C {}\x2C defaultGetFormat);\n    if (typeof getFormatResponse !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C 'loader getFormat'\x2C getFormatResponse);\n    }\n\n    const { format } = getFormatResponse;\n    if (format === null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n      throw new ERR_INVALID_MODULE_SPECIFIER(\n        url\x2C\n        dataUrl ? `has an unsupported MIME type "${dataUrl[1]}"` : '');\n    }\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C 'loader getFormat'\x2C 'format'\x2C format);\n    }\n\n    if (format === 'builtin') {\n      return format;\n    }\n\n    if (this._resolve !== defaultResolve) {\n      try {\n        new URL(url);\n      } catch {\n        throw new ERR_INVALID_RETURN_PROPERTY(\n          'url'\x2C 'loader resolve'\x2C 'url'\x2C url\n        );\n      }\n    }\n\n    if (this._resolve === defaultResolve &&\n      !StringPrototypeStartsWith(url\x2C 'file:') &&\n      !StringPrototypeStartsWith(url\x2C 'data:')\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY(\n        'file: or data: url'\x2C 'loader resolve'\x2C 'url'\x2C url\n      );\n    }\n\n    return format;\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }) => {\n          return this.import(specifier\x2C url);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(this\x2C url\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C job);\n    const { module } = await job.run();\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  async import(specifier\x2C parent) {\n    const job = await this.getModuleJob(specifier\x2C parent);\n    const { module } = await job.run();\n    return module.getNamespace();\n  }\n\n  hook(hooks) {\n    const {\n      resolve\x2C\n      dynamicInstantiate\x2C\n      getFormat\x2C\n      getSource\x2C\n      transformSource\x2C\n      getGlobalPreloadCode\x2C\n    } = hooks;\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (resolve !== undefined)\n      this._resolve = FunctionPrototypeBind(resolve\x2C null);\n    if (dynamicInstantiate !== undefined) {\n      process.emitWarning(\n        'The dynamicInstantiate loader hook has been removed.');\n    }\n    if (getFormat !== undefined) {\n      this._getFormat = FunctionPrototypeBind(getFormat\x2C null);\n    }\n    if (getSource !== undefined) {\n      this._getSource = FunctionPrototypeBind(getSource\x2C null);\n    }\n    if (transformSource !== undefined) {\n      this._transformSource = FunctionPrototypeBind(transformSource\x2C null);\n    }\n    if (getGlobalPreloadCode !== undefined) {\n      this._getGlobalPreloadCode =\n        FunctionPrototypeBind(getGlobalPreloadCode\x2C null);\n    }\n  }\n\n  runGlobalPreloadCode() {\n    if (!this._getGlobalPreloadCode) {\n      return;\n    }\n    const preloadCode = this._getGlobalPreloadCode();\n    if (preloadCode === null) {\n      return;\n    }\n\n    if (typeof preloadCode !== 'string') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'string'\x2C 'loader getGlobalPreloadCode'\x2C preloadCode);\n    }\n    const { compileFunction } = require('vm');\n    const preloadInit = compileFunction(preloadCode\x2C ['getBuiltin']\x2C {\n      filename: '<preload>'\x2C\n    });\n    const { NativeModule } = require('internal/bootstrap/loaders');\n\n    preloadInit.call(globalThis\x2C (builtinName) => {\n      if (NativeModule.canBeRequiredByUsers(builtinName)) {\n        return require(builtinName);\n      }\n      throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n    });\n  }\n\n  async getModuleJob(specifier\x2C parentURL) {\n    const url = await this.resolve(specifier\x2C parentURL);\n    const format = await this.getFormat(url);\n    let job = this.moduleMap.get(url);\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function')\n      this.moduleMap.set(url\x2C job = job());\n    if (job !== undefined)\n      return job;\n\n    if (!translators.has(format))\n      throw new ERR_UNKNOWN_MODULE_FORMAT(format);\n\n    const loaderInstance = translators.get(format);\n\n    const inspectBrk = parentURL === undefined &&\n        format === 'module' && getOptionValue('--inspect-brk');\n    job = new ModuleJob(this\x2C url\x2C loaderInstance\x2C parentURL === undefined\x2C\n                        inspectBrk);\n    this.moduleMap.set(url\x2C job);\n    return job;\n  }\n}\n\nObjectSetPrototypeOf(Loader.prototype\x2C null);\n\nexports.Loader = Loader;\n
code-source-info,0x216c440168c6,110,0,8716,C0O0C4O8716,,
code-creation,Function,10,178202,0x216c44016f26,430, node:internal/modules/esm/loader:1:1,0x216c44016830,~
code-source-info,0x216c44016f26,110,0,8716,C0O0C89O79C95O79C99O130C105O155C110O179C116O202C122O217C128O246C134O493C140O493C145O519C150O286C156O310C162O335C168O367C174O398C180O435C186O463C192O573C198O573C203O535C209O540C215O555C221O616C227O616C231O616C233O678C239O678C243O678C245O775C251O775C256O733C262O751C268O845C274O845C279O824C285O918C291O918C296O897C302O1000C308O1000C313O973C319O1077C325O1077C330O1061C336O1152C342O1152C347O1133C410O8672C417O8644C422O8691C424O8706C429O8715,,
tick,0x10729a836,178437,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017009,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,178469,0x216c44017e16,5, node:internal/modules/esm/module_map:1:1,0x216c44017c38,~
script-source,111,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst {\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url) {\n    validateString(url\x2C 'url');\n    return super.get(url);\n  }\n  set(url\x2C job) {\n    validateString(url\x2C 'url');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url\x2C job);\n  }\n  has(url) {\n    validateString(url\x2C 'url');\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x216c44017e16,111,0,955,C0O0C4O955,,
code-creation,Function,10,178590,0x216c44018246,149, node:internal/modules/esm/module_map:1:1,0x216c44017d80,~
code-source-info,0x216c44018246,111,0,955,C0O0C17O33C20O33C24O33C26O87C31O125C34O125C39O158C52O159C58O125C60O236C63O236C68O262C73O211C79O297C82O297C87O278C97O407C141O927C143O942C148O954,,
code-creation,Eval,10,178867,0x216c44018c9e,5, node:internal/modules/esm/module_job:1:1,0x216c440189a8,~
script-source,112,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const childFileURL =\n            await this.loader.resolve(childSpecifier\x2C parentFileUrl);\n        const format = await this.loader.getFormat(childFileURL);\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n              StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
tick,0x7ff808957f9b,181382,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4401825a,0x216c7df79cad,0x216c7df78f7d,0x216c44017009,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c44018c9e,112,0,7676,C0O0C4O7676,,
code-creation,Function,10,181421,0x216c4401919e,334, node:internal/modules/esm/module_job:1:1,0x216c44018c08,~
code-source-info,0x216c4401919e,112,0,7676,C0O0C85O25C91O47C97O68C103O90C109O112C114O133C119O157C125O171C130O189C136O214C142O230C148O253C154O274C160O285C166O312C172O336C178O362C184O386C190O454C196O454C201O439C207O518C213O518C218O495C224O580C230O580C235O554C241O644C247O644C251O644C253O696C256O696C258O728C260O728C262O769C263O769C265O799C269O799C271O917C275O917C314O7630C321O7599C326O7648C328O7663C333O7675,,
tick,0x7ff80896f1fd,182437,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017021,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x1072c1be7,183079,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017021,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,183283,0x216c4401bc96,5, node:internal/modules/esm/resolve:1:1,0x216c4401b5d0,~
script-source,113,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeSubstr\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node'\x2C 'import'\x2C ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\nconst emittedPackageWarnings = new SafeSet();\nfunction emitFolderMapDeprecation(match\x2C pjsonUrl\x2C isExports\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping "${match}" in the ${isExports ?\n      '"exports"' : '"imports"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like "${match}*".`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0148'\n  );\n}\n\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const { format } = defaultGetFormat(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved\x2C base) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  const path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path\x2C '/')) {\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveDirectoryEntry(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  return resolved;\n}\n\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          StringPrototypeReplace(target\x2C patternRegEx\x2C subpath) :\n          target + subpath;\n        return packageResolve(exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath))\n    throwInvalidSubpath(match + subpath\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (pattern)\n    return new URL(StringPrototypeReplace(resolved.href\x2C patternRegEx\x2C\n                                          subpath));\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {object} packageConfig\n * @param {string} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    return { resolved\x2C exact: true };\n  }\n\n  let bestMatch = '';\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key[key.length - 1] === '*' &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C -1)) &&\n        packageSubpath.length >= key.length &&\n        key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath\x2C key) &&\n      key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = StringPrototypeSubstr(packageSubpath\x2C bestMatch.length -\n      (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C\n                                          bestMatch\x2C base\x2C pattern\x2C false\x2C\n                                          conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C true\x2C base);\n    return { resolved\x2C exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name)) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolved !== null)\n          return { resolved\x2C exact: true };\n      } else {\n        let bestMatch = '';\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (key[key.length - 1] === '*' &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C -1)) &&\n              name.length >= key.length &&\n              key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name\x2C key) &&\n            key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = StringPrototypeSubstr(name\x2C bestMatch.length -\n            (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(\n            packageJSONUrl\x2C target\x2C subpath\x2C bestMatch\x2C base\x2C pattern\x2C true\x2C\n            conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C false\x2C base);\n            return { resolved\x2C exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base);\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier\x2C base\x2C conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier\x2C base\x2C conditions);\n    }\n  }\n  return finalizeResolution(resolved\x2C base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = StringPrototypeReplace(found\x2C new RegExp(`\\\\${sep}`\x2C 'g')\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === 'node:')\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL\x2C 'data:')) {\n    // This is gonna blow up\x2C we want the error\n    new URL(specifier\x2C parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier\x2C parentURL\x2C conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath\x2C sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n};\n\n// cycle\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\n
code-source-info,0x216c4401bc96,113,0,31198,C0O0C4O31198,,
tick,0x7ff808957f54,186898,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017021,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957cc0,186913,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017021,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957f0d,186926,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017021,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Function,10,186947,0x216c4401cb46,977, node:internal/modules/esm/resolve:1:1,0x216c4401bc00,~
code-source-info,0x216c4401cb46,113,0,31198,C0O0C361O25C367O41C373O63C379O86C385O99C391O116C396O132C402O161C408O194C414O204C420O227C425O238C431O249C437O259C443O286C449O312C455O338C461O362C467O386C473O415C479O474C482O474C486O474C488O529C491O529C496O512C502O617C505O617C510O578C516O594C522O606C528O659C531O659C536O640C542O754C548O754C557O798C564O754C566O878C569O878C574O851C580O856C586O866C592O920C598O920C602O920C604O988C610O988C614O988C616O1049C622O1049C626O1049C628O1127C631O1127C636O1089C642O1094C648O1109C654O1501C657O1501C662O1527C667O1162C673O1192C679O1217C685O1249C691O1279C697O1309C703O1344C709O1368C715O1402C721O1435C727O1465C733O1565C736O1565C741O1551C747O1632C750O1632C754O1632C756O1704C762O1704C767O1763C774O1798C775O1798C829O1763C833O1763C835O1847C843O1847C848O1847C850O1912C853O1912C858O1912C860O4006C862O4006C867O4006C869O4046C871O4046C876O4046C878O4115C882O4115C884O9025C888O9025C890O9876C894O9876C896O12297C900O12297C902O12360C906O12360C908O30942C915O30963C921O30985C927O31003C933O31022C939O31047C945O31065C951O31090C957O30957C961O31154C964O31154C969O31133C976O31197,,
code-creation,Eval,10,187434,0x216c4401f68e,5, node:internal/modules/esm/get_format:1:1,0x216c4401f468,~
script-source,114,node:internal/modules/esm/get_format,'use strict';\nconst {\n  RegExpPrototypeExec\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\n\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\nfunction defaultGetFormat(url\x2C context\x2C defaultGetFormatUnused) {\n  if (StringPrototypeStartsWith(url\x2C 'node:')) {\n    return { format: 'builtin' };\n  }\n  const parsed = new URL(url);\n  if (parsed.protocol === 'data:') {\n    const { 1: mime } = RegExpPrototypeExec(\n      /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n      parsed.pathname\x2C\n    ) || [ \x2C null ];\n    const format = ({\n      '__proto__': null\x2C\n      'text/javascript': 'module'\x2C\n      'application/json': experimentalJsonModules ? 'json' : null\x2C\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n    return { format };\n  } else if (parsed.protocol === 'file:') {\n    const ext = extname(parsed.pathname);\n    let format;\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpecifierResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.'\x2C\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\n      }\n    }\n    return { format: format || null };\n  }\n  return { format: null };\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  extensionFormatMap\x2C\n  legacyExtensionFormatMap\x2C\n};\n
code-source-info,0x216c4401f68e,114,0,2537,C0O0C4O2537,,
code-creation,Function,10,187719,0x216c4401f94e,258, node:internal/modules/esm/get_format:1:1,0x216c4401f5f8,~
code-source-info,0x216c4401f94e,114,0,2537,C0O0C50O24C56O47C62O111C65O111C70O99C76O155C79O155C84O136C89O217C92O217C96O217C98O306C101O306C105O306C107O393C110O393C114O393C116O467C119O467C124O448C130O539C133O539C138O516C144O521C150O603C153O603C158O629C163O572C169O665C173O665C175O785C179O785C181O920C185O951C194O1015C200O979C204O1026C208O1057C217O1121C223O1085C227O2445C234O2466C240O2486C246O2508C252O2460C257O2536,,
tick,0x1071211a0,188072,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,188095,0x216c44020176,5, node:internal/modules/esm/get_source:1:1,0x216c4401ff90,~
script-source,115,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\nconst { Buffer } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_INVALID_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C { format } = {}\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = Buffer.from(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else {\n    throw new ERR_INVALID_URL_SCHEME(['file'\x2C 'data']);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return { source };\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x216c44020176,115,0,1353,C0O0C4O1353,,
code-creation,Function,10,188302,0x216c440202f6,169, node:internal/modules/esm/get_source:1:1,0x216c440200e0,~
code-source-info,0x216c440202f6,115,0,1353,C0O0C37O25C43O48C49O112C52O112C57O93C62O207C65O207C74O251C81O207C83O316C86O316C91O305C97O347C100O347C105O378C110O404C113O404C118O396C124O486C127O486C132O512C137O439C143O458C149O545C153O542C155O581C159O581C161O1308C163O1333C168O1352,,
tick,0x1072c4f2b,189215,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,189266,0x216c4402153e,5, node:internal/fs/promises:1:1,0x216c44020df0,~
script-source,116,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError();\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions === undefined) {\n      bufferOrOptions = {};\n    }\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.byteLength;\n    position = bufferOrOptions.position || null;\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return SafePromisePrototypeFinally(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return SafePromisePrototypeFinally(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return SafePromisePrototypeFinally(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return SafePromisePrototypeFinally(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
tick,0x106ea13f4,191949,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff80884e9f8,191967,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c4402153e,116,0,21471,C0O0C4O21471,,
code-creation,Function,10,191999,0x216c44023aae,1534, node:internal/fs/promises:1:1,0x216c440214a8,~
code-source-info,0x216c44023aae,116,0,21471,C0O0C459O25C465O47C471O56C477O67C483O78C489O101C495O112C501O136C507O154C513O175C519O206C524O216C530O311C534O311C540O339C546O256C552O264C558O277C564O289C570O299C576O360C580O360C584O360C586O402C590O402C596O391C602O550C606O550C612O550C618O445C624O472C630O499C636O534C642O608C646O608C652O586C658O667C662O667C668O648C674O1278C678O1278C684O1278C690O725C696O743C702O759C708O786C714O820C720O851C726O865C732O894C737O908C743O922C749O945C755O965C761O981C767O994C773O1026C779O1043C785O1066C791O1085C797O1108C803O1136C809O1165C814O1186C820O1210C826O1248C832O1328C836O1328C842O1316C847O1502C851O1502C857O1366C863O1383C869O1406C875O1425C881O1443C887O1463C893O1482C899O1553C903O1553C907O1553C909O1610C913O1610C919O1578C925O1596C930O1666C934O1666C940O1644C945O1718C949O1718C955O1708C960O1774C964O1774C970O1759C976O1824C980O1824C984O1824C986O1869C990O1869C994O1869C996O1900C1000O1900C1004O1900C1006O1929C1010O1929C1014O1929C1016O1968C1020O1968C1024O1968C1026O2015C1030O2015C1034O2015C1036O2061C1040O2061C1044O2061C1046O2098C1050O2098C1054O2098C1056O2129C1060O2129C1064O2129C1066O2173C1070O2156C1076O2251C1080O2251C1086O2192C1091O2208C1096O2222C1101O2233C1106O2331C1110O2331C1112O2387C1116O2387C1118O2443C1228O4728C1238O5131C1248O5188C1260O5279C1270O5316C1302O2418C1304O21036C1310O21066C1318O21072C1324O21084C1330O21098C1334O21117C1344O21141C1350O21153C1356O21167C1362O21175C1368O21186C1374O21197C1380O21210C1386O21224C1392O21237C1398O21248C1404O21258C1410O21268C1416O21280C1422O21291C1428O21303C1434O21315C1440O21326C1446O21338C1452O21351C1458O21365C1464O21378C1470O21393C1476O21409C1482O21423C1494O21438C1504O21452C1514O21460C1524O21051C1533O21470,,
code-creation,Function,10,192319,0x216c440243ce,27,<instance_members_initializer> node:internal/fs/promises:177:3,0x216c44022988,~
code-source-info,0x216c440243ce,116,3925,4723,C0O3925C12O3933C26O4723,,
tick,0x1073f9604,192568,1,0x106d4ba80,6,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,192979,0x216c44026c2e,5, node:internal/fs/rimraf:1:1,0x216c440268b8,~
script-source,117,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR')\n      throw originalErr;\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
tick,0x7ff80882d44e,193807,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c44026c2e,117,0,7095,C0O0C4O7095,,
code-creation,Function,10,193843,0x216c4402723e,409, node:internal/fs/rimraf:1:1,0x216c44026b98,~
code-source-info,0x216c4402723e,117,0,7095,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7038C385O7057C391O7065C397O7081C403O7053C408O7094,,
code-creation,LazyCompile,10,194350,0x216c440280e6,188,from node:buffer:294:28,0x216cb0d24940,~
script-source,18,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\nconst kBase64Digits =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
tick,0x7ff8088a98d6,199837,0,0x0,3,0x10739e050,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957955,199875,0,0x0,3,0x10739e050,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957f54,199892,0,0x0,3,0x10739e050,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957e25,199909,0,0x0,3,0x10739e050,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808839d16,199925,0,0x0,3,0x10739e050,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c440280e6,18,8386,9337,C3O8424C9O8459C12O8466C17O8502C18O8506C28O8561C33O8565C39O8596C51O8603C56O8652C57O8680C63O8697C68O8697C73O8712C78O8751C95O8842C104O8849C109O8889C110O8911C113O8911C118O8934C120O8947C122O8956C123O8962C125O8979C127O8978C134O9040C136O9046C138O9045C145O9064C151O9082C155O9127C158O9134C163O9174C164O9196C182O9202C187O9196,,
tick,0x106f2d782,201165,0,0x0,3,0x10739e050,0x216c440280f2,0x216c440273b1,0x216c7df79cad,0x216c7df78f7d,0x216c44023d44,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,LazyCompile,10,201216,0x216c4402aabe,110,fromString node:buffer:430:20,0x216cb0d24d28,~
code-source-info,0x216c4402aabe,18,12437,12871,C0O12464C2O12471C8O12516C14O12523C19O12547C25O12554C30O12567C35O12574C40O12591C41O12596C46O12614C51O12624C56O12661C59O12667C64O12697C66O12726C73O12732C78O12726C79O12783C85O12790C90O12803C95O12810C100O12827C101O12834C104O12841C109O12869,,
code-creation,LazyCompile,10,201337,0x216c4402ac86,177,fromStringFast node:buffer:411:24,0x216cb0d24c88,~
code-source-info,0x216c4402ac86,18,11893,12416,C0O11930C5O11930C11O11953C14O11975C18O11984C21O11964C26O11996C31O12032C36O12003C41O12045C42O12049C44O12063C49O12074C51O12072C54O12060C59O12091C62O12091C65O12115C72O12130C77O12141C85O12115C91O12183C110O12183C116O12214C118O12225C123O12309C130O12328C135O12339C143O12313C149O12366C156O12380C162O12377C168O12390C171O12390C174O12405C176O12414,,
code-creation,LazyCompile,10,201417,0x216c4402ae86,36,FastBuffer node:internal/buffer:958:14,0x216cb0d31850,~
code-source-info,0x216c4402ae86,19,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,201465,0x216c4402af96,23,write node:buffer:591:12,0x216cb0d25098,~
code-source-info,0x216c4402af96,18,16505,16569,C0O16539C17O16539C22O16569,,
code-creation,LazyCompile,10,201534,0x216c4402b096,42,alignPool node:buffer:157:19,0x216cb0d246c0,~
code-source-info,0x216c4402b096,18,3978,4082,C0O4012C4O4027C9O4040C19O4051C25O4063C34O4073C41O4081,,
code-creation,LazyCompile,10,201865,0x216c4402b656,238,promisify node:internal/util:303:19,0x216c014e9c10,~
code-source-info,0x216c4402b656,12,8265,9756,C0O8265C17O8280C23O8320C41O8326C46O8320C47O8389C54O8402C56O8401C61O8446C68O8455C70O8454C74O8486C78O8524C96O8530C101O8524C102O8607C113O8639C123O8680C130O8614C135O8746C136O8909C143O8918C145O8917C148O8909C150O9473C161O9498C167O9498C172O9473C177O9534C188O9559C198O9598C205O9534C210O9665C221O9708C227O9708C232O9672C237O9754,,
code-creation,LazyCompile,10,202129,0x216c4402bb96,65,EventEmitterMixin node:internal/event_target:696:27,0x216c145707d8,~
script-source,38,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nclass Event {\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    this[kDefaultPrevented] = true;\n  }\n\n  get target() { return this[kTarget]; }\n  get currentTarget() { return this[kTarget]; }\n  get srcElement() { return this[kTarget]; }\n\n  get type() { return this[kType]; }\n\n  get cancelable() { return this[kCancelable]; }\n\n  get defaultPrevented() {\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  get timeStamp() { return this[kTimestamp]; }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n\n  composedPath() { return this[kIsBeingDispatched] ? [this[kTarget]] : []; }\n  get returnValue() { return !this.defaultPrevented; }\n  get bubbles() { return this[kBubbles]; }\n  get composed() { return this[kComposed]; }\n  get eventPhase() {\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n  get cancelBubble() { return this[kPropagationStopped]; }\n  set cancelBubble(value) {\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n  stopPropagation() {\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperty(Event.prototype\x2C SymbolToStringTag\x2C {\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'Event'\x2C\n});\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n  }\n\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  dispatchEvent(event) {\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return true;\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: { enumerable: true }\x2C\n  removeEventListener: { enumerable: true }\x2C\n  dispatchEvent: { enumerable: true }\n});\nObjectDefineProperty(EventTarget.prototype\x2C SymbolToStringTag\x2C {\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'EventTarget'\x2C\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  setMaxListeners(n) {\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  getMaxListeners() {\n    return this[kMaxEventTargetListeners];\n  }\n\n  eventNames() {\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  listenerCount(type) {\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  off(type\x2C listener\x2C options) {\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  removeListener(type\x2C listener\x2C options) {\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  on(type\x2C listener) {\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  addListener(type\x2C listener) {\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  emit(type\x2C arg) {\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  once(type\x2C listener) {\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  removeAllListeners(type) {\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: { enumerable: true }\x2C\n  getMaxListeners: { enumerable: true }\x2C\n  eventNames: { enumerable: true }\x2C\n  listenerCount: { enumerable: true }\x2C\n  off: { enumerable: true }\x2C\n  removeListener: { enumerable: true }\x2C\n  on: { enumerable: true }\x2C\n  addListener: { enumerable: true }\x2C\n  once: { enumerable: true }\x2C\n  emit: { enumerable: true }\x2C\n  removeAllListeners: { enumerable: true }\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x216c4402bb96,38,19901,20323,C0O19953C23O20137C30O20169C33O20182C38O20137C43O20196C47O20229C52O20270C57O20229C62O20296C64O20321,,
tick,0x7ff80882d299,204891,0,0x0,3,0x10739e050,0x216c44023f0c,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957f54,204908,0,0x0,3,0x10739e050,0x216c44023f0c,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808922ae6,204923,0,0x0,3,0x10739e050,0x216c44023f0c,0x216c7df79cad,0x216c7df78f7d,0x216c4402035a,0x216c7df79cad,0x216c7df78f7d,0x216c44017049,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,205265,0x216c4402d7e6,5, node:internal/modules/esm/transform_source:1:1,0x216c4402d690,~
script-source,118,node:internal/modules/esm/transform_source,'use strict';\n\nfunction defaultTransformSource(source\x2C { url\x2C format } = {}\x2C\n                                defaultTransformSource) {\n  return { source };\n}\nexports.defaultTransformSource = defaultTransformSource;\n
code-source-info,0x216c4402d7e6,118,0,215,C0O0C4O215,,
code-creation,Function,10,205330,0x216c4402d8ce,13, node:internal/modules/esm/transform_source:1:1,0x216c4402d750,~
code-source-info,0x216c4402d8ce,118,0,215,C0O0C5O158C7O189C12O214,,
tick,0x1072c1be7,205878,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4401706b,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,206016,0x216c4402e4ae,5, node:internal/modules/esm/translators:1:1,0x216c4402dfc8,~
script-source,119,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  PromisePrototypeCatch\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst { defaultGetSource } = require(\n  'internal/modules/esm/get_source');\nconst { defaultTransformSource } = require(\n  'internal/modules/esm/transform_source');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n    getOptionValue('--experimental-import-meta-resolve');\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }) {\n  return asyncESM.ESMLoader.import(specifier\x2C url);\n}\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeCatch(\n      asyncESM.ESMLoader.resolve(specifier\x2C parentUrl)\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\nfunction initializeImportMeta(meta\x2C { url }) {\n  // Alphabetical\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url) {\n  let { source } = await this._getSource(\n    url\x2C { format: 'module' }\x2C defaultGetSource);\n  assertBufferSource(source\x2C true\x2C 'getSource');\n  ({ source } = await this._transformSource(\n    source\x2C { url\x2C format: 'module' }\x2C defaultTransformSource));\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.ESMLoader.cjsCache.has(module)) {\n      exports = asyncESM.ESMLoader.cjsCache.get(module);\n      asyncESM.ESMLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {}\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {}\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url) {\n  emitExperimentalWarning('Importing JSON modules');\n  debug(`Translating JSONModule ${url}`);\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  let { source } = await this._getSource(\n    url\x2C { format: 'json' }\x2C defaultGetSource);\n  assertBufferSource(source\x2C true\x2C 'getSource');\n  ({ source } = await this._transformSource(\n    source\x2C { url\x2C format: 'json' }\x2C defaultTransformSource));\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url) {\n  emitExperimentalWarning('Importing Web Assembly modules');\n  let { source } = await this._getSource(\n    url\x2C { format: 'wasm' }\x2C defaultGetSource);\n  assertBufferSource(source\x2C false\x2C 'getSource');\n  ({ source } = await this._transformSource(\n    source\x2C { url\x2C format: 'wasm' }\x2C defaultTransformSource));\n  assertBufferSource(source\x2C false\x2C 'transformSource');\n  debug(`Translating WASMModule ${url}`);\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x216c4402e4ae,119,0,11976,C0O0C4O11976,,
tick,0x7ff8088ccc74,208311,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4401706b,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x7ff808957d1e,208327,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c4401706b,0x216c7df79cad,0x216c7df78f7d,0x216c44015bff,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Function,10,208364,0x216c4402ed7e,813, node:internal/modules/esm/translators:1:1,0x216c4402e418,~
code-source-info,0x216c4402ed7e,119,0,11976,C0O0C207O25C213O50C219O71C225O82C231O95C237O119C243O152C249O166C255O191C261O208C267O229C272O240C278O251C284O277C290O301C296O330C307O368C313O414C314O414C316O559C322O559C327O542C333O606C339O606C344O582C350O591C356O683C362O683C367O633C373O649C379O669C385O773C391O773C396O742C402O755C408O839C414O839C418O839C420O893C426O893C431O872C437O975C443O975C448O948C454O1056C460O1056C464O1056C466O1145C472O1145C477O1122C483O1137C489O1173C495O1173C500O1206C513O1207C519O1173C521O1287C527O1287C532O1259C538O1391C544O1391C549O1417C554O1323C560O1353C566O1457C572O1457C577O1433C583O1525C586O1525C590O1525C592O1580C595O1565C601O1619C607O1619C612O1600C617O1690C620O1690C624O1690C626O1761C632O1761C636O1761C638O1829C644O1829C649O1809C655O1890C661O1890C666O1874C672O1925C673O1925C675O2249C677O2249C683O2264C685O2284C689O2299C691O2322C695O2355C696O2355C698O3854C711O3854C717O5235C724O5244C727O5227C729O5277C733O5277C735O5296C748O5296C754O8232C767O8232C773O8681C786O8681C792O10866C805O10866C812O11975,,
code-creation,Eval,10,208792,0x216c44030446,5, node:internal/modules/esm/create_dynamic_module:1:1,0x216c44030260,~
script-source,120,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x216c44030446,120,0,1756,C0O0C4O1756,,
code-creation,Function,10,209021,0x216c4403067e,111, node:internal/modules/esm/create_dynamic_module:1:1,0x216c440303b0,~
code-source-info,0x216c4403067e,120,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
tick,0x10732d955,210003,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44015c32,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x10732d955,211568,1,0x106d4ba80,2,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44015c32,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
tick,0x106fff9b7,211907,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44015c32,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-creation,Eval,10,211985,0x216c4403154e,5, node:internal/vm/module:1:1,0x216c44030ff8,~
script-source,121,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
tick,0x107ff11f4,213249,1,0x106d4ba80,3,0x106ed5ae0,0x216c7df79c8c,0x216c7df78f7d,0x216c44015c32,0x216c7df79cad,0x216c7df78f7d,0x216c44011351,0x216c7df79cad,0x216c7df78f7d,0x216c4400d194,0x216c7df7df62,0x216c7df78cf5
code-source-info,0x216c4403154e,121,0,12310,C0O0C4O12310,,
code-creation,Function,10,213278,0x216c440327be,872, node:internal/vm/module:1:1,0x216c440314b8,~
code-source-info,0x216c440327be,121,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,213371,0x216c44032d0e,30,<instance_members_initializer> node:internal/vm/module:256:3,0x216c44031b38,~
code-source-info,0x216c44032d0e,121,6796,6832,C3O6805C29O6832,,
code-creation,LazyCompile,10,213667,0x216c44034366,80,Loader node:internal/modules/esm/loader:45:14,0x216c440168f8,~
code-source-info,0x216c44034366,110,1421,3183,C0O1516C2O1535C4O1533C8O1612C10O1633C13O1629C18O1627C22O1699C24O1719C27O1715C32O1713C36O2223C37O2250C41O2504C43O2520C45O2518C49O2722C51O2740C53O2738C57O2856C59O2874C61O2872C65O3034C67O3058C69O3056C73O3160C74O3175C79O3182,,
code-creation,LazyCompile,10,213750,0x216c44034d86,27,ModuleMap node:internal/modules/esm/module_map:15:14,0x216c44017e98,~
code-source-info,0x216c44034d86,111,430,447,C3O436C7O442C11O436C26O446,,
code-creation,LazyCompile,10,213845,0x216c44034ff6,13,desc.value node:internal/per_context/primordials:325:32,0x216c014c9d60,~
code-source-info,0x216c44034ff6,6,9496,9555,C0O9513C7O9520C12O9543,,
code-creation,LazyCompile,10,213892,0x216c4403510e,13,SafeIterator node:internal/per_context/primordials:270:16,0x216c014c97b0,~
code-source-info,0x216c4403510e,6,7785,7845,C0O7804C3O7821C7O7819C12O7844,,
code-creation,LazyCompile,10,213941,0x216c44035256,13,next node:internal/per_context/primordials:273:9,0x216c014c9878,~
code-source-info,0x216c44035256,6,7854,7899,C0O7865C3O7882C8O7872C12O7893,,
tick,0x1072c4f1c,214394,0,0x0,3,0x10739e050,0x216c4400d1a3,0x216c7df7df62,0x216c7df78cf5
code-creation,LazyCompile,10,214506,0x216c44035a56,315,Module._initPaths node:internal/modules/cjs/loader:1227:29,0x216c44010388,~
code-source-info,0x216c44035a56,107,38372,39328,C0O38395C9O38415C14O38419C22O38433C28O38433C33O38472C42O38492C47O38496C55O38508C61O38508C66O38703C74O38719C77O38724C85O38740C93O38724C103O38762C106O38767C114O38783C125O38767C131O38823C140O38824C143O38829C157O38829C169O38868C173O38887C180O38916C183O38921C191O38921C198O38887C203O38963C210O38992C213O38997C221O38997C228O38963C233O39040C237O39060C244O39094C249O39122C254O39153C257O39158C262O39122C270O39176C273O39094C279O39060C284O39199C286O39211C292O39272C297O39293C302O39313C305O39293C309O39291C314O39327,,
code-creation,Eval,10,214901,0x216c440389f6,5, node:internal/modules/run_main:1:1,0x216c440387e0,~
script-source,122,node:internal/modules/run_main,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const esmLoader = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n  handleMainPromise(esmLoader.loadESM((ESMLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return ESMLoader.import(main);\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  // Handle a Promise from running code that potentially does Top-Level Await.\n  // In that case\x2C it makes sense to set the exit code to a specific non-zero\n  // value if the main code never finishes running.\n  function handler() {\n    if (process.exitCode === undefined)\n      process.exitCode = 13;\n  }\n  process.on('exit'\x2C handler);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handler);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x216c440389f6,122,0,2696,C0O0C4O2696,,
code-creation,Function,10,215201,0x216c44038cfe,149, node:internal/modules/run_main:1:1,0x216c44038960,~
code-source-info,0x216c44038cfe,122,0,2696,C0O0C60O25C66O85C72O85C77O133C83O141C89O153C95O212C101O212C106O193C112O254C118O254C122O254C124O2628C131O2649C137O2674C143O2643C148O2695,,
code-creation,LazyCompile,10,215355,0x216c440394ce,154,initializeESMLoader node:internal/bootstrap/pre_execution:429:29,0x216c7df7b230,~
code-source-info,0x216c440394ce,91,13653,14720,C0O13735C6O13735C13O13784C16O13780C21O13778C25O13802C31O13834C32O13841C33O13941C39O13941C44O13857C49O13897C54O13987C60O13987C65O14188C70O14146C74O14258C79O14219C83O14424C91O14428C97O14544C103O14544C108O14493C113O14501C118O14519C123O14590C129O14590C134O14609C136O14619C140O14633C142O14653C146O14677C148O14696C153O14719,,
tick,0x1077ba07e,215531,0,0x0,0,0x216c1594a58e,0x216c1594a229,0x216c44039529,0x216c7df7df68,0x216c7df78cf5
code-creation,LazyCompile,10,215626,0x216c440396de,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x216c4400f878,~
code-source-info,0x216c440396de,107,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,215701,0x216c440397d6,53,loadPreloadModules node:internal/bootstrap/pre_execution:472:28,0x216c7df7b320,~
code-source-info,0x216c440397d6,91,15196,15516,C0O15283C8O15283C13O15314C15O15351C21O15358C26O15434C32O15434C37O15434C42O15401C47O15478C52O15515,,
code-creation,LazyCompile,10,215798,0x216c440399ce,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:464:36,0x216c7df7b2d0,~
code-source-info,0x216c440399ce,91,14945,15167,C0O14952C8O14956C14O15001C17O15009C28O15009C34O15121C40O15121C45O15158C49O15166,,
code-creation,LazyCompile,10,216120,0x216c44039b06,80,executeUserEntryPoint node:internal/modules/run_main:72:31,0x216c44038b90,~
code-source-info,0x216c44039b06,122,2321,2626,C7O2337C14O2341C22O2371C25O2371C30O2417C33O2417C38O2453C40O2477C45O2488C50O2477C56O2589C61O2596C73O2596C79O2625,,
code-creation,LazyCompile,10,216194,0x216c44039f56,68,resolveMainPath node:internal/modules/run_main:11:25,0x216c44038a28,~
code-source-info,0x216c44039f56,122,296,710,C0O468C5O475C12O485C15O490C20O490C30O475C36O520C38O539C39O546C40O579C48O579C53O625C55O656C60O667C65O692C67O708,,
code-creation,LazyCompile,10,216386,0x216c4403a166,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x216c4400fb98,~
code-source-info,0x216c4403a166,107,14327,16931,C0O14380C5O14385C10O14385C16O14408C18O14435C26O14458C30O14478C36O14485C41O14498C42O14511C43O14536C45O14544C51O14555C57O14555C62O14553C66O14606C69O14613C76O14623C80O14637C82O14652C84O14665C85O14673C87O14709C93O14716C100O14727C103O14770C107O14777C111O14727C119O14790C121O14782C125O14812C127O14838C134O14874C137O14854C143O14943C145O14956C149O14948C154O15041C156O15046C160O15055C165O15070C172O15084C177O15089C179O15104C183O15158C186O15158C192O15198C194O15227C196O15250C197O15279C202O15284C207O15284C214O15319C216O15345C219O15345C224O15365C228O15393C229O15400C234O15427C238O15452C244O15488C249O15504C254O15504C262O15554C265O15565C272O15614C278O16228C283O16244C288O16244C296O16290C299O16301C304O16348C308O16419C312O16453C320O16478C325O16460C330O16500C342O16511C348O16569C354O16589C359O16674C363O16706C371O16731C376O16713C381O16751C396O16762C402O16818C406O16840C409O16847C416O16868C420O16886C422O16902C423O14965C428O14930C434O16916C435O16929,,
code-creation,LazyCompile,10,216503,0x216c4403a526,45,isAbsolute node:path:1156:13,0x216c145639b0,~
code-source-info,0x216c4403a526,35,35448,35594,C0O35461C8O35461C13O35507C19O35514C26O35532C31O35532C39O35571C41O35567C44O35590,,
tick,0x106eb5a35,216736,0,0x0,2,0x10739e050,0x216c4403a241,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-creation,LazyCompile,10,216812,0x216c4403a756,85,stat node:internal/modules/cjs/loader:151:14,0x216c4400f138,~
code-source-info,0x216c4403a756,107,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,216891,0x216c4403a8a6,3,toNamespacedPath node:path:1266:19,0x216c14563aa0,~
code-source-info,0x216c4403a8a6,35,38609,38669,C0O38653C2O38665,,
code-creation,LazyCompile,10,216999,0x216c4403a9a6,42,toRealPath node:internal/modules/cjs/loader:393:20,0x216c4400f408,~
code-source-info,0x216c4403a9a6,107,11292,11404,C0O11310C5O11320C10O11333C17O11353C20O11364C28O11383C35O11320C41O11402,,
new,MemoryChunk,0x216c29bc0000,262144
code-creation,LazyCompile,10,217613,0x216c4403adb6,1036,realpathSync node:fs:2398:22,0x216c4df98058,~
script-source,76,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateCallback(cb);\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void | never}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError());\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number | bigint} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C options\x2C callback)\n    let options = {};\n    if (arguments.length < 3) {\n      // This is fs.read(fd\x2C callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd\x2C {}\x2C callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength\x2C\n      position\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C buffer\x2C options)\n    const options = offset || {};\n\n    ({ offset = 0\x2C length = buffer.byteLength\x2C position } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch { }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError();\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options\x2C {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\nconst emptyObj = ObjectCreate(null);\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options\x2C emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      if (cache) cache.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options\x2C {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null\x2C seenLinks[id]);\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 kb.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      if (promises === null)\n        promises = require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0x216c4403adb6,76,63742,67653,C0O63759C8O63789C12O63769C19O63802C25O63806C31O63828C35O63861C45O63876C51O63876C55O63895C61O63910C67O63910C74O63939C76O63947C78O63946C82O63994C86O63999C92O64001C101O64011C103O64040C105O64065C106O64091C115O64091C120O64131C129O64131C134O64170C137O64217C139O64292C141O64387C143O64463C145O64497C151O64514C157O64544C162O64626C168O64659C176O64667C183O64679C189O64687C197O64693C201O64704C207O64704C223O64687C228O64756C234O64756C238O64789C239O64805C243O64945C247O64941C252O65000C258O65000C264O65022C267O65046C269O65057C274O65086C280O65086C287O65122C289O65133C296O65145C298O65161C302O65183C309O65210C311O65221C317O65257C328O65221C340O65269C342O65287C355O65287C360O65285C364O65331C366O65344C370O65417C372O65430C384O65445C390O65447C402O65457C407O65475C413O65490C417O65498C425O65510C429O65479C442O65543C446O65551C454O65563C458O65532C465O65584C467O65605C469O65630C471O65676C478O65681C484O65683C493O65698C495O65731C502O65913C508O65924C514O65924C520O65966C528O65974C535O66002C541O66010C559O66010C565O66055C571O66055C575O66091C581O66114C585O66096C592O66134C593O66150C597O66166C604O66171C610O66173C619O66198C621O66352C624O66368C627O66378C633O66416C640O66445C649O66416C656O66475C664O66504C673O66475C680O66522C694O66537C700O66552C702O66565C707O66583C709O66605C714O66635C718O66682C726O66690C733O66706C739O66714C757O66714C762O66761C768O66761C772O66798C778O66819C796O66819C803O66874C809O66874C813O66917C819O66943C825O66943C832O66981C836O66998C842O66998C848O67029C854O67045C856O67059C860O67125C866O67140C874O67162C878O67162C885O67140C893O67221C899O67238C905O67270C910O67356C918O67383C923O67411C931O67419C938O67433C944O67441C952O67447C956O67458C962O67458C978O67441C983O67512C989O67512C993O67547C994O67563C998O64930C1004O67584C1011O67589C1017O67591C1026O67611C1030O67618C1035O67651,,
tick,0x7ff80882d126,226148,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff80884ea32,226162,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff808920316,226172,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff808957f70,226182,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff80882d43d,226192,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x106c71898,226201,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff808957f70,226211,0,0x0,3,0x10739e050,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x106ff83cf,226360,0,0x0,3,0x10739e050,0x216c4403adc2,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-creation,LazyCompile,10,226429,0x216c29bc7006,123,getOptions node:internal/fs/utils:313:20,0x216c4df9ff98,~
script-source,77,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isDate\x2C\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigUint64Array} stats\n * @param {number} offset\n * @returns\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
tick,0x7ff808957f54,228784,0,0x0,3,0x10739e050,0x216c4403adc2,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-source-info,0x216c29bc7006,77,7198,7821,C0O7228C14O7320C16O7342C17O7350C23O7389C29O7433C31O7457C35O7472C42O7507C48O7546C66O7552C71O7546C72O7639C79O7648C84O7666C87O7689C92O7666C96O7715C102O7743C107O7771C115O7743C120O7804C122O7819,,
tick,0x106eb8564,228869,0,0x0,2,0x10739e050,0x216c29bc7062,0x216c4403adc2,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-creation,LazyCompile,10,228904,0x216c29bc8e96,48,assertEncoding node:internal/fs/utils:150:24,0x216c4df9f9a0,~
code-source-info,0x216c29bc8e96,77,3507,3684,C0O3522C6O3539C9O3546C14O3546C21O3589C24O3616C40O3622C45O3616C47O3683,,
code-creation,LazyCompile,10,229027,0x216c29bc8fbe,20,toPathIfFileURL node:internal/url:1449:25,0x216c145565e8,~
script-source,33,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst { getConstructorOf\x2C removeColors } = require('internal/util');\nconst {\n  ERR_ARG_NOT_ITERABLE\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_FILE_URL_HOST\x2C\n  ERR_INVALID_FILE_URL_PATH\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_INVALID_TUPLE\x2C\n  ERR_INVALID_URL\x2C\n  ERR_INVALID_URL_SCHEME\x2C\n  ERR_MISSING_ARGS\n} = require('internal/errors').codes;\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateCallback\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  toUSVString: _toUSVString\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\nconst unpairedSurrogateRe =\n    /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey\x2C typedValue);\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n    validateCallback(callback);\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    }\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: { enumerable: true }\x2C\n  delete: { enumerable: true }\x2C\n  get: { enumerable: true }\x2C\n  getAll: { enumerable: true }\x2C\n  has: { enumerable: true }\x2C\n  set: { enumerable: true }\x2C\n  sort: { enumerable: true }\x2C\n  entries: { enumerable: true }\x2C\n  forEach: { enumerable: true }\x2C\n  keys: { enumerable: true }\x2C\n  values: { enumerable: true }\x2C\n  toString: { enumerable: true }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(flags\x2C input) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input\x2C base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    return this[kFormat]({});\n  }\n\n  get href() {\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  // readonly\n  get origin() {\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    return this[context].username;\n  }\n\n  set username(username) {\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    return this[context].password;\n  }\n\n  set password(password) {\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    return this[searchParams];\n  }\n\n  get hash() {\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    return this[kFormat]({});\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\n  toString: { enumerable: true }\x2C\n  href: { enumerable: true }\x2C\n  origin: { enumerable: true }\x2C\n  protocol: { enumerable: true }\x2C\n  username: { enumerable: true }\x2C\n  password: { enumerable: true }\x2C\n  host: { enumerable: true }\x2C\n  hostname: { enumerable: true }\x2C\n  port: { enumerable: true }\x2C\n  pathname: { enumerable: true }\x2C\n  search: { enumerable: true }\x2C\n  searchParams: { enumerable: true }\x2C\n  hash: { enumerable: true }\x2C\n  toJSON: { enumerable: true }\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
tick,0x7ff8089579cd,233193,0,0x0,3,0x10739e050,0x216c4403adcf,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff808957d1e,233205,0,0x0,3,0x10739e050,0x216c4403adcf,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
tick,0x7ff8088ccc6b,233215,0,0x0,3,0x10739e050,0x216c4403adcf,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-source-info,0x216c29bc8fbe,33,40960,41081,C0O40980C3O40985C9O41019C11O41040C12O41043C15O41050C19O41079,,
code-creation,LazyCompile,10,233299,0x216c29bcbf86,17,isURLInstance node:internal/url:1445:23,0x216c14556598,~
code-source-info,0x216c29bcbf86,33,40837,40934,C0O40857C3O40878C6O40903C12O40925C16O40932,,
code-creation,LazyCompile,10,233382,0x216c29bcc0f6,81, node:internal/fs/utils:667:38,0x216c4dfa09c0,~
code-source-info,0x216c29bcc0f6,77,18121,18391,C14O18154C22O18187C25O18187C31O18213C36O18244C49O18219C54O18213C55O18309C68O18309C74O18346C76O18375C78O18375C80O18390,,
code-creation,LazyCompile,10,233459,0x216c29bcc316,110, node:internal/fs/utils:356:35,0x216c4dfa0038,~
code-source-info,0x216c29bcc316,77,8549,9138,C16O8613C21O8666C26O8666C31O8760C37O8783C41O8811C45O8828C51O8828C60O8879C64O8900C69O8900C76O8945C77O8952C78O8972C94O8972C100O9086C104O9108C106O9108C107O9125C109O9136,,
code-creation,LazyCompile,10,233519,0x216c29bcc49e,16,isUint8Array node:internal/util/types:13:22,0x216cb0d16d28,~
script-source,15,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0x216c29bcc49e,15,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,233856,0x216c29bcc926,61,splitRoot node:fs:2352:33,0x216c4df97f68,~
code-source-info,0x216c29bcc926,76,62544,62736,C0O62569C2O62580C6O62574C11O62601C16O62605C24O62643C26O62639C31O62671C44O62678C49O62710C50O62590C55O62556C58O62721C60O62732,,
tick,0x7ff808828c5c,233935,0,0x0,3,0x10739e050,0x216c4403ae4d,0x216c4403a9c9,0x216c4403a291,0x216c44039f74,0x216c44039b1f,0x216c7df78d19
code-creation,LazyCompile,10,233976,0x216c29bcca6e,20,nextPart node:fs:2385:31,0x216c4df98008,~
code-source-info,0x216c29bcca6e,76,63451,63509,C0O63464C14O63471C19O63505,,
code-creation,LazyCompile,10,234094,0x216c29bccb9e,63,handleErrorFromBinding node:internal/fs/utils:339:32,0x216c4df9ffe8,~
code-source-info,0x216c29bccb9e,77,7910,8408,C0O7928C6O7991C11O7991C16O8013C24O8013C29O8070C31O8070C32O8095C38O8323C43O8350C51O8323C56O8396C60O8386C62O8407,,
code-creation,LazyCompile,10,234157,0x216c29bcccfe,34,isFileType node:fs:202:20,0x216c4df95c48,~
code-source-info,0x216c29bcccfe,76,5240,5481,C0O5374C2O5379C6O5386C10O5420C15O5427C20O5443C22O5458C24O5456C30O5466C33O5479,,
code-creation,LazyCompile,10,234372,0x216c29bcd03e,72,encodeRealpathResult node:fs:2361:30,0x216c4df97fb8,~
code-source-info,0x216c29bcd03e,76,62770,63028,C0O62792C4O62817C10O62837C17O62846C22O62862C24O62876C25O62896C30O62903C35O62903C41O62931C48O62940C53O62960C55O62976C56O62999C61O63016C66O62999C71O63026,,
code-creation,LazyCompile,10,234481,0x216c29bcd1fe,109,shouldUseESMLoader node:internal/modules/run_main:26:28,0x216c44038a78,~
code-source-info,0x216c29bcd1fe,122,739,1299,C0O773C8O773C13O816C15O836C16O848C17O891C25O891C30O948C32O980C37O996C38O1008C39O1056C45O1072C51O1072C58O1119C59O1131C60O1134C66O1151C72O1151C79O1198C80O1211C81O1226C86O1226C91O1256C93O1274C98O1279C105O1284C108O1297,,
code-creation,LazyCompile,10,234577,0x216c29bcd42e,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x216c4400f318,~
code-source-info,0x216c29bcd42e,107,8919,9437,C0O8962C7O8996C10O8962C16O9008C18O9035C25O9090C28O9052C34O9100C47O9112C54O9168C61O9207C66O9211C70O9172C77O9236C78O9249C79O9268C84O9292C86O9290C90O9268C95O9302C97O9313C104O9334C110O9353C116O9370C117O9397C119O9397C124O9026C127O9422C128O9435,,
code-creation,LazyCompile,10,234705,0x216c29bcd78e,234,readPackage node:internal/modules/cjs/loader:290:21,0x216c4400f2c8,~
code-source-info,0x216c29bcd78e,107,8102,8892,C0O8137C5O8142C13O8142C20O8200C25O8217C30O8217C36O8234C38O8262C40O8278C41O8297C46O8315C51O8315C57O8353C63O8366C72O8392C77O8402C79O8432C84O8449C91O8449C97O8475C98O8488C102O8521C107O8521C112O8559C117O8580C125O8605C133O8633C141O8664C149O8692C160O8708C165O8725C170O8725C176O8754C178O8770C190O8791C195O8798C199O8814C207O8843C213O8854C220O8865C224O8861C227O8824C231O8878C233O8878,,
code-creation,LazyCompile,10,234838,0x216c29bcdaa6,199,read node:internal/modules/package_json_reader:16:14,0x216c44014f58,~
code-source-info,0x216c29bcdaa6,108,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,235138,0x216c29bce3ce,71,runMainESM node:internal/modules/run_main:43:20,0x216c44038ac8,~
tick,0x7ff8088ccc2d,235208,0,0x0,3,0x10739e050,0x216c44039b38,0x216c7df78d19
code-source-info,0x216c29bce3ce,122,1320,1636,C0O1320C12O1353C20O1353C25O1421C33O1421C38O1403C44O1448C49O1476C59O1476C65O1448C70O1635,,
code-creation,LazyCompile,10,235291,0x216c29bce60e,222,loadESM node:internal/process/esm_loader:65:41,0x216c44015a70,~
code-source-info,0x216c29bce60e,109,2011,2324,C10O2011C21O2036C24O2042C35O2036C58O2066C60O2081C63O2072C75O2066C113O2115C120O2119C125O2166C130O2174C138O2174C143O2202C154O2209C155O2220C163O2220C168O2245C178O2246C197O2323,,
code-creation,LazyCompile,10,235399,0x216c29bcec2e,172,initializeLoader node:internal/process/esm_loader:40:32,0x216c44015900,~
code-source-info,0x216c29bcec2e,109,1233,1969,C0O1233C25O1267C33O1267C38O1248C43O1317C46O1317C50O1317C52O1360C56O1381C67O1388C68O1395C69O1395C74O1412C79O1426C84O1426C91O1432C94O1416C100O1455C102O1459C104O1634C112O1634C117O1606C122O1662C125O1662C129O1714C134O1964C147O1967,,
code-creation,LazyCompile,10,235590,0x216c29bcee16,205, node:internal/process/esm_loader:55:11,0x216c29bceb28,~
code-source-info,0x216c29bcee16,109,1722,1963,C10O1722C18O1762C25O1778C32O1785C39O1797C44O1811C47O1797C52O1815C57O1784C71O1762C97O1827C104O1839C114O1837C122O1857C129O1867C134O1867C139O1884C146O1894C151O1894C155O1922C164O1949C167O1947C180O1959,,
code-creation,LazyCompile,10,235685,0x216c29bcf10e,170,handleMainPromise node:internal/modules/run_main:53:33,0x216c44038b18,~
code-source-info,0x216c29bcf10e,122,1670,2105,C10O1670C23O1989C26O1997C34O1997C43O2030C53O2037C90O2070C93O2078C101O2078C145O2104,,
code-creation,LazyCompile,10,235776,0x216c29bcf2fe,55, node:internal/modules/run_main:46:39,0x216c29bce2f8,~
code-source-info,0x216c29bcf2fe,122,1484,1631,C0O1518C7O1523C15O1523C24O1552C30O1552C35O1575C44O1614C49O1620C54O1627,,
code-creation,LazyCompile,10,235885,0x216c29bcf566,283,pathToFileURL node:internal/url:1408:23,0x216c14556528,~
code-source-info,0x216c29bcf566,33,39584,40813,C0O39614C10O39614C16O39636C24O39653C30O39653C37O39766C45O39766C51O39818C58O39825C63O39839C79O39845C84O39839C85O39982C87O39987C91O40009C97O40016C102O40031C118O40037C123O40031C124O40152C127O40170C131O40168C135O40199C140O40240C145O40259C151O40259C160O40240C166O40217C170O40215C176O40327C181O40332C186O40332C192O40445C197O40541C201O40548C205O40445C211O40558C213O40580C215O40576C222O40612C228O40642C230O40638C235O40693C239O40700C242O40683C248O40709C251O40714C255O40705C260O40725C269O40746C272O40764C276O40762C280O40797C282O40811,,
code-creation,LazyCompile,10,235987,0x216c29bcf846,105,URL node:internal/url:604:14,0x216c14555420,~
code-source-info,0x216c29bcf846,33,17430,17765,C0O17484C5O17512C7O17530C11O17562C18O17577C28O17591C30O17590C34O17611C38O17616C45O17631C48O17627C53O17625C57O17649C73O17701C81O17701C98O17649C104O17764,,
code-creation,LazyCompile,10,236048,0x216c29bcfa16,51,URLContext node:internal/url:143:14,0x216c14554bf8,~
code-source-info,0x216c29bcfa16,33,3684,3896,C0O3693C1O3704C5O3713C7O3725C11O3736C13O3750C17O3760C19O3774C23O3784C24O3794C28O3806C29O3816C33O3828C35O3838C39O3848C40O3859C44O3871C45O3885C50O3895,,
code-creation,LazyCompile,10,236193,0x216c29bcfc6e,190,onParseComplete node:internal/url:516:25,0x216c14555150,~
code-source-info,0x216c29bcfc6e,33,14636,15305,C0O14750C2O14755C4O14754C8O14767C10O14777C14O14788C16O14799C20O14813C22O14837C24O14835C29O14861C43O14826C47O14886C49O14910C51O14908C56O14934C70O14899C74O14959C76O14968C80O14978C82O14998C84O14996C89O15018C101O15026C103O14987C107O15039C109O15049C113O15060C115O15073C119O15087C121O15096C125O15106C127O15116C129O15115C134O15169C136O15174C141O15194C144O15190C149O15188C153O15217C155O15222C157O15221C163O15236C168O15245C172O15259C177O15281C179O15280C183O15259C189O15304,,
code-creation,LazyCompile,10,236392,0x216c29bd00d6,881,URLSearchParams node:internal/url:161:14,0x216c14554c48,~
tick,0x7ff808957f4f,236492,0,0x0,3,0x1073aea10,0x216c29bcfcfe,0x106d888d0,0x216c29bcf8a8,0x216c29bcf570,0x216c29bcf31c,0x216c29bce64d,0x1076ecbbf
code-source-info,0x216c29bd00d6,33,4197,6594,C10O4222C16O4271C18O4276C24O4290C30O4307C42O4390C44O4395C46O4394C50O4418C52O4438C54O4437C57O4429C62O4636C64O4641C66O4640C71O4664C73O4669C77O4697C83O4697C87O4683C93O4719C101O4774C107O4820C119O4826C124O4820C125O5020C128O5051C156O5043C187O5043C190O5069C208O5190C210O5189C217O5236C233O5242C238O5236C239O5345C243O5381C271O5370C302O5370C305O5399C315O5433C321O5399C329O5359C405O5466C411O5466C416O5032C490O5527C492O5532C498O5546C502O5579C530O5571C561O5571C564O5607C572O5614C577O5635C593O5641C598O5635C599O5722C607O5746C609O5745C615O5765C622O5774C627O5722C632O5560C705O5918C707O5923C713O5937C717O5964C723O5964C728O6007C730O6019C734O6012C739O6056C741O6060C745O6088C751O6088C757O6142C759O6173C765O6216C769O6216C774O6265C780O6281C785O6265C790O6301C792O6306C794O6305C799O6320C805O6320C811O6028C816O5994C821O6416C825O6423C830O6448C831O6456C838O6460C843O6481C853O6481C859O6497C863O6497C868O6569C870O6574C875O6583C880O6593,,
code-creation,LazyCompile,10,236622,0x216c29bd06b6,35,initSearchParams node:internal/url:969:26,0x216c14556088,~
code-source-info,0x216c29bd06b6,33,26588,26703,C0O26604C4O26621C6O26625C11O26639C15O26649C16O26656C17O26663C19O26667C25O26683C29O26681C34O26702,,
code-creation,LazyCompile,10,236725,0x216c29bd0876,199,encodePathChars node:internal/url:1393:25,0x216c145564d8,~
code-source-info,0x216c29bd0876,33,38868,39560,C0O38883C8O38887C15O38931C22O38975C31O38942C38O39055C46O39073C52O39073C59O39118C66O39162C75O39129C82O39188C90O39192C97O39237C104O39281C113O39248C120O39305C128O39309C135O39354C142O39398C151O39365C158O39429C166O39433C173O39478C180O39522C189O39489C196O39542C198O39558,,
code-creation,LazyCompile,10,236812,0x216c29bd0ab6,70,set pathname node:internal/url:868:15,0x216c14555d58,~
code-source-info,0x216c29bd0ab6,33,24054,24256,C0O24101C5O24123C9O24132C11O24131C16O24153C17O24160C18O24165C29O24177C38O24200C40O24199C49O24240C54O24240C63O24165C69O24255,,
code-creation,LazyCompile,10,236865,0x216c29bd0c16,31, node:internal/url:620:21,0x216c145554f8,~
code-source-info,0x216c29bd0c16,33,17872,17947,C0O17881C4O17894C6O17893C10O17903C19O17911C21O17909C26O17937C30O17943,,
code-creation,LazyCompile,10,236944,0x216c29bd0d56,108,onParsePathComplete node:internal/url:575:29,0x216c14555330,~
code-source-info,0x216c29bd0d56,33,16595,17061,C0O16713C2O16718C4O16717C8O16730C10O16743C12O16741C17O16763C22O16776C24O16785C28O16797C35O16810C40O16807C46O16845C48O16854C52O16864C59O16878C61O16877C66O16874C70O16956C72O16969C74O16967C79O16989C84O17002C86O17011C90O17023C97O17036C102O17033C107O17060,,
code-creation,LazyCompile,10,237012,0x216c29bd0f06,18,get href node:internal/url:718:11,0x216c14555688,~
code-source-info,0x216c29bd0f06,33,20537,20575,C0O20546C4O20558C6O20557C12O20566C17O20571,,
code-creation,LazyCompile,10,237126,0x216c29bd11e6,393, node:internal/url:666:12,0x216c145555e8,~
code-source-info,0x216c29bd11e6,33,19172,20422,C0O19188C4O19207C14O19207C19O19248C30O19351C37O19382C41O19387C43O19386C47O19467C52O19487C58O19510C67O19554C74O19563C79O19602C86O19611C91O19637C99O19646C103O19662C105O19687C109O19726C120O19744C124O19772C127O19787C142O19807C151O19848C165O19886C170O19866C176O19898C184O19918C190O19941C193O19956C208O19974C212O19983C214O19982C219O20017C225O20021C237O20053C243O20074C248O20079C255O20086C260O20097C266O20101C272O20105C277O20123C286O20158C291O20163C297O20181C304O20194C307O20217C315O20194C320O20192C330O20259C336O20273C342O20295C345O20310C360O20335C366O20351C372O20376C375O20391C390O20407C392O20418,,
code-creation,LazyCompile,10,237250,0x216c29bd157e,103, node:internal/validators:144:3,0x216cb0d19ee8,~
code-source-info,0x216c29bd157e,17,4197,4570,C10O4197C16O4217C24O4239C32O4263C40O4305C50O4352C54O4366C57O4366C71O4441C79O4506C95O4512C100O4506C102O4569,,
code-creation,LazyCompile,10,237340,0x216c29bd1766,152,import node:internal/modules/esm/loader:176:15,0x216c44016a38,~
code-source-info,0x216c29bd1766,110,5914,6073,C10O5914C18O5963C23O5963C37O5952C63O6029C68O6029C80O6019C103O6008C108O6054C113O6054C127O6069,,
code-creation,LazyCompile,10,237432,0x216c29bd19be,317,getModuleJob node:internal/modules/esm/loader:241:21,0x216c44016b28,~
code-source-info,0x216c29bd19be,110,7868,8640,C10O7868C18O7920C23O7920C37O7909C63O7981C68O7981C81O7970C107O8016C112O8026C117O8026C123O8100C127O8142C132O8152C137O8167C141O8152C147O8179C151O8208C163O8219C164O8225C169O8242C174O8242C181O8261C188O8267C193O8261C194O8334C199O8346C204O8346C210O8383C217O8425C224O8441C230O8441C235O8478C258O8484C264O8596C269O8606C274O8606C280O8625C292O8636,,
tick,0x107104110,238023,0,0x0,3,0x10739e050,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-creation,LazyCompile,10,238063,0x216c29bd1dae,238,resolve node:internal/modules/esm/loader:84:16,0x216c44016948,~
code-source-info,0x216c29bd1dae,110,3200,3907,C10O3200C18O3244C22O3273C32O3322C35O3322C41O3354C59O3360C64O3354C65O3469C70O3485C77O3498C83O3521C91O3543C100O3469C113O3458C139O3564C145O3613C161O3619C166O3613C167O3722C172O3751C176O3788C195O3794C200O3788C201O3892C213O3903,,
code-creation,LazyCompile,10,238532,0x216c29bd233e,885,defaultResolve node:internal/modules/esm/resolve:804:24,0x216c4401c5d8,~
code-source-info,0x216c29bd233e,113,27657,30940,C7O27657C16O27715C21O27726C26O27752C32O27769C38O27775C47O27811C53O27818C59O27827C65O27827C71O27863C73O27894C78O27903C84O27953C86O27976C92O27972C99O27953C106O28018C109O28030C110O28046C115O28066C120O28096C124O28148C130O28162C138O28176C144O28183C145O28198C149O28221C151O28234C157O28319C163O28342C170O28319C185O28230C192O28221C196O28397C201O28417C209O28426C215O28461C223O28470C228O28491C236O28513C242O28531C249O28553C253O28574C261O28583C266O28600C274O28614C280O28626C281O28629C285O28650C293O28659C298O28681C306O28690C311O28707C319O28713C324O28707C325O28759C331O28776C337O28776C344O28815C356O28843C365O28861C366O28868C372O28885C380O28885C387O28986C401O28986C406O29039C410O29066C412O29084C422O29121C428O29121C442O29096C448O29130C453O29542C459O29562C465O29568C470O29562C471O29609C475O29622C480O29658C485O29675C498O29681C508O29679C519O29849C523O29859C531O29864C540O29908C548O29913C553O29955C565O29959C572O30018C580O30030C585O30084C591O30084C597O30131C599O30233C611O30260C621O30233C627O30295C633O30321C645O30339C653O30363C657O30363C665O30390C672O30397C679O30414C688O30433C696O30433C701O30421C704O30351C708O30474C724O30496C731O30488C735O30522C737O30522C738O30542C744O30556C751O30580C756O30620C762O30620C767O30657C773O30670C781O30688C785O30699C793O30718C800O30657C806O30756C809O30765C817O30800C823O30833C827O30800C843O30797C848O30771C853O30873C857O30867C861O30900C865O30894C869O30913C877O30930C884O30938,,
code-creation,LazyCompile,10,238760,0x216c29bd4626,15,get protocol node:internal/url:753:15,0x216c145557c8,~
tick,0x7ff808957f54,238876,0,0x0,3,0x10739e050,0x216c29bd2415,0x216c29bd1e12,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-source-info,0x216c29bd4626,33,21375,21416,C0O21384C4O21396C6O21395C10O21405C14O21412,,
code-creation,LazyCompile,10,238950,0x216c29bd4736,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x216c014cf628,~
code-source-info,0x216c29bd4736,9,7353,7449,C0O7376C5O7389C10O7393C15O7393C21O7406C23O7424C27O7445,,
code-creation,LazyCompile,10,239181,0x216c29bd489e,64,getConditionsSet node:internal/modules/esm/resolve:107:26,0x216c4401bd68,~
code-source-info,0x216c29bd489e,113,3655,3982,C0O3672C6O3719C8O3715C13O3745C18O3750C24O3784C40O3790C45O3784C46O3912C53O3919C58O3943C59O3950C63O3980,,
code-creation,LazyCompile,10,239286,0x216c29bd49f6,116,moduleResolve node:internal/modules/esm/resolve:741:23,0x216c4401c538,~
code-source-info,0x216c29bd49f6,113,25529,26078,C0O25667C2O25679C5O25683C11O25741C24O25752C32O25787C33O25800C39O25804C44O25819C56O25835C62O25822C72O25915C79O25926C88O25924C89O25966C101O25977C107O26034C110O26041C115O26076,,
code-creation,LazyCompile,10,239407,0x216c29bd4b8e,31,shouldBeTreatedAsRelativeOrAbsolutePath node:internal/modules/esm/resolve:729:49,0x216c4401c4e8,~
code-source-info,0x216c29bd4b8e,113,25259,25394,C0O25275C2O25289C7O25297C8O25310C9O25313C10O25326C16O25330C21O25339C22O25351C23O25354C26O25361C30O25392,,
code-creation,LazyCompile,10,239482,0x216c29bd4cb6,81,isRelativeSpecifier node:internal/modules/esm/resolve:719:29,0x216c4401c498,~
code-source-info,0x216c29bd4cb6,113,24966,25209,C0O24982C1O24995C7O24999C12O25028C19O25035C26O25053C32O25057C37O25066C38O25078C39O25083C41O25096C47O25100C52O25131C59O25138C66O25156C72O25160C77O25169C78O25181C79O25194C80O25207,,
code-creation,LazyCompile,10,239683,0x216c29bd4ef6,341,finalizeResolution node:internal/modules/esm/resolve:294:28,0x216c4401bfe8,~
code-source-info,0x216c29bd4ef6,113,9915,11113,C0O9936C7O9960C10O9986C15O9940C22O10001C27O10056C37O10123C40O10123C47O10007C52O10001C53O10161C58O10161C63O10188C71O10192C78O10246C83O10275C86O10275C91O10324C93O10348C95O10360C96O10365C104O10370C111O10414C116O10447C121O10454C131O10443C137O10421C142O10475C144O10499C146O10511C149O10531C152O10538C160O10582C161O10593C166O10640C173O10650C176O10650C186O10599C191O10593C192O10703C199O10715C205O10715C214O10756C220O10756C230O10703C235O10808C240O10808C246O10841C253O10878C256O10878C266O10841C272O10904C274O10914C277O10914C281O10912C285O10936C287O10936C288O10967C293O10967C299O10983C306O11021C308O11038C315O11048C319O11056C322O11056C332O10989C337O10983C338O11095C340O11111,,
code-creation,LazyCompile,10,239818,0x216c29bd5246,78,get pathname node:internal/url:859:15,0x216c14555ce8,~
code-source-info,0x216c29bd5246,33,23845,24038,C0O23866C4O23871C6O23870C10O23885C14O23894C16O23893C21O23926C27O23930C30O23934C31O23947C36O23952C42O23959C47O23972C49O23982C50O23987C57O23998C60O24021C68O23998C77O24034,,
tick,0x7ff808922ae6,239953,0,0x0,3,0x10739e050,0x216c29bd4f00,0x216c29bd4a64,0x216c29bd2530,0x216c29bd1e12,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-creation,LazyCompile,10,240427,0x216c29bd54ae,106,fileURLToPath node:internal/url:1366:23,0x216c14556488,~
code-source-info,0x216c29bd54ae,33,37759,38084,C0O37770C6O37804C13O37811C22O37833C25O37838C31O37863C49O37869C54O37863C55O37939C62O37948C67O37965C77O37971C82O37965C83O38009C92O38028C101O38056C105O38082,,
code-creation,LazyCompile,10,240581,0x216c29bd56e6,150,get origin node:internal/url:730:13,0x216c14555758,~
code-source-info,0x216c29bd56e6,33,20800,21359,C0O20882C4O20887C6O20886C10O20913C59O20959C64O20964C70O20971C78O21006C83O21026C89O21030C95O21014C101O21036C105O21043C110O21136C116O21157C117O21263C122O21295C127O21307C132O21317C137O21270C142O21323C143O21334C149O21355,,
code-creation,LazyCompile,10,240699,0x216c29bd595e,136,getPathFromURLPosix node:internal/url:1348:29,0x216c14556438,~
code-source-info,0x216c29bd595e,33,37259,37735,C0O37277C7O37286C12O37300C19O37336C24O37306C29O37300C30O37374C35O37399C37O37415C41O37404C46O37434C48O37446C54O37450C59O37490C66O37504C70O37490C75O37509C79O37523C81O37538C84O37535C90O37543C97O37560C102O37579C112O37585C117O37579C118O37424C123O37386C126O37697C131O37704C135O37733,,
code-creation,LazyCompile,10,240781,0x216c29bd5b4e,19,get hostname node:internal/url:825:15,0x216c14555b38,~
code-source-info,0x216c29bd5b4e,33,23055,23100,C0O23064C4O23076C6O23075C10O23085C18O23096,,
code-creation,LazyCompile,10,240917,0x216c29bd5d9e,30,tryStatSync node:internal/modules/esm/resolve:122:3,0x216c4401c628,~
tick,0x7ff808922ae6,241056,0,0x0,3,0x10739e050,0x216c29bd4fdc,0x216c29bd4a64,0x216c29bd2530,0x216c29bd1e12,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-source-info,0x216c29bd5d9e,113,4115,4181,C0O4170C5O4134C10O4125C21O4174C24O4170C29O4181,,
code-creation,LazyCompile,10,241177,0x216c29bd5f66,123,statSync node:fs:1518:18,0x216c4df970d0,~
code-source-info,0x216c29bd5f66,76,38623,39027,C7O38623C16O38685C21O38692C26O38730C33O38732C40O38756C45O38764C52O38769C55O38780C60O38780C66O38841C76O38764C82O38880C88O38895C96O38908C102O38936C103O38953C104O38960C109O38960C113O38991C118O38998C122O39025,,
code-creation,LazyCompile,10,241263,0x216c29bd6116,37, node:internal/fs/utils:679:42,0x216c4dfa0a10,~
code-source-info,0x216c29bd6116,77,18436,18571,C14O18491C19O18491C24O18525C29O18525C34O18557C36O18569,,
code-creation,LazyCompile,10,241402,0x216c29bd6266,64,hasNoEntryError node:fs:1455:25,0x216c4df96fa0,~
code-source-info,0x216c29bd6266,76,37060,37251,C0O37078C6O37105C11O37121C16O37105C21O37133C27O37147C36O37151C39O37164C40O37180C46O37204C51O37210C58O37215C61O37228C62O37236C63O37249,,
code-creation,LazyCompile,10,241530,0x216c29bd63ae,576,getStatsFromBinding node:internal/fs/utils:529:29,0x216c4dfa07e0,~
code-source-info,0x216c29bd63ae,77,13953,15003,C13O13977C18O13981C24O14012C31O14050C34O14047C43O14069C46O14066C55O14088C58O14085C67O14113C70O14110C79O14132C82O14129C91O14151C94O14148C103O14176C106O14173C115O14195C118O14192C127O14214C130O14211C139O14239C142O14236C154O14286C157O14282C167O14306C170O14302C174O14256C189O14354C192O14350C202O14374C205O14370C210O14324C225O14422C228O14418C239O14442C242O14438C247O14392C263O14490C266O14486C277O14510C280O14506C285O14460C294O14019C299O14527C300O14534C307O14564C310O14561C319O14583C322O14580C331O14602C334O14599C343O14625C346O14622C355O14644C358O14641C367O14663C370O14660C379O14686C382O14683C391O14705C394O14702C403O14724C406O14721C415O14747C418O14744C430O14786C433O14782C443O14806C446O14802C450O14762C465O14846C468O14842C478O14866C481O14862C486O14822C501O14906C504O14902C515O14926C518O14922C523O14882C539O14966C542O14962C553O14986C556O14982C561O14942C570O14541C575O15001,,
code-creation,LazyCompile,10,241658,0x216c29bd67ee,16,isBigUint64Array node:internal/util/types:53:26,0x216cb0d17190,~
code-source-info,0x216c29bd67ee,15,1371,1460,C0O1383C5O1390C12O1437C15O1458,,
code-creation,LazyCompile,10,241717,0x216c29bd68ee,19,msFromTimeSpec node:internal/fs/utils:445:24,0x216c4dfa0508,~
code-source-info,0x216c29bd68ee,77,10986,11045,C0O11002C2O11015C4O11013C10O11034C12O11032C15O11025C18O11043,,
code-creation,LazyCompile,10,241805,0x216c29bd6b3e,116,Stats node:internal/fs/utils:494:15,0x216c4dfa0700,~
code-source-info,0x216c29bd6b3e,77,12729,13257,C0O12866C41O12866C46O12994C48O13007C52O13020C54O13033C58O13046C60O13059C64O13072C66O13089C70O13106C73O13119C77O13117C81O13142C84O13155C88O13153C92O13178C95O13191C99O13189C103O13214C106O13231C110O13229C115O13256,,
code-creation,LazyCompile,10,241884,0x216c29bd6d26,62,StatsBase node:internal/fs/utils:399:19,0x216c4dfa00d8,~
code-source-info,0x216c29bd6d26,77,9893,10182,C0O9979C2O9988C6O9997C8O10007C12O10017C14O10028C18O10039C20O10048C24O10057C26O10066C30O10075C32O10085C36O10095C38O10108C42O10121C44O10130C48O10139C50O10149C54O10159C56O10171C61O10181,,
tick,0x1072eb030,242030,0,0x0,2,0x10739e050,0x216c29bd6b87,0x216c29bd65e8,0x216c29bd5fdc,0x216c29bd5da8,0x216c29bd4fdc,0x216c29bd4a64,0x216c29bd2530,0x216c29bd1e12,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-creation,LazyCompile,10,242068,0x216c29bd6f2e,29,dateFromMs node:internal/fs/utils:459:20,0x216c4dfa05a8,~
code-source-info,0x216c29bd6f2e,77,11498,11543,C0O11507C7O11523C10O11523C17O11534C23O11514C28O11541,,
code-creation,LazyCompile,10,242165,0x216c29bd7046,16,StatsBase.isDirectory node:internal/fs/utils:413:43,0x216c4dfa0128,~
code-source-info,0x216c29bd7046,77,10226,10275,C0O10245C7O10264C10O10245C15O10273,,
code-creation,LazyCompile,10,242226,0x216c29bd716e,54,Stats._checkModeProperty node:internal/fs/utils:516:46,0x216c4dfa0750,~
code-source-info,0x216c29bd716e,77,13606,13828,C0O13621C8O13652C10O13648C17O13676C19O13672C26O13704C28O13700C33O13721C34O13734C35O13798C42O13805C44O13803C50O13813C53O13826,,
code-creation,LazyCompile,10,242299,0x216c29bd72b6,16,StatsBase.isFile node:internal/fs/utils:417:38,0x216c4dfa01b8,~
code-source-info,0x216c29bd72b6,77,10315,10364,C0O10334C7O10353C10O10334C15O10362,,
code-creation,LazyCompile,10,242615,0x216c29bd7556,37,get search node:internal/url:877:13,0x216c14555dc8,~
code-source-info,0x216c29bd7556,33,24270,24396,C0O24297C4O24302C6O24301C10O24287C15O24316C19O24344C24O24358C26O24368C27O24373C32O24384C36O24392,,
code-creation,LazyCompile,10,242709,0x216c29bd76ee,179,set search node:internal/url:884:13,0x216c14555e38,~
code-source-info,0x216c29bd76ee,33,24410,24917,C0O24437C4O24442C6O24441C10O24456C15O24465C21O24490C23O24501C28O24517C29O24527C33O24541C42O24555C44O24554C49O24551C55O24595C56O24605C62O24609C67O24618C77O24627C84O24666C86O24676C90O24688C99O24701C104O24698C108O24728C112O24750C123O24764C132O24797C140O24797C152O24750C157O24868C166O24890C168O24889C172O24868C178O24916,,
code-creation,LazyCompile,10,242790,0x216c29bd78f6,41,toUSVString node:internal/url:118:21,0x216c145537a8,~
code-source-info,0x216c29bd78f6,33,2647,2939,C0O2669C4O2820C11O2840C14O2820C20O2869C22O2885C24O2896C25O2899C30O2930C35O2906C40O2937,,
code-creation,LazyCompile,10,243078,0x216c29bd7a4e,37,get hash node:internal/url:907:11,0x216c14555f18,~
code-source-info,0x216c29bd7a4e,33,25002,25140,C0O25032C4O25037C6O25036C10O25019C15O25051C19O25085C24O25099C26O25109C27O25114C32O25125C36O25136,,
code-creation,LazyCompile,10,243176,0x216c29bd7bd6,144,set hash node:internal/url:914:11,0x216c14555f80,~
code-source-info,0x216c29bd7bd6,33,25152,25585,C0O25177C4O25182C6O25181C10O25230C15O25252C17O25271C18O25284C22O25298C31O25312C33O25311C38O25308C42O25342C43O25349C44O25360C45O25368C51O25372C56O25381C66O25388C73O25423C75O25436C79O25446C88O25459C93O25456C97O25487C108O25499C117O25531C125O25531C137O25487C143O25584,,
tick,0x7ff80877943a,243506,0,0x0,2,0x10739e050,0x216c29bd26ab,0x216c29bd1e12,0x216c29bd19d5,0x216c29bd177d,0x216c29bcf32f,0x216c29bce64d,0x1076ecbbf
code-creation,LazyCompile,10,243546,0x216c29bd7d96,18,toString node:internal/url:714:11,0x216c14555638,~
code-source-info,0x216c29bd7d96,33,20487,20525,C0O20496C4O20508C6O20507C12O20516C17O20521,,
code-creation,LazyCompile,10,243717,0x216c29bd8076,384,getFormat node:internal/modules/esm/loader:104:18,0x216c44016998,~
code-source-info,0x216c29bd8076,110,3926,5219,C10O3926C18O3975C23O3993C27O4002C36O3975C49O3964C75O4025C81O4076C97O4082C102O4076C103O4189C108O4223C110O4268C120O4268C126O4371C136O4432C143O4482C163O4377C168O4371C169O4506C175O4546C194O4552C199O4546C200O4659C202O4670C207O4693C219O4707C220O4728C227O4741C229O4737C237O4779C244O4779C253O4817C272O4823C277O4817C278O4941C285O4954C287O4950C294O4979C300O4979C309O5029C315O5029C322O5083C341O5089C346O5083C347O5201C359O5215,,
code-creation,LazyCompile,10,243877,0x216c29bd8676,312,defaultGetFormat node:internal/modules/esm/get_format:39:26,0x216c4401f6c0,~
code-source-info,0x216c29bd8676,114,1157,2443,C0O1200C8O1204C15O1251C19O1280C20O1302C27O1302C33O1329C40O1338C45O1377C55O1458C60O1377C72O1368C79O1508C86O1597C101O1664C116O1710C123O1730C130O1739C136O1748C137O1769C144O1778C149O1809C154O1824C159O1809C164O1843C166O1855C168O1863C173O1882C178O1913C183O1891C190O1919C204O1976C211O2003C215O2020C219O2041C226O2077C231O2099C234O2107C245O2107C251O2232C258O2265C264O2295C271O2337C274O2337C284O2301C289O2295C290O2376C297O2393C306O2410C307O2417C311O2441,,
code-creation,LazyCompile,10,244041,0x216c29bd8c86,211,extname node:path:1385:10,0x216c14563b90,~
code-source-info,0x216c29bd8c86,35,41977,43660,C0O41990C8O41990C13O42039C16O42063C18O42080C21O42107C23O42253C25O42278C29O42285C33O42292C34O42292C39O42324C44O42324C50O42366C52O42379C54O42375C59O42543C63O42574C65O42588C69O42603C71O42628C73O42652C75O42660C80O42775C82O42805C84O42813C88O42832C90O42845C92O42841C97O42940C99O42953C104O42971C111O42998C113O43014C118O43031C123O43061C125O43074C130O43234C133O42300C138O42260C141O43271C143O43284C150O43306C156O43401C163O43498C170O43533C173O43525C180O43572C183O43558C188O43586C190O43596C191O43607C205O43614C210O43656,,
code-creation,LazyCompile,10,244165,0x216c29bd8ec6,13,getPackageType node:internal/modules/esm/resolve:618:24,0x216c4401c358,~
code-source-info,0x216c29bd8ec6,113,21597,21687,C0O21629C3O21629C8O21680C12O21685,,
code-creation,LazyCompile,10,244255,0x216c29bd912e,173,getPackageScopeConfig node:internal/modules/esm/resolve:176:31,0x216c4401be08,~
code-source-info,0x216c29bd912e,113,5554,6624,C0O5590C13O5590C19O5687C24O5701C32O5705C39O5782C41O5815C46O5832C49O5832C54O5815C60O5939C66O5947C68O5968C69O6001C72O6021C85O6038C91O6243C96O6275C100O6252C105O6285C107O5629C110O6322C115O6322C120O6377C127O6394C132O6440C137O6461C142O6503C147O6527C154O6545C159O6562C164O6562C170O6601C172O6622,,
code-creation,LazyCompile,10,244448,0x216c29bd954e,331,getPackageConfig node:internal/modules/esm/resolve:124:26,0x216c4401bdb8,~
code-source-info,0x216c29bd954e,113,4209,5522,C0O4254C5O4271C10O4271C16O4284C18O4318C20O4334C21O4356C26O4374C31O4374C37O4384C42O4395C44O4449C51O4468C56O4507C61O4530C66O4576C71O4602C78O4624C83O4641C88O4641C94O4671C96O4692C97O4704C102O4729C107O4743C115O4741C125O4786C137O4843C144O4854C163O4881C168O4895C174O4881C178O4879C185O4927C192O4792C197O4786C198O4955C203O4964C208O4970C213O4976C218O5008C223O5035C233O5088C235O5111C241O5141C243O5161C249O5191C251O5264C253O5273C260O5294C265O5310C268O5350C275O5367C281O5395C287O5405C293O5415C299O5425C305O5438C312O5454C317O5471C322O5471C328O5499C330O5520,,
tick,0x7ff808839c0b,244717,0,0x0,3,0x10739e050,0x216c29bd9164,0x216c29bd8ec9,0x216c29bd872d,0x216c29bd809a,0x216c29bd1a02,0x1076ecbbf
code-creation,LazyCompile,10,244902,0x216c29bd9cfe,34,get node:internal/modules/esm/module_map:16:6,0x216c44017ee8,~
code-source-info,0x216c29bd9cfe,111,499,569,C0O511C10O511C15O543C17O556C28O556C33O565,,
code-creation,LazyCompile,10,245042,0x216c29bd9f8e,150,ModuleJob node:internal/modules/esm/module_job:55:14,0x216c44018d20,~
code-source-info,0x216c29bd9f8e,112,1296,2977,C0O1296C13O1352C18O1364C22O1378C27O1390C31O1404C36O1420C40O1439C44O1451C48O1586C55O1607C58O1636C67O1645C76O1650C89O1607C94O1605C98O1754C103O2661C106O2675C109O2673C113O2782C123O2809C132O2817C135O2782C140O2943C144O2961C149O2976,,
code-creation,LazyCompile,10,245196,0x216c29bdaa46,301,moduleStrategy node:internal/modules/esm/translators:137:56,0x216c4402e878,~
code-source-info,0x216c29bdaa46,119,3897,4449,C10O3897C18O3935C23O3951C30O3978C39O3935C52O3924C75O3913C80O3999C91O3999C96O4073C101O4095C108O4105C114O4130C123O4073C136O4062C159O4051C164O4158C167O4167C172O4188C177O4188C182O4224C192O4260C197O4224C201O4285C220O4285C226O4333C231O4344C236O4356C241O4360C248O4374C254O4400C258O4356C264O4433C276O4447,,
code-creation,LazyCompile,10,245326,0x216c29bdba5e,349,defaultGetSource node:internal/modules/esm/get_source:25:32,0x216c440201a8,~
code-source-info,0x216c29bdba5e,115,662,1307,C10O662C31O670C70O722C77O722C83O742C85O763C92O772C97O791C102O806C114O800C144O849C151O858C156O891C163O911C166O936C171O891C177O951C179O971C186O977C191O971C192O1024C199O1035C206O1055C211O1071C218O1076C221O1076C228O1102C237O1071C246O1146C258O1152C263O1146C264O1204C271O1214C280O1232C285O1239C290O1248C295O1248C301O1287C308O1296C324O1305,,
code-creation,LazyCompile,10,245493,0x216c29bdbf6e,196,readFile node:internal/fs/promises:733:24,0x216c44022240,~
code-source-info,0x216c29bdbf6e,116,20699,21034,C10O20699C18O20719C23O20740C28O20729C35O20788C44O20804C46O20824C48O20813C53O20840C56O20847C71O20877C72O20881C75O20902C80O20881C84O20925C98O20931C111O20925C137O20958C145O20993C151O21025C156O20965C171O21032,,
code-creation,LazyCompile,10,245562,0x216c29bddaf6,29,checkAborted node:internal/fs/promises:273:22,0x216c440215c0,~
code-source-info,0x216c29bddaf6,116,6018,6081,C0O6031C7O6041C16O6056C21O6062C26O6056C28O6080,,
code-creation,LazyCompile,10,245628,0x216c29bddc9e,182,open node:internal/fs/promises:396:20,0x216c44021750,~
code-source-info,0x216c29bddc9e,116,9900,10206,C10O9900C18O9924C23O9931C29O9977C34O9977C39O10001C55O10008C62O10046C69O10079C72O10087C79O10102C82O10113C87O10113C95O10189C104O10087C117O10073C142O10053C157O10204,,
tick,0x107109856,245823,0,0x0,3,0x10739e050,0x216c29bddcc0,0x216c29bdbfd0,0x216c29bdbac4,0x216c29bdaa6d,0x216c29bd9fe7,0x216c29bd1ac0,0x1076ecbbf
code-creation,LazyCompile,10,245839,0x216c29bde236,515,stringToFlags node:internal/fs/utils:554:23,0x216c4dfa0830,~
code-source-info,0x216c29bde236,77,15027,16261,C14O15055C20O15092C25O15092C30O15124C32O15137C33O15145C38O15170C42O15186C43O15194C202O15226C206O15242C207O15292C214O15310C216O15308C219O15317C220O15334C224O15348C225O15400C232O15416C234O15414C237O15423C238O15440C245O15457C247O15455C253O15467C255O15465C258O15476C259O15526C266O15543C268O15541C274O15553C276O15551C282O15564C284O15562C287O15571C288O15589C295O15606C297O15604C303O15616C305O15614C308O15623C309O15673C316O15690C318O15688C324O15700C326O15698C332O15709C334O15707C337O15716C338O15733C345O15751C347O15749C353O15761C355O15759C358O15770C359O15820C366O15838C368O15836C374O15848C376O15846C382O15859C384O15857C387O15866C388O15916C395O15934C397O15932C403O15944C405O15942C411O15955C413O15953C416O15962C417O15980C424O15998C426O15996C432O16008C434O16006C437O16015C438O16065C445O16083C447O16081C453O16093C455O16091C461O16102C463O16100C466O16109C467O16159C474O16177C476O16175C482O16187C484O16185C490O16196C492O16194C495O16203C496O16211C509O16217C514O16211,,
code-creation,LazyCompile,10,245983,0x216c29bde636,97,parseFileMode node:internal/validators:58:23,0x216cb0d19c08,~
code-source-info,0x216c29bde636,17,1468,1764,C0O1491C11O1508C17O1545C24O1570C27O1550C34O1596C41O1641C52O1602C57O1596C58O1662C66O1670C73O1703C89O1703C94O1749C96O1762,,
code-creation,LazyCompile,10,246064,0x216c29bde816,206, node:internal/validators:83:3,0x216cb0d19cc8,~
code-source-info,0x216c29bde816,17,2236,2817,C36O2377C39O2382C45O2406C51O2447C67O2453C72O2447C73O2516C78O2521C84O2555C100O2561C105O2555C106O2624C116O2663C129O2676C142O2630C147O2624C148O2701C150O2711C157O2726C162O2741C172O2780C185O2793C198O2747C203O2741C205O2816,,
code-creation,LazyCompile,10,246122,0x216c29bde9ee,9,isInt32 node:internal/validators:35:17,0x216cb0d19810,~
code-source-info,0x216c29bde9ee,17,715,758,C0O727C2O751C5O740C8O756,,
code-creation,LazyCompile,10,246513,0x216c29bdec9e,263,link node:internal/modules/esm/module_job:66:18,0x216c29bd9e10,~
code-source-info,0x216c29bdec9e,112,1754,2604,C4O1754C26O1774C36O1799C48O1788C73O1786C77O1820C89O1832C98O1850C100O1839C104O1820C108O2166C110O2166C112O2193C117O2198C122O2205C132O2205C138O2447C140O2483C151O2504C156O2500C162O2489C174O2483C199O2541C210O2563C218O2559C224O2548C238O2598,,
code-creation,LazyCompile,10,246587,0x216c29bdef36,19,primordials.PromisePrototypeCatch node:internal/per_context/primordials:397:37,0x216c014ca250,~
code-source-info,0x216c29bdef36,6,11446,11533,C0O11477C13O11477C18O11533,,
code-creation,LazyCompile,10,246662,0x216c29bdf0b6,110,set node:internal/modules/esm/module_map:20:6,0x216c44017f38,~
code-source-info,0x216c29bdf0b6,111,575,848,C0O592C10O592C15O624C19O643C21O632C26O653C37O708C55O714C60O708C61O775C73O792C84O775C88O817C90O830C104O830C109O844,,
code-creation,LazyCompile,10,246731,0x216c29bdf23e,104,logger node:internal/util/debuglog:96:18,0x216c14575258,~
code-source-info,0x216c29bdf23e,40,2899,3124,C0O2899C3O2931C30O2955C35O2962C38O2970C39O2985C45O3002C49O2992C53O3007C54O3022C60O3039C66O3048C70O3029C75O3053C76O3069C80O3076C87O3089C92O3085C98O3076C103O3114,,
code-creation,LazyCompile,10,246802,0x216c29bdf3ce,155,debug node:internal/util/debuglog:76:15,0x216c145751b8,~
code-source-info,0x216c29bdf3ce,40,2357,2781,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C81O2612C86O2619C89O2627C90O2642C96O2659C100O2649C104O2664C105O2679C111O2696C117O2705C121O2686C126O2710C127O2726C131O2733C138O2746C143O2742C149O2733C154O2771,,
code-creation,LazyCompile,10,246865,0x216c29bdf5ae,41,init node:internal/util/debuglog:72:16,0x216c14575168,~
code-source-info,0x216c29bdf5ae,40,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,246912,0x216c29bdf6ae,2,testEnabled node:internal/util/debuglog:32:19,0x216c1594f7e8,~
code-source-info,0x216c29bdf6ae,40,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,247006,0x216c29bdf856,116,debuglogImpl node:internal/util/debuglog:49:22,0x216c14574fa0,~
code-source-info,0x216c29bdf856,40,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
tick,0x1076c5732,247104,0,0x0,0,0x216c29bdf8b9,0x216c29bdf3e4,0x216c29bdf26f,0x216c29bdf10a,0x216c29bd1ad0,0x1076ecbbf
code-creation,LazyCompile,10,247140,0x216c29bdfa1e,10, node:internal/modules/esm/module_map:7:63,0x216c44017e48,~
code-source-info,0x216c29bdfa1e,111,175,200,C0O187C2O193C9O199,,
code-creation,LazyCompile,10,247179,0x216c29bdfade,2,noop node:internal/util/debuglog:47:14,0x216c14574f50,~
code-source-info,0x216c29bdfade,40,1419,1427,C1O1426,,
code-creation,LazyCompile,10,247292,0x216c29bdff0e,433,run node:internal/modules/esm/module_job:178:12,0x216c44018e10,~
code-source-info,0x216c29bdff0e,112,6423,7596,C10O6423C18O6443C23O6443C35O6432C58O6478C61O6508C66O6542C71O6549C76O6549C90O6531C128O6607C133O6612C143O6619C152O6653C158O6691C163O6653C169O6711C182O6721C186O6756C196O6788C204O6760C211O6822C224O6832C228O6918C235O6949C240O6956C248O6918C259O6987C267O7037C272O7044C277O6987C292O7064C297O7118C302O7146C307O7153C312O7119C318O7185C325O7190C330O7216C344O7363C358O7306C364O7386C370O7465C376O7226C380O7542C382O7542C383O7561C388O7583C408O7592,,
code-creation,LazyCompile,10,247373,0x216c29be024e,24,instantiate node:internal/modules/esm/module_job:98:14,0x216c44018d70,~
code-source-info,0x216c29be024e,112,2992,3126,C0O3010C6O3071C11O3071C15O3064C19O3109C23O3122,,
code-creation,LazyCompile,10,247544,0x216c29be0936,920,_instantiate node:internal/modules/esm/module_job:105:21,0x216c44018dc0,~
code-source-info,0x216c29be0936,112,3148,6410,C4O3148C29O3177C37O3177C42O3177C44O3229C48O3229C50O3532C54O3538C67O3532C97O3587C105O3615C111O3637C118O3652C126O3688C136O3688C142O3716C147O3763C153O3770C159O3788C165O3746C172O3825C178O3832C184O3832C203O3879C215O3879C219O4219C227O4224C236O4260C244O4286C254O4260C261O4396C273O4419C283O4396C289O4463C298O4507C313O4463C319O4602C331O4636C343O4602C350O4574C358O4593C366O4765C372O4772C378O4772C393O4754C421O4846C427O4853C433O4853C447O4835C475O4886C477O4897C482O4949C484O4959C488O5279C496O5300C502O5279C508O5368C514O5405C518O5428C531O5405C537O5479C547O5508C566O5567C577O5548C584O5629C591O5706C602O5822C617O5858C625O5909C644O5784C647O5489C651O5979C663O6002C673O5979C679O6026C691O6058C699O6038C703O6079C711O6089C719O6089C724O6087C728O6149C730O6149C731O6197C763O6180C794O6180C797O6355C801O6384C803O6382C807O6169C891O6409,,
code-creation,LazyCompile,10,247757,0x216c29be0f8e,179,addJobsToDependencyGraph node:internal/modules/esm/module_job:107:38,0x216c29be0698,~
code-source-info,0x216c29be0f8e,112,3229,3526,C10O3229C18O3258C23O3274C28O3274C35O3300C46O3307C47O3322C52O3334C57O3334C62O3395C74O3379C100O3409C111O3431C118O3458C123O3492C126O3458C134O3427C140O3416C154O3520,,
code-creation,LazyCompile,10,247911,0x216c29be1186,112,FileHandle node:internal/fs/promises:104:14,0x216c44022290,~
code-source-info,0x216c29be1186,116,2570,2736,C3O2589C11O2589C40O2602C45O2607C50O2616C54O2634C59O2639C67O2646C69O2670C77O2644C81O2684C86O2689C91O2696C95O2705C100O2710C104O2725C111O2735,,
code-creation,LazyCompile,10,247977,0x216c29be1316,63,MixedEventEmitter node:internal/event_target:698:16,0x216c4402b980,~
code-source-info,0x216c29be1316,38,19981,20111,C0O19981C8O19999C15O20006C21O20041C25O20050C29O20041C41O20063C48O20085C54O20063C62O20110,,
code-creation,LazyCompile,10,248035,0x216c29be143e,3, node:internal/per_context/primordials:276:21,0x216c014c9920,~
code-source-info,0x216c29be143e,6,7920,7949,C0O7931C2O7943,,
code-creation,LazyCompile,10,248242,0x216c29be16be,601,readFileHandle node:internal/fs/promises:313:30,0x216c44021660,~
code-source-info,0x216c29be16be,116,7255,9027,C10O7255C18O7296C25O7303C33O7316C37O7316C41O7360C47O7374C53O7391C64O7402C68O7374C82O7360C110O7420C114O7420C118O7449C120O7457C122O7472C129O7488C131O7486C138O7500C140O7496C145O7515C147O7532C153O7562C155O7579C157O7590C159O7588C164O7608C172O7614C177O7608C178O7666C180O7691C182O7711C183O7716C187O7741C190O7766C199O7787C203O7794C209O7794C215O7828C219O7828C223O7858C225O7874C227O7890C229O7902C233O7922C239O7938C247O7954C251O7938C257O7991C259O8009C266O8067C269O8094C272O8120C280O8142C287O8155C291O8129C297O8208C303O8223C309O8239C321O8313C334O8223C348O8209C379O8338C381O8351C388O8366C389O8388C396O8407C400O8421C405O8445C410O8479C412O8493C414O8489C418O8549C424O8580C433O8580C440O8607C446O8607C451O8666C455O7819C458O8686C460O8696C461O8705C466O8716C468O8735C477O8770C486O8770C495O8823C503O8830C509O8845C516O8851C520O8858C526O8858C533O8971C539O8989C545O9006C551O8989C568O9018C572O9025,,
tick,0x7ff808922ae6,248391,0,0x0,3,0x10739e050,0x216c29bdbfff,0x1076ecbbf
code-creation,LazyCompile,10,248428,0x216c29be1b16,8,get fd node:internal/fs/promises:117:9,0x216c44022348,~
code-source-info,0x216c29be1b16,116,2807,2837,C0O2816C2O2828C4O2827C7O2833,,
code-creation,LazyCompile,10,248546,0x216c29be1ca6,33,primordials.SafePromisePrototypeFinally node:internal/per_context/primordials:409:43,0x216c014ca308,~
code-source-info,0x216c29be1ca6,6,12020,12293,C0O12020C13O12153C27O12153C32O12293,,
code-creation,LazyCompile,10,248606,0x216c29be1e46,46, node:internal/per_context/primordials:412:15,0x216c29be1be8,~
code-source-info,0x216c29be1e46,6,12165,12289,C0O12279C14O12179C20O12253C28O12260C34O12278C39O12279C45O12289,,
code-creation,LazyCompile,10,248654,0x216c29be1f9e,27,SafePromise node:internal/per_context/primordials:393:16,0x216c014ca200,~
code-source-info,0x216c29be1f9e,6,11370,11401,C3O11383C7O11389C11O11383C26O11400,,
code-creation,LazyCompile,10,248782,0x216c29be20a6,22, node:internal/per_context/primordials:413:21,0x216c29be1d80,~
code-source-info,0x216c29be20a6,6,12195,12244,C0O12205C16O12205C21O12244,,
code-creation,LazyCompile,10,249477,0x216c29be21ae,19,allocUnsafeSlow node:buffer:381:50,0x216cb0d24b58,~
tick,0x7ff80884ea1f,249735,0,0x0,3,0x10739e050,0x216c29be178f,0x1076ecbbf
code-source-info,0x216c29be21ae,18,11171,11236,C0O11182C5O11182C9O11202C14O11209C18O11234,,
code-creation,LazyCompile,10,249819,0x216c29be22ce,54, node:buffer:347:36,0x216cb0d24a30,~
code-source-info,0x216c29be22ce,18,10149,10304,C0O10163C8O10163C13O10195C14O10206C21O10222C23O10219C28O10241C33O10273C46O10247C51O10241C53O10303,,
code-creation,LazyCompile,10,249875,0x216c29be2406,30,validateNumber node:internal/validators:122:24,0x216cb0d19dd8,~
code-source-info,0x216c29be2406,17,3532,3641,C0O3550C6O3585C22O3591C27O3585C29O3640,,
code-creation,LazyCompile,10,249934,0x216c29be2536,71,createUnsafeBuffer node:internal/buffer:1059:28,0x216cb0d31a68,~
code-source-info,0x216c29be2536,19,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
code-creation,LazyCompile,10,250705,0x216c29be2836,248,close node:internal/fs/promises:177:11,0x216c44024310,~
code-source-info,0x216c29be2836,116,3933,4723,C0O3945C7O3954C9O3953C15O3959C20O3975C27O3982C30O3999C31O4011C38O4020C40O4019C45O4044C52O4056C54O4055C57O4071C58O4083C65O4088C73O4094C77O4102C84O4111C86O4110C91O4118C96O4133C103O4138C108O4143C112O4155C119O4160C126O4177C136O4219C138O4218C142O4228C147O4228C157O4177C162O4175C168O4316C175O4321C182O4338C189O4379C199O4375C210O4338C215O4336C219O4668C222O4673C230O4673C235O4692C242O4704C244O4703C247O4719,,
code-creation,LazyCompile,10,250898,0x216c29be2bae,17, node:internal/fs/promises:191:9,0x216c29be2610,~
code-source-info,0x216c29be2bae,116,4245,4287,C0O4253C7O4258C11O4273C16O4286,,
code-creation,LazyCompile,10,250988,0x216c29be2d1e,83,assertBufferSource node:internal/modules/esm/translators:83:28,0x216c4402e580,~
code-source-info,0x216c29be2d1e,119,2388,2781,C0O2422C10O2473C11O2480C12O2535C15O2535C19O2495C24O2514C29O2554C35O2581C41O2611C42O2618C43O2625C50O2677C77O2631C82O2625,,
code-creation,LazyCompile,10,251048,0x216c29be2e86,31,lazyTypes node:internal/modules/esm/translators:24:19,0x216c4402e4e0,~
code-source-info,0x216c29be2e86,119,438,532,C0O445C6O466C10O480C11O483C17O499C24O497C30O530,,
code-creation,LazyCompile,10,251122,0x216c29be323e,40,defaultTransformSource node:internal/modules/esm/transform_source:3:32,0x216c4402d818,~
code-source-info,0x216c29be323e,118,46,157,C7O46C13O57C18O62C26O137C33O146C39O155,,
code-creation,LazyCompile,10,251206,0x216c29be33b6,72,stringify node:internal/modules/esm/translators:99:19,0x216c4402e5d0,~
code-source-info,0x216c29be33b6,119,2801,3001,C0O2812C6O2842C8O2854C9O2857C20O2857C25O2911C33O2944C36O2940C45O2960C50O2919C56O2971C61O2986C66O2986C71O2999,,
code-creation,LazyCompile,10,251327,0x216c29be356e,205,TextDecoder node:internal/encoding:382:16,0x216cb0d38430,~
script-source,21,node:internal/encoding,'use strict';\n\n// An implementation of the WHATWG Encoding Standard\n// https://encoding.spec.whatwg.org\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  SafeMap\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  Uint32Array\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_ENCODING_INVALID_ENCODED_DATA\x2C\n  ERR_ENCODING_NOT_SUPPORTED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_NO_ICU\n} = require('internal/errors').codes;\nconst kHandle = Symbol('handle');\nconst kFlags = Symbol('flags');\nconst kEncoding = Symbol('encoding');\nconst kDecoder = Symbol('decoder');\nconst kEncoder = Symbol('encoder');\n\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol: inspect\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\n\nconst { validateString } = require('internal/validators');\n\nconst {\n  encodeInto\x2C\n  encodeUtf8String\n} = internalBinding('buffer');\n\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === undefined)\n    Buffer = require('buffer').Buffer;\n  return Buffer;\n}\n\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS('TextEncoder');\n}\n\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS('TextDecoder');\n}\n\nfunction validateArgument(prop\x2C expected\x2C propName\x2C expectedName) {\n  // eslint-disable-next-line valid-typeof\n  if (typeof prop !== expected)\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C expectedName\x2C prop);\n}\n\nconst CONVERTER_FLAGS_FLUSH = 0x1;\nconst CONVERTER_FLAGS_FATAL = 0x2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\n\nconst empty = new Uint8Array(0);\n\nconst encodings = new SafeMap([\n  ['unicode-1-1-utf-8'\x2C 'utf-8']\x2C\n  ['utf8'\x2C 'utf-8']\x2C\n  ['utf-8'\x2C 'utf-8']\x2C\n  ['866'\x2C 'ibm866']\x2C\n  ['cp866'\x2C 'ibm866']\x2C\n  ['csibm866'\x2C 'ibm866']\x2C\n  ['ibm866'\x2C 'ibm866']\x2C\n  ['csisolatin2'\x2C 'iso-8859-2']\x2C\n  ['iso-8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso-ir-101'\x2C 'iso-8859-2']\x2C\n  ['iso8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso88592'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2:1987'\x2C 'iso-8859-2']\x2C\n  ['l2'\x2C 'iso-8859-2']\x2C\n  ['latin2'\x2C 'iso-8859-2']\x2C\n  ['csisolatin3'\x2C 'iso-8859-3']\x2C\n  ['iso-8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso-ir-109'\x2C 'iso-8859-3']\x2C\n  ['iso8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso88593'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3:1988'\x2C 'iso-8859-3']\x2C\n  ['l3'\x2C 'iso-8859-3']\x2C\n  ['latin3'\x2C 'iso-8859-3']\x2C\n  ['csisolatin4'\x2C 'iso-8859-4']\x2C\n  ['iso-8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso-ir-110'\x2C 'iso-8859-4']\x2C\n  ['iso8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso88594'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4:1988'\x2C 'iso-8859-4']\x2C\n  ['l4'\x2C 'iso-8859-4']\x2C\n  ['latin4'\x2C 'iso-8859-4']\x2C\n  ['csisolatincyrillic'\x2C 'iso-8859-5']\x2C\n  ['cyrillic'\x2C 'iso-8859-5']\x2C\n  ['iso-8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso-ir-144'\x2C 'iso-8859-5']\x2C\n  ['iso8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso88595'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5:1988'\x2C 'iso-8859-5']\x2C\n  ['arabic'\x2C 'iso-8859-6']\x2C\n  ['asmo-708'\x2C 'iso-8859-6']\x2C\n  ['csiso88596e'\x2C 'iso-8859-6']\x2C\n  ['csiso88596i'\x2C 'iso-8859-6']\x2C\n  ['csisolatinarabic'\x2C 'iso-8859-6']\x2C\n  ['ecma-114'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-e'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-i'\x2C 'iso-8859-6']\x2C\n  ['iso-ir-127'\x2C 'iso-8859-6']\x2C\n  ['iso8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso88596'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6:1987'\x2C 'iso-8859-6']\x2C\n  ['csisolatingreek'\x2C 'iso-8859-7']\x2C\n  ['ecma-118'\x2C 'iso-8859-7']\x2C\n  ['elot_928'\x2C 'iso-8859-7']\x2C\n  ['greek'\x2C 'iso-8859-7']\x2C\n  ['greek8'\x2C 'iso-8859-7']\x2C\n  ['iso-8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso-ir-126'\x2C 'iso-8859-7']\x2C\n  ['iso8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso88597'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7:1987'\x2C 'iso-8859-7']\x2C\n  ['sun_eu_greek'\x2C 'iso-8859-7']\x2C\n  ['csiso88598e'\x2C 'iso-8859-8']\x2C\n  ['csisolatinhebrew'\x2C 'iso-8859-8']\x2C\n  ['hebrew'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8-e'\x2C 'iso-8859-8']\x2C\n  ['iso-ir-138'\x2C 'iso-8859-8']\x2C\n  ['iso8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso88598'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8:1988'\x2C 'iso-8859-8']\x2C\n  ['visual'\x2C 'iso-8859-8']\x2C\n  ['csiso88598i'\x2C 'iso-8859-8-i']\x2C\n  ['iso-8859-8-i'\x2C 'iso-8859-8-i']\x2C\n  ['logical'\x2C 'iso-8859-8-i']\x2C\n  ['csisolatin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso-ir-157'\x2C 'iso-8859-10']\x2C\n  ['iso8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso885910'\x2C 'iso-8859-10']\x2C\n  ['l6'\x2C 'iso-8859-10']\x2C\n  ['latin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso885913'\x2C 'iso-8859-13']\x2C\n  ['iso-8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso885914'\x2C 'iso-8859-14']\x2C\n  ['csisolatin9'\x2C 'iso-8859-15']\x2C\n  ['iso-8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso885915'\x2C 'iso-8859-15']\x2C\n  ['iso_8859-15'\x2C 'iso-8859-15']\x2C\n  ['l9'\x2C 'iso-8859-15']\x2C\n  ['cskoi8r'\x2C 'koi8-r']\x2C\n  ['koi'\x2C 'koi8-r']\x2C\n  ['koi8'\x2C 'koi8-r']\x2C\n  ['koi8-r'\x2C 'koi8-r']\x2C\n  ['koi8_r'\x2C 'koi8-r']\x2C\n  ['koi8-ru'\x2C 'koi8-u']\x2C\n  ['koi8-u'\x2C 'koi8-u']\x2C\n  ['csmacintosh'\x2C 'macintosh']\x2C\n  ['mac'\x2C 'macintosh']\x2C\n  ['macintosh'\x2C 'macintosh']\x2C\n  ['x-mac-roman'\x2C 'macintosh']\x2C\n  ['dos-874'\x2C 'windows-874']\x2C\n  ['iso-8859-11'\x2C 'windows-874']\x2C\n  ['iso8859-11'\x2C 'windows-874']\x2C\n  ['iso885911'\x2C 'windows-874']\x2C\n  ['tis-620'\x2C 'windows-874']\x2C\n  ['windows-874'\x2C 'windows-874']\x2C\n  ['cp1250'\x2C 'windows-1250']\x2C\n  ['windows-1250'\x2C 'windows-1250']\x2C\n  ['x-cp1250'\x2C 'windows-1250']\x2C\n  ['cp1251'\x2C 'windows-1251']\x2C\n  ['windows-1251'\x2C 'windows-1251']\x2C\n  ['x-cp1251'\x2C 'windows-1251']\x2C\n  ['ansi_x3.4-1968'\x2C 'windows-1252']\x2C\n  ['ascii'\x2C 'windows-1252']\x2C\n  ['cp1252'\x2C 'windows-1252']\x2C\n  ['cp819'\x2C 'windows-1252']\x2C\n  ['csisolatin1'\x2C 'windows-1252']\x2C\n  ['ibm819'\x2C 'windows-1252']\x2C\n  ['iso-8859-1'\x2C 'windows-1252']\x2C\n  ['iso-ir-100'\x2C 'windows-1252']\x2C\n  ['iso8859-1'\x2C 'windows-1252']\x2C\n  ['iso88591'\x2C 'windows-1252']\x2C\n  ['iso_8859-1'\x2C 'windows-1252']\x2C\n  ['iso_8859-1:1987'\x2C 'windows-1252']\x2C\n  ['l1'\x2C 'windows-1252']\x2C\n  ['latin1'\x2C 'windows-1252']\x2C\n  ['us-ascii'\x2C 'windows-1252']\x2C\n  ['windows-1252'\x2C 'windows-1252']\x2C\n  ['x-cp1252'\x2C 'windows-1252']\x2C\n  ['cp1253'\x2C 'windows-1253']\x2C\n  ['windows-1253'\x2C 'windows-1253']\x2C\n  ['x-cp1253'\x2C 'windows-1253']\x2C\n  ['cp1254'\x2C 'windows-1254']\x2C\n  ['csisolatin5'\x2C 'windows-1254']\x2C\n  ['iso-8859-9'\x2C 'windows-1254']\x2C\n  ['iso-ir-148'\x2C 'windows-1254']\x2C\n  ['iso8859-9'\x2C 'windows-1254']\x2C\n  ['iso88599'\x2C 'windows-1254']\x2C\n  ['iso_8859-9'\x2C 'windows-1254']\x2C\n  ['iso_8859-9:1989'\x2C 'windows-1254']\x2C\n  ['l5'\x2C 'windows-1254']\x2C\n  ['latin5'\x2C 'windows-1254']\x2C\n  ['windows-1254'\x2C 'windows-1254']\x2C\n  ['x-cp1254'\x2C 'windows-1254']\x2C\n  ['cp1255'\x2C 'windows-1255']\x2C\n  ['windows-1255'\x2C 'windows-1255']\x2C\n  ['x-cp1255'\x2C 'windows-1255']\x2C\n  ['cp1256'\x2C 'windows-1256']\x2C\n  ['windows-1256'\x2C 'windows-1256']\x2C\n  ['x-cp1256'\x2C 'windows-1256']\x2C\n  ['cp1257'\x2C 'windows-1257']\x2C\n  ['windows-1257'\x2C 'windows-1257']\x2C\n  ['x-cp1257'\x2C 'windows-1257']\x2C\n  ['cp1258'\x2C 'windows-1258']\x2C\n  ['windows-1258'\x2C 'windows-1258']\x2C\n  ['x-cp1258'\x2C 'windows-1258']\x2C\n  ['x-mac-cyrillic'\x2C 'x-mac-cyrillic']\x2C\n  ['x-mac-ukrainian'\x2C 'x-mac-cyrillic']\x2C\n  ['chinese'\x2C 'gbk']\x2C\n  ['csgb2312'\x2C 'gbk']\x2C\n  ['csiso58gb231280'\x2C 'gbk']\x2C\n  ['gb2312'\x2C 'gbk']\x2C\n  ['gb_2312'\x2C 'gbk']\x2C\n  ['gb_2312-80'\x2C 'gbk']\x2C\n  ['gbk'\x2C 'gbk']\x2C\n  ['iso-ir-58'\x2C 'gbk']\x2C\n  ['x-gbk'\x2C 'gbk']\x2C\n  ['gb18030'\x2C 'gb18030']\x2C\n  ['big5'\x2C 'big5']\x2C\n  ['big5-hkscs'\x2C 'big5']\x2C\n  ['cn-big5'\x2C 'big5']\x2C\n  ['csbig5'\x2C 'big5']\x2C\n  ['x-x-big5'\x2C 'big5']\x2C\n  ['cseucpkdfmtjapanese'\x2C 'euc-jp']\x2C\n  ['euc-jp'\x2C 'euc-jp']\x2C\n  ['x-euc-jp'\x2C 'euc-jp']\x2C\n  ['csiso2022jp'\x2C 'iso-2022-jp']\x2C\n  ['iso-2022-jp'\x2C 'iso-2022-jp']\x2C\n  ['csshiftjis'\x2C 'shift_jis']\x2C\n  ['ms932'\x2C 'shift_jis']\x2C\n  ['ms_kanji'\x2C 'shift_jis']\x2C\n  ['shift-jis'\x2C 'shift_jis']\x2C\n  ['shift_jis'\x2C 'shift_jis']\x2C\n  ['sjis'\x2C 'shift_jis']\x2C\n  ['windows-31j'\x2C 'shift_jis']\x2C\n  ['x-sjis'\x2C 'shift_jis']\x2C\n  ['cseuckr'\x2C 'euc-kr']\x2C\n  ['csksc56011987'\x2C 'euc-kr']\x2C\n  ['euc-kr'\x2C 'euc-kr']\x2C\n  ['iso-ir-149'\x2C 'euc-kr']\x2C\n  ['korean'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1987'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1989'\x2C 'euc-kr']\x2C\n  ['ksc5601'\x2C 'euc-kr']\x2C\n  ['ksc_5601'\x2C 'euc-kr']\x2C\n  ['windows-949'\x2C 'euc-kr']\x2C\n  ['utf-16be'\x2C 'utf-16be']\x2C\n  ['utf-16le'\x2C 'utf-16le']\x2C\n  ['utf-16'\x2C 'utf-16le']\x2C\n]);\n\n// Unfortunately\x2C String.prototype.trim also removes non-ascii whitespace\x2C\n// so we have to do this manually\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (\n    label[s] === '\\u0009' ||\n    label[s] === '\\u000a' ||\n    label[s] === '\\u000c' ||\n    label[s] === '\\u000d' ||\n    label[s] === '\\u0020')) {\n    s++;\n  }\n  while (e > s && (\n    label[e - 1] === '\\u0009' ||\n    label[e - 1] === '\\u000a' ||\n    label[e - 1] === '\\u000c' ||\n    label[e - 1] === '\\u000d' ||\n    label[e - 1] === '\\u0020')) {\n    e--;\n  }\n  return StringPrototypeSlice(label\x2C s\x2C e);\n}\n\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== undefined) return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\n\nconst encodeIntoResults = new Uint32Array(2);\n\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n\n  get encoding() {\n    validateEncoder(this);\n    return 'utf-8';\n  }\n\n  encode(input = '') {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n\n  encodeInto(src\x2C dest) {\n    validateEncoder(this);\n    validateString(src\x2C 'src');\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE('dest'\x2C 'Uint8Array'\x2C dest);\n    encodeInto(src\x2C dest\x2C encodeIntoResults);\n    return { read: encodeIntoResults[0]\x2C written: encodeIntoResults[1] };\n  }\n\n  [inspect](depth\x2C opts) {\n    validateEncoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\n    });\n    obj.encoding = this.encoding;\n    // Lazy to avoid circular dependency\n    return require('internal/util/inspect').inspect(obj\x2C opts);\n  }\n}\n\nObjectDefineProperties(\n  TextEncoder.prototype\x2C {\n    'encode': { enumerable: true }\x2C\n    'encodeInto': { enumerable: true }\x2C\n    'encoding': { enumerable: true }\x2C\n    [SymbolToStringTag]: { configurable: true\x2C value: 'TextEncoder' }\x2C\n  });\n\nconst TextDecoder =\n  internalBinding('config').hasIntl ?\n    makeTextDecoderICU() :\n    makeTextDecoderJS();\n\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode\x2C\n    getConverter\x2C\n  } = internalBinding('icu');\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = {}) {\n      encoding = `${encoding}`;\n      validateArgument(options\x2C 'object'\x2C 'options'\x2C 'Object');\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      const handle = getConverter(enc\x2C flags);\n      if (handle === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      this[kDecoder] = true;\n      this[kHandle] = handle;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n    }\n\n\n    decode(input = empty\x2C options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (!isArrayBufferView(input)) {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateArgument(options\x2C 'object'\x2C 'options'\x2C 'Object');\n\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n\n      const ret = _decode(this[kHandle]\x2C input\x2C flags);\n      if (typeof ret === 'number') {\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding\x2C ret);\n      }\n      return ret.toString('ucs2');\n    }\n  }\n\n  return TextDecoder;\n}\n\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === undefined)\n      ({ StringDecoder } = require('string_decoder'));\n    return StringDecoder;\n  }\n\n  const kBOMSeen = Symbol('BOM seen');\n\n  function hasConverter(encoding) {\n    return encoding === 'utf-8' || encoding === 'utf-16le';\n  }\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = {}) {\n      encoding = `${encoding}`;\n      validateArgument(options\x2C 'object'\x2C 'options'\x2C 'Object');\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('"fatal" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n\n    decode(input = empty\x2C options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (isArrayBufferView(input)) {\n        input = lazyBuffer().from(input.buffer\x2C input.byteOffset\x2C\n                                  input.byteLength);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateArgument(options\x2C 'object'\x2C 'options'\x2C 'Object');\n\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\n        this[kHandle].end(input) :\n        this[kHandle].write(input);\n\n      if (result.length > 0 &&\n          !this[kBOMSeen] &&\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        // If the very first result in the stream is a BOM\x2C and we are not\n        // explicitly told to ignore it\x2C then we discard it.\n        if (result[0] === '\\ufeff') {\n          result = StringPrototypeSlice(result\x2C 1);\n        }\n        this[kBOMSeen] = true;\n      }\n\n      return result;\n    }\n  }\n\n  return TextDecoder;\n}\n\n// Mix in some shared properties.\nObjectDefineProperties(\n  TextDecoder.prototype\x2C\n  ObjectGetOwnPropertyDescriptors({\n    get encoding() {\n      validateDecoder(this);\n      return this[kEncoding];\n    }\x2C\n\n    get fatal() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n    }\x2C\n\n    get ignoreBOM() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\n              CONVERTER_FLAGS_IGNORE_BOM;\n    }\x2C\n\n    [inspect](depth\x2C opts) {\n      validateDecoder(this);\n      if (typeof depth === 'number' && depth < 0)\n        return this;\n      const constructor = getConstructorOf(this) || TextDecoder;\n      const obj = ObjectCreate({ constructor });\n      obj.encoding = this.encoding;\n      obj.fatal = this.fatal;\n      obj.ignoreBOM = this.ignoreBOM;\n      if (opts.showHidden) {\n        obj[kFlags] = this[kFlags];\n        obj[kHandle] = this[kHandle];\n      }\n      // Lazy to avoid circular dependency\n      const { inspect } = require('internal/util/inspect');\n      return `${constructor.name} ${inspect(obj)}`;\n    }\n  })\n);\n\nObjectDefineProperties(TextDecoder.prototype\x2C {\n  decode: { enumerable: true }\x2C\n  [inspect]: { enumerable: false }\x2C\n  [SymbolToStringTag]: {\n    configurable: true\x2C\n    value: 'TextDecoder'\n  }\n});\n\nmodule.exports = {\n  getEncodingFromLabel\x2C\n  TextDecoder\x2C\n  TextEncoder\n};\n
code-source-info,0x216c29be356e,21,10490,11206,C15O10490C21O10533C25O10565C42O10565C47O10642C52O10642C57O10680C59O10711C68O10717C73O10711C74O10778C76O10787C80O10836C93O10844C102O10896C115O10908C124O10970C129O10970C135O11002C137O11036C146O11042C151O11036C152O11091C156O11096C160O11106C164O11120C168O11125C173O11134C177O11150C181O11155C186O11163C190O11178C194O11183C199O11194C204O11205,,
tick,0x7ff80896f266,253086,0,0x0,3,0x1073aea10,0x216c29be33da,0x216c29bdaaed,0x1076ecbbf
code-creation,LazyCompile,10,253131,0x216c29be498e,35,validateArgument node:internal/encoding:66:26,0x216cb0d38120,~
code-source-info,0x216c29be498e,21,1376,1561,C0O1464C6O1480C11O1498C27O1504C32O1498C34O1560,,
code-creation,LazyCompile,10,253194,0x216c29be4ace,55,getEncodingFromLabel node:internal/encoding:316:30,0x216cb0d381c0,~
code-source-info,0x216c29be4ace,21,8836,8986,C0O8860C5O8870C10O8870C16O8884C18O8907C20O8918C21O8921C26O8938C34O8968C39O8968C44O8942C49O8938C54O8984,,
tick,0x7ff8088bd68b,253286,0,0x0,3,0x10739e050,0x216c29be35a2,0x216c29be33da,0x216c29bdaaed,0x1076ecbbf
code-creation,LazyCompile,10,253373,0x216c29be4da6,226,decode node:internal/encoding:407:11,0x216cb0d38550,~
code-source-info,0x216c29be4da6,21,11219,11973,C8O11228C25O11257C30O11257C34O11286C41O11290C47O11325C52O11333C56O11345C61O11346C69O11372C76O11377C82O11413C102O11419C107O11413C108O11589C125O11589C130O11666C132O11675C136O11722C152O11735C158O11777C167O11790C169O11789C179O11777C185O11821C189O11860C196O11909C206O11866C211O11860C212O11950C220O11950C225O11967,,
code-creation,LazyCompile,10,253463,0x216c29be4fce,37,validateDecoder node:internal/encoding:61:25,0x216cb0d380d0,~
code-source-info,0x216c29be4fce,21,1248,1349,C0O1258C7O1281C9O1280C14O1291C19O1305C29O1311C34O1305C36O1348,,
code-creation,LazyCompile,10,253557,0x216c29be5156,162,toString node:buffer:781:46,0x216cb0d26970,~
code-source-info,0x216c29be5156,18,23244,23806,C0O23244C2O23285C8O23292C13O23317C20O23335C25O23317C31O23343C32O23368C37O23379C38O23389C43O23399C48O23417C50O23427C55O23439C57O23449C58O23461C65O23476C71O23505C76O23516C83O23538C90O23551C92O23559C97O23573C99O23583C100O23587C104O23631C109O23631C115O23653C116O23669C119O23669C124O23697C126O23724C133O23730C138O23724C139O23780C156O23780C161O23804,,
code-creation,LazyCompile,10,253684,0x216c29be540e,503,getEncodingOps node:buffer:677:24,0x216cb0d267c8,~
code-source-info,0x216c29be540e,18,19911,21712,C0O19926C10O19961C66O19989C68O20002C73O20014C78O20033C82O20038C83O20045C85O20058C90O20070C95O20089C99O20094C100O20101C105O20112C111O20156C113O20169C118O20181C123O20200C127O20205C128O20212C130O20225C135O20237C140O20256C144O20261C145O20268C147O20293C149O20306C154O20319C159O20338C163O20343C164O20350C166O20363C171O20376C176O20395C180O20401C181O20408C183O20421C188O20434C193O20453C197O20458C198O20465C203O20476C209O20520C211O20533C216O20546C221O20565C225O20570C226O20577C228O20590C233O20603C238O20622C242O20628C243O20635C245O20648C250O20661C255O20680C259O20685C260O20692C262O20717C264O20730C271O20757C274O20757C281O20794C286O20817C291O20836C295O20844C296O20851C298O20876C300O20889C307O20917C310O20917C317O20954C322O20978C327O20997C331O21005C332O21012C334O21037C336O21050C343O21075C348O21097C353O21116C357O21123C358O21130C360O21143C365O21157C370O21176C374O21183C375O21190C380O21201C386O21245C388O21258C395O21283C400O21305C405O21324C409O21331C410O21338C412O21351C417O21365C422O21384C426O21391C427O21398C429O21423C431O21436C438O21449C441O21449C448O21486C453O21505C458O21524C462O21528C463O21535C465O21560C467O21573C474O21602C477O21602C484O21639C489O21664C494O21683C498O21693C499O21700C502O21711,,
code-creation,LazyCompile,10,253794,0x216c29be57fe,12,slice node:buffer:601:12,0x216cb0d25478,~
code-source-info,0x216c29be57fe,18,16951,16997,C0O16976C5O16976C11O16997,,
code-creation,LazyCompile,10,253899,0x216c29be5ab6,229,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x216c44007340,~
code-source-info,0x216c29be5ab6,104,2239,3273,C0O2308C3O2308C7O2334C10O2348C15O2352C23O2372C25O2392C26O2399C30O2412C35O2423C44O2421C54O2564C64O2574C69O2564C73O2586C74O2593C75O2614C80O2640C85O2614C91O2717C93O2747C96O2775C101O2782C106O2747C112O2817C117O2837C122O2844C127O2866C131O2897C136O2915C141O2919C148O2948C155O2979C165O3009C171O3023C175O2915C183O3149C188O3167C193O3171C201O3204C211O3234C217O3248C221O3167C228O3272,,
code-creation,LazyCompile,10,253968,0x216c29be6526,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x216c440072a0,~
code-source-info,0x216c29be6526,104,1418,1563,C0O1425C6O1468C11O1489C17O1489C22O1468C26O1536C30O1561,,
code-creation,LazyCompile,10,254028,0x216c29be66ae,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x216c440072f0,~
code-source-info,0x216c29be66ae,104,1594,2209,C0O1604C8O1604C13O1709C19O1709C24O1648C29O1674C34O1738C38O1767C42O1822C48O1822C53O1796C58O1878C64O1936C70O2095C76O2095C81O2068C86O2127C90O2183C92O2201C99O2208,,
code-creation,LazyCompile,10,254080,0x216c29be6836,30,validateBoolean node:internal/validators:138:25,0x216cb0d19e98,~
code-source-info,0x216c29be6836,17,4042,4153,C0O4060C6O4096C22O4102C27O4096C29O4152,,
code-creation,LazyCompile,10,254129,0x216c29be693e,10, node:internal/modules/esm/translators:48:63,0x216c4402e828,~
code-source-info,0x216c29be693e,119,1223,1248,C0O1235C2O1241C9O1247,,
code-creation,Script,10,254194,0x216c29be6b2e,45, file:///Users/julian/Desktop/FullStack%20dev/BackEnd/desafioLoggers/src/child.js:1:1,0x216c29be6a00,~
script-source,123,file:///Users/julian/Desktop/FullStack%20dev/BackEnd/desafioLoggers/src/child.js,// const randoms = (cant) => {\n//     let obj = {}\n//     if(!isNaN(cant)){\n//         for(let i = 0;i<cant;i++){\n//             let num = Math.floor(Math.random()*1000)+1\n//             if(obj[num]){\n//                 obj[num] += 1\n//             } else {\n//                 obj[num]=1\n//             }\n//         }\n//     }\n//     return obj\n// }\n\n\n// process.on('message'\x2Ccant=>{\n//    let result = randoms(cant)\n//    process.send(result)\n// })\n\n
code-source-info,0x216c29be6b2e,123,0,451,C10O0C15O0C35O0C44O451,,
tick,0x107284e7a,254545,0,0x0,0,0x1073a49d0,0x216c29be6b38,0x106cc4160,0x216c29be09ee,0x1076ecbbf
code-creation,LazyCompile,10,254587,0x216c29be6f46,307,removeListener node:events:561:28,0x216c014f2778,~
code-source-info,0x216c29be6f46,13,16175,17446,C0O16200C3O16200C7O16252C12O16267C14O16301C16O16313C17O16334C19O16340C23O16354C25O16386C27O16398C28O16406C30O16415C35O16436C42O16445C47O16469C54O16480C59O16493C64O16510C66O16525C71O16525C75O16523C81O16570C83O16584C85O16612C91O16645C99O16679C114O16645C121O16725C127O16782C130O16813C134O16820C138O16827C139O16827C144O16850C146O16858C152O16862C159O16882C163O16886C170O16895C175O16923C180O16949C182O16834C187O16795C190O16987C191O17000C196O17015C198O17027C199O17037C200O17050C205O17072C210O17072C216O17106C222O17147C228O17159C233O17183C240O17157C246O17205C251O17205C256O17260C263O17267C268O17284C269O17303C272O17297C276O17328C282O17373C299O17373C304O17428C306O17440,,
code-creation,LazyCompile,10,254728,0x216c29be7236,64,stopListeningIfSignal node:internal/process/signal:43:31,0x216c4dfbd0d0,~
code-source-info,0x216c29be7236,88,936,1101,C0O960C5O972C10O972C16O985C21O1019C26O1019C33O1039C38O1057C43O1057C47O1070C52O1082C57O1088C63O1100,,
code-creation,LazyCompile,10,254783,0x216c29be738e,30,onRemoveListener node:child_process:179:57,0x216c1597e4d8,~
code-source-info,0x216c29be738e,95,5298,5387,C0O5311C2O5320C9O5342C14O5360C19O5368C24O5368C29O5386,,
profiler,end
delete,MemoryChunk,0x216c014c0000
delete,MemoryChunk,0x216cb0d00000
delete,MemoryChunk,0x216c14540000
delete,MemoryChunk,0x216c18bc0000
delete,MemoryChunk,0x216c4df80000
delete,MemoryChunk,0x216c9d840000
delete,MemoryChunk,0x216c76000000
delete,MemoryChunk,0x216c3ae80000
delete,MemoryChunk,0x216c20640000
delete,MemoryChunk,0x216c7df40000
delete,MemoryChunk,0x216c15940000
delete,MemoryChunk,0x216c44000000
delete,MemoryChunk,0x216c29bc0000
delete,MemoryChunk,0x10cf00000
delete,MemoryChunk,0x216cd6d40000
delete,MemoryChunk,0x216c70d80000
delete,MemoryChunk,0x216c28400000
delete,MemoryChunk,0x216c85fc0000
delete,MemoryChunk,0x216cb6bc0000
delete,MemoryChunk,0x216c3c140000
delete,MemoryChunk,0x216c1fdc0000
